{"title":"C5 优化程序性能","uid":"43e79f6e161596f1d8a3c8c2b15157f9","slug":"CSAPP/C5-优化程序性能","date":"2021-09-01T03:34:30.000Z","updated":"2021-09-05T07:45:29.000Z","comments":true,"path":"api/articles/CSAPP/C5-优化程序性能.json","keywords":null,"cover":[],"content":"<h1 id=\"优化程序性能\"><a href=\"#优化程序性能\" class=\"headerlink\" title=\"优化程序性能\"></a>优化程序性能</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>写程序最主要的目标：在所有可能的情况下都正确工作</p>\n<p>编写程序需要做到</p>\n<ul>\n<li>选择适当的算法和数据结构</li>\n<li>编写出编译器能够有效优化以转换成高效可执行代码的源代码<ul>\n<li>即使是最好的编译器也收到<strong>optimization blocker</strong>的阻碍，即<strong>严重依赖于执行环境的方面</strong></li>\n</ul>\n</li>\n<li>将一个任务分成多个部分</li>\n</ul>\n<p>程序优化</p>\n<ul>\n<li>消除不必要的工作<ul>\n<li>消除不必要的函数调用、条件测试、内存引用</li>\n</ul>\n</li>\n<li>利用处理器提供的指令级并行能力，同时执行多条指令</li>\n</ul>\n<p>profiler的作用</p>\n<ul>\n<li>测量程序各个部分性能的工具</li>\n<li>帮助找到代码中低效率的地方，并且确定程序中应该着重优化的部分</li>\n</ul>\n<p>修改source code vs 用汇编语言编写</p>\n<ul>\n<li>修改source code：可移植性强</li>\n<li>汇编语言：性能好</li>\n</ul>\n<h2 id=\"优化编译器的能力和局限性\"><a href=\"#优化编译器的能力和局限性\" class=\"headerlink\" title=\"优化编译器的能力和局限性\"></a>优化编译器的能力和局限性</h2><p>optimization blocker</p>\n<ul>\n<li>特殊情况<ul>\n<li>不同指针指向内存中的同一个位置</li>\n<li>……</li>\n</ul>\n</li>\n<li>函数调用</li>\n</ul>\n<h2 id=\"表示程序性能\"><a href=\"#表示程序性能\" class=\"headerlink\" title=\"表示程序性能\"></a>表示程序性能</h2><p>Cycles Per Element：每元素周期数，帮助我们在更细节的级别上理解迭代程序的循环性能</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gu5retr6orj615w0s00vh02.jpg\" alt=\"截屏2021-09-05 下午2.58.45\"></p>\n<h2 id=\"程序示例\"><a href=\"#程序示例\" class=\"headerlink\" title=\"程序示例\"></a>程序示例</h2><h2 id=\"消除循环的低效率\"><a href=\"#消除循环的低效率\" class=\"headerlink\" title=\"消除循环的低效率\"></a>消除循环的低效率</h2><h2 id=\"减少过程调用\"><a href=\"#减少过程调用\" class=\"headerlink\" title=\"减少过程调用\"></a>减少过程调用</h2><h2 id=\"消除不必要的内存引用\"><a href=\"#消除不必要的内存引用\" class=\"headerlink\" title=\"消除不必要的内存引用\"></a>消除不必要的内存引用</h2><h2 id=\"理解现代处理器\"><a href=\"#理解现代处理器\" class=\"headerlink\" title=\"理解现代处理器\"></a>理解现代处理器</h2><h3 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h3><ul>\n<li>之前的优化都<strong>不依赖于目标机器的任何特性</strong>，只是<strong>降低过程调用的开销</strong>，消除一些critical “optimization blockers”</li>\n<li>需进一步提高性能，则考虑利用<strong>处理器微体系结构的优化</strong>，即处理器用来执行指令的<strong>底层系统设计</strong></li>\n</ul>\n<p>现代处理器的<strong>指令级并行<em>instruction-level parallelism</em></strong></p>\n<p>即：多条指令可以并行地执行，同时又呈现出一种简单的顺序执行指令的表象</p>\n<ul>\n<li>复杂硬件➡️程序性能最大化➡️处理器实际操作与通过观察机器级程序所察觉到的大相径庭<ul>\n<li>代码级：顺序执行指令</li>\n<li>实际处理器：同时对多条指令求值</li>\n</ul>\n</li>\n</ul>\n<p>两种下界描述了程序的最大性能</p>\n<ul>\n<li>latency bound➡️一系列操作必须按照严格顺序执行时</li>\n<li>throughput bound➡️处理器功能单元原始计算能力</li>\n</ul>\n<h3 id=\"Overall-Operation\"><a href=\"#Overall-Operation\" class=\"headerlink\" title=\"Overall Operation\"></a>Overall Operation</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>处理器类型</th>\n<th>硬件</th>\n<th>指令并行度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><em>in-order</em> pipeline</td>\n<td>简单</td>\n<td>低</td>\n</tr>\n<tr>\n<td>out-of-order processors</td>\n<td>复杂</td>\n<td>高</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>名词</th>\n<th>英文</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>超标量</td>\n<td>superscalar</td>\n<td>可以在每个时钟周期执行多个操作</td>\n</tr>\n<tr>\n<td>乱序</td>\n<td>out-of-order</td>\n<td>指令执行的顺序 不一定要与它们在机器级程序中的顺序一致</td>\n</tr>\n<tr>\n<td>指令控制单元</td>\n<td>ICU,Instruction Control Unit</td>\n<td>从内存中读出指令序列<br />并根据指令序列生成一组针对程序数据的基本操作</td>\n</tr>\n<tr>\n<td>执行单元</td>\n<td>EU,Execution Unit</td>\n<td>执行操作</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gu5j93c5yrj61d40u0dmn02.jpg\" alt=\"截屏2021-09-05 上午10.14.14\"></p>\n<h4 id=\"Branch-Prediction\"><a href=\"#Branch-Prediction\" class=\"headerlink\" title=\"Branch Prediction\"></a>Branch Prediction</h4><pre class=\"mermaid\">graph TD\n处理器开始取出位于它预测的分支会跳到的地方的指令\n--> 对指令译码 \n--> BranchPrediction\n--yes?--> 执行操作\n\n\nBranchPrediction\n--no?--> 将状态重新设置到分支点状态 --> 开始取出和执行另一个方向上的指令</pre>\n\n<h4 id=\"Instruction-Decoding\"><a href=\"#Instruction-Decoding\" class=\"headerlink\" title=\"Instruction Decoding\"></a>Instruction Decoding</h4><pre class=\"mermaid\">graph TD\n实际的程序指令\n\n--InstructionDecoding--> 一组基本操作/微操作</pre>\n\n<h4 id=\"Function-Unit-for-Intel-Core-i7-Haswell\"><a href=\"#Function-Unit-for-Intel-Core-i7-Haswell\" class=\"headerlink\" title=\"Function Unit for Intel Core i7 Haswell\"></a>Function Unit for Intel Core i7 Haswell</h4><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gu5je0r4ocj61qh0hq7at02.jpg\" alt=\"IMG_67CC58845882-1\"></p>\n<h4 id=\"Retirement-Unit\"><a href=\"#Retirement-Unit\" class=\"headerlink\" title=\"Retirement Unit\"></a>Retirement Unit</h4><p>记录正在进行的处理，并确保它遵守机器级程序的顺序语义</p>\n<pre class=\"mermaid\">graph TD\n指令译码时信息被放置在一个先进先出的队列\n--> 信息一致保持在队列中\n--> 指令操作完成 --> 指令retired\n\n信息一致保持在队列中\n--> 引起指令的分支点被确认为预测正确 --> 指令retired \n--> 对程序寄存器的更新都可以被实际执行了\n\n信息一致保持在队列中\n--> 引起指令的某个分支点被确认为预测错误\n--> 指令flushed --> 丢弃所有计算结果 --> 预测错误就不会改变程序的状态</pre>\n\n<h4 id=\"并行化实现方法\"><a href=\"#并行化实现方法\" class=\"headerlink\" title=\"并行化实现方法\"></a><strong>并行化实现方法</strong></h4><ul>\n<li>通过执行单元之间的operation result的<strong>信息交换</strong>，某条指令分支预测<strong>皆</strong>正确，则<strong>提前</strong>实现对程序寄存器的更新，<strong>加速</strong>指令到另一条指令的结构的传送，实现<strong>指令并行化</strong>。</li>\n</ul>\n<h4 id=\"Register-Renaming\"><a href=\"#Register-Renaming\" class=\"headerlink\" title=\"Register Renaming\"></a>Register Renaming</h4><ul>\n<li>本质：数据转发</li>\n<li>作用<ul>\n<li>值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件再读出来</li>\n<li>使得第二个操作能够在第一个操作完成后尽快开始</li>\n</ul>\n</li>\n</ul>\n<pre class=\"mermaid\">graph TD\n更新寄存器r的指令译码时产生标记t\n--> 条目r,t被加入到一张表中\n--> 该表维护着每个程序寄存器r与会更新该寄存器的操作标记t之间的关联\n--> 以寄存器r作为操作数的指令译码时\n--> 发送到执行单元的操作会包含t作为操作数源的值\n--某个执行单元完成第一个操作时-->产生结果v,t指明标记为t的操作产生值v\n--> 所有等待t作为源的操作都能使用v作为源值</pre>\n\n<h3 id=\"Functional-Unit-Performance\"><a href=\"#Functional-Unit-Performance\" class=\"headerlink\" title=\"Functional Unit Performance\"></a>Functional Unit Performance</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>performance</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>latency</td>\n<td>完成运算所需要的总时间</td>\n</tr>\n<tr>\n<td>issue time</td>\n<td>两个连续的同类型的运算之间需要的最小时钟周期数</td>\n</tr>\n<tr>\n<td>capacity</td>\n<td>能够执行该运算的功能单元的数量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gu5qn7ptbfj614m0gmgoz02.jpg\" alt=\"截屏2021-09-05 下午2.31.58\"></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>bound</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>latency bound</td>\n<td>给出了任何必须按照严格顺序完成合并运算的函数所需要的最小CPE值</td>\n</tr>\n<tr>\n<td>throughput bound</td>\n<td>给出了CPE的最小界限</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gu5qn930dij611u07u0t702.jpg\" alt=\"截屏2021-09-05 下午2.32.14\"></p>\n<h3 id=\"An-Abstract-Model-of-Processor-Operation\"><a href=\"#An-Abstract-Model-of-Processor-Operation\" class=\"headerlink\" title=\"An Abstract Model of Processor Operation\"></a>An Abstract Model of Processor Operation</h3><p>data-flow：一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的</p>\n<p>critical-path：执行一组机器指令所需时钟周期数的一个下界</p>\n<h4 id=\"From-Machine-Level-Code-to-Data-Flow-Graphs\"><a href=\"#From-Machine-Level-Code-to-Data-Flow-Graphs\" class=\"headerlink\" title=\"From Machine-Level Code to Data-Flow Graphs\"></a>From Machine-Level Code to Data-Flow Graphs</h4><p>data-flow：</p>\n<ul>\n<li>非正式</li>\n<li>用其形象描述程序中数据相关如何主宰程序的性能</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gu5rovto7vj61pk0gkadn02.jpg\" alt=\"截屏2021-09-05 下午3.05.47\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gu5ryjsbqpj61o40qsgqd02.jpg\" alt=\"截屏2021-09-05 下午3.08.45\"></p>\n<p>对于形成循环的代码片段，我们可以将访问到的寄存器分成四类</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>寄存器类别</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><em>Read-only.</em></td>\n<td>只用作源值，可以作为数据，也可以用来计算内存地址<br />但是在循环中不会被修改</td>\n</tr>\n<tr>\n<td><em>Write-only.</em></td>\n<td>作为数据传送操作的目的</td>\n</tr>\n<tr>\n<td><em>Local.</em></td>\n<td>在循环内部被修改和使用，迭代与迭代之间不相关</td>\n</tr>\n<tr>\n<td><em>Loop.</em></td>\n<td>既作为源值，又作为目的，一次迭代中产生的值会在另一次迭代中用到</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>将combine4的操作抽象成数据流图</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gu5s2ox150j61q60kuaef02.jpg\" alt=\"截屏2021-09-05 下午3.19.26\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gu5sconbdqj61ba0u0q6202.jpg\" alt=\"截屏2021-09-05 下午3.27.59\"></p>\n<h4 id=\"Other-Performance-Factors\"><a href=\"#Other-Performance-Factors\" class=\"headerlink\" title=\"Other Performance Factors\"></a>Other Performance Factors</h4><p>data-flow表示中的critical path提供的只是程序需要周期数的下界，还有其他一些因素会限制性能</p>\n<ul>\n<li>可用的功能单元数量</li>\n<li>任何一步中功能单元之间能够传递数据值的数量</li>\n</ul>\n<h2 id=\"循环展开\"><a href=\"#循环展开\" class=\"headerlink\" title=\"循环展开\"></a>循环展开</h2>","text":"优化程序性能引入写程序最主要的目标：在所有可能的情况下都正确工作 编写程序需要做到 选择适当的算法和数据结构 编写出编译器能够有效优化以转换成高效可执行代码的源代码 即使是最好的编译器也收到optimization blocker的阻碍，即严重依赖于执行环境的方面 将一个任务分成...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"CSAPP","slug":"CSAPP","count":8,"path":"api/categories/CSAPP.json"}],"tags":[{"name":"CSAPP","slug":"CSAPP","count":8,"path":"api/tags/CSAPP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">优化程序性能</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">引入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%83%BD%E5%8A%9B%E5%92%8C%E5%B1%80%E9%99%90%E6%80%A7\"><span class=\"toc-text\">优化编译器的能力和局限性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E7%A4%BA%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">表示程序性能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">程序示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E9%99%A4%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%8E%E6%95%88%E7%8E%87\"><span class=\"toc-text\">消除循环的低效率</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%8F%E5%B0%91%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">减少过程调用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">消除不必要的内存引用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8\"><span class=\"toc-text\">理解现代处理器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Intro\"><span class=\"toc-text\">Intro</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Overall-Operation\"><span class=\"toc-text\">Overall Operation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Branch-Prediction\"><span class=\"toc-text\">Branch Prediction</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Instruction-Decoding\"><span class=\"toc-text\">Instruction Decoding</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Function-Unit-for-Intel-Core-i7-Haswell\"><span class=\"toc-text\">Function Unit for Intel Core i7 Haswell</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Retirement-Unit\"><span class=\"toc-text\">Retirement Unit</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E8%A1%8C%E5%8C%96%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">并行化实现方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Register-Renaming\"><span class=\"toc-text\">Register Renaming</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Functional-Unit-Performance\"><span class=\"toc-text\">Functional Unit Performance</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Abstract-Model-of-Processor-Operation\"><span class=\"toc-text\">An Abstract Model of Processor Operation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#From-Machine-Level-Code-to-Data-Flow-Graphs\"><span class=\"toc-text\">From Machine-Level Code to Data-Flow Graphs</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Other-Performance-Factors\"><span class=\"toc-text\">Other Performance Factors</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80\"><span class=\"toc-text\">循环展开</span></a></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C6 存储器层次结构","uid":"ef5fe063a7d3aa88da43f1d6119bbac2","slug":"CSAPP/C6-存储器层次结构","date":"2021-09-05T07:45:30.000Z","updated":"2021-09-06T12:09:56.000Z","comments":true,"path":"api/articles/CSAPP/C6-存储器层次结构.json","keywords":null,"cover":null,"text":"存储器层次结构引入存储技术局部性存储器层次结构高速缓存存储器编写高速缓存友好的代码综合：高速缓存对程序性能的影响","link":"","photos":[],"count_time":{"symbolsCount":56,"symbolsTime":"1 mins."},"categories":[{"name":"CSAPP","slug":"CSAPP","count":8,"path":"api/categories/CSAPP.json"}],"tags":[{"name":"CSAPP","slug":"CSAPP","count":8,"path":"api/tags/CSAPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"hexo1 博客搭建(MacOS BigSur11.5)","uid":"a36fe725225b00ec2046a714dc5f7085","slug":"hexo/保姆级hexo博客搭建教程","date":"2021-08-31T15:42:53.000Z","updated":"2021-08-31T15:45:43.000Z","comments":true,"path":"api/articles/hexo/保姆级hexo博客搭建教程.json","keywords":null,"cover":null,"text":"https://blog.csdn.net/jingbin_/article/details/79536467 依赖安装","link":"","photos":[],"count_time":{"symbolsCount":60,"symbolsTime":"1 mins."},"categories":[{"name":"Hexo","slug":"Hexo","count":1,"path":"api/categories/Hexo.json"}],"tags":[{"name":"Hexo","slug":"Hexo","count":1,"path":"api/tags/Hexo.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}