{"title":"CPP8 编写泛型函数","uid":"916993f3303db0d9f66253cbc5cc5316","slug":"CPP/C8 编写泛型函数","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:48:58.000Z","comments":true,"path":"api/articles/CPP/C8 编写泛型函数.json","keywords":null,"cover":null,"content":"<h1 id=\"编写泛型函数\"><a href=\"#编写泛型函数\" class=\"headerlink\" title=\"编写泛型函数\"></a>编写泛型函数</h1><p>本书第一部分：编写程序以便解决某些具体问题</p>\n<ul>\n<li>使用c++语言基本要素以及标准库提供的抽象</li>\n</ul>\n<p>从这一章开始：学习编写抽象的方法</p>\n<ul>\n<li>C8 讨论泛型函数</li>\n<li>C9-C12 演示如何实现抽象数据类型</li>\n</ul>\n<p>从C13开始：学习面向对象程序设计方法OOP</p>\n<h2 id=\"什么是泛型函数\"><a href=\"#什么是泛型函数\" class=\"headerlink\" title=\"什么是泛型函数\"></a>什么是泛型函数</h2><p>表面上看，我们在编写函数时都要清楚函数的参数以及返回值的类型</p>\n<p>实际上，我们已经用过了那些在使用之前并不知道其参数以及返回类型的函数</p>\n<p>例如：</p>\n<ul>\n<li><code>find</code>函数在任何种类的容器中查找任何类型适当的值</li>\n<li>上述用法表明了：我们在使用<code>find</code>函数之前，并不知道它的参数或返回类型是什么</li>\n</ul>\n<p>语言支持泛型函数并非难事，但是当我们说<code>find</code>函数能接受“任何适当类型”的参数时，我们表达的意思是什么？如：</p>\n<p>我们想让希望使用<code>find</code>函数的人知道它对特定类型参数是否有效，该如何描述这个函数的行为？</p>\n<p>答案分为两部分</p>\n<ul>\n<li>位于语言内部：函数对一个未知类型的参数的<strong>使用方式</strong>会对这个参数的<strong>类型</strong>产生<strong>约束</strong><ul>\n<li>eg：<code>x+y</code> requires <code>x,y</code> has the specific type for which <code>x+y</code> is defined</li>\n</ul>\n</li>\n<li>位于语言外部：标准库对其函数参数的约束条件所采用的组织方式<ul>\n<li>eg：迭代器<ul>\n<li>A type is an iterator if and only if it supports a particular collection of operations in a particular way</li>\n<li>迭代器概念并非C++所特有，但它是标准库组织的一个基本组成部分</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"未知类型的中值\"><a href=\"#未知类型的中值\" class=\"headerlink\" title=\"未知类型的中值\"></a>未知类型的中值</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>名词</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模板函数</td>\n<td>实现泛型函数的语言特征</td>\n</tr>\n<tr>\n<td>模板</td>\n<td>允许我们为一个行为特性相似的函数族（类型族）编写一个单独的定义</td>\n</tr>\n<tr>\n<td>族中各个函数（或类型）间差别</td>\n<td>归因于它们的模板参数的类型不同</td>\n</tr>\n<tr>\n<td>模板背后的关键概念</td>\n<td>不同类型的对象仍然可以享有共同的行为特性</td>\n</tr>\n<tr>\n<td>模板参数</td>\n<td>允许我们按照共同的行为特性编写程序</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><code>median_template.cpp</code></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\nT <span class=\"token function\">median</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> v<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">typedef</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">vector</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>size_type vec_sz<span class=\"token punctuation\">;</span>\n    vec_sz size <span class=\"token operator\">=</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>size <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token function\">domain_error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"median of an empty vector\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>v<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        vec_sz mid <span class=\"token operator\">=</span> size<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> size <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>v<span class=\"token punctuation\">[</span>mid<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span><span class=\"token number\">2</span> <span class=\"token operator\">:</span> v<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>template &lt;class T&gt;</code></td>\n<td>模板头<br />告知系统环境，我们定义的是一个模板函数，而且这个函数将有一个类型参数<br />T出现时认为T命名了一个类型</td>\n</tr>\n<tr>\n<td><code>typename</code></td>\n<td>告知系统环境，<code>vector&lt;T&gt;::size_type</code>是一个类型名，即使系统环境还不知道类型T具体代表什么</td>\n</tr>\n<tr>\n<td><code>(v[mid]+v[mid-1])/2</code></td>\n<td>在了解了v的元素类型下，才会知道<code>v[mid]</code>和<code>v[mid-1]</code>的类型</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"模板实例化\"><a href=\"#模板实例化\" class=\"headerlink\" title=\"模板实例化\"></a>模板实例化</h3><p>对<code>vector&lt;int&gt;</code>类型调用median→系统环境高效创建并编译这个函数的一个实例→使用int代替所有对T的使用</p>\n<p>对<code>vector&lt;double&gt;</code>类型调用median→系统环境高效创建并编译这个函数的一个实例→使用double代替所有对T的使用</p>\n<p>也即：系统环境产生了两个版本的median</p>\n<p>当我们无法确切说明编译器将如何处理实例化时，应该牢记：</p>\n<ul>\n<li>edit-compile-link，实例化动作通常不是在编译而是在链接期间发生<ul>\n<li>It is not until the templates are instantiated that the implementation can verify that the template code can be used with the types that were specified.</li>\n<li>Hence, it is possible to get what seem like compile-time errors at link time.</li>\n</ul>\n</li>\n<li>编写自己模板时<ul>\n<li>为了对模板实例化，要求模板的定义（不仅是声明）必须是系统环境可以访问的<ul>\n<li>定义了模板的源文件和头文件都必须是可访问的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"泛型函数和类型\"><a href=\"#泛型函数和类型\" class=\"headerlink\" title=\"泛型函数和类型\"></a>泛型函数和类型</h3><p>在设计和使用模板时，最困难的部分：精确理解模版和能被用于此模板的“适当的类型”之间的交互作用。</p>\n<h2 id=\"数据结构独立性\"><a href=\"#数据结构独立性\" class=\"headerlink\" title=\"数据结构独立性\"></a>数据结构独立性</h2><p>如果库使用迭代器从而要求我们两次提到c，那么我们有可能只需要编写一个find函数就可以在任何容器的任何连续的一部分中查找到一个值。</p>\n<p>泛型函数为什么要用迭代器参数而不直接使用容器参数：</p>\n<ul>\n<li>如果我们使用迭代器，就可以访问到具有特殊意义的但又不存在于容器中的元素</li>\n</ul>\n<h3 id=\"算法与迭代器\"><a href=\"#算法与迭代器\" class=\"headerlink\" title=\"算法与迭代器\"></a>算法与迭代器</h3><p>库定义了5种迭代器</p>\n<ul>\n<li>迭代器$\\sim$操作集合$\\sim$容器可以使用哪些算法$\\sim$访问容器元素的策略</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>访问策略</th>\n<th>对应库函数</th>\n<th>迭代器应该支持的操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>顺序只读访问</td>\n<td><code>find</code></td>\n<td>输入迭代器</td>\n</tr>\n<tr>\n<td>顺序只写访问</td>\n<td><code>copy</code></td>\n<td>输出迭代器</td>\n</tr>\n<tr>\n<td>顺序读-写访问</td>\n<td><code>replace</code></td>\n<td>正向迭代器</td>\n</tr>\n<tr>\n<td>可逆访问</td>\n<td><code>reverse</code></td>\n<td>双向迭代器</td>\n</tr>\n<tr>\n<td>随机访问</td>\n<td><code>binary_search</code></td>\n<td>随机访问迭代器</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>迭代器类型</th>\n<th>支持操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>输入迭代器</td>\n<td><code>++</code>,<code>==</code>,<code>!=</code>,<code>*</code></td>\n</tr>\n<tr>\n<td>输出迭代器</td>\n<td>不能在对<code>*it</code>的两个赋值运算之间执行超过一次的<code>++it</code>操作<br />也不能在没有对<code>it</code>进行递增的情况下对<code>it</code>进行多次赋值</td>\n</tr>\n<tr>\n<td>正向迭代器</td>\n<td><code>*it</code>,<code>++it和it++</code>,<code>it == j</code>和<code>it != j</code>,<code>it -&gt; member</code></td>\n</tr>\n<tr>\n<td>双向迭代器</td>\n<td>正向迭代器和<code>--</code></td>\n</tr>\n<tr>\n<td>随机访问迭代器</td>\n<td>双向迭代器和算术运算</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"find-template-cpp\"><a href=\"#find-template-cpp\" class=\"headerlink\" title=\"find_template.cpp\"></a><code>find_template.cpp</code></h4><p>调用<code>find(begin,end,x)</code>的结果</p>\n<ul>\n<li>在区间[begin,end)中第一个满足<code>*iter = x</code>的<code>iter</code></li>\n<li>end,不存在<code>*iter = x</code>的<code>iter</code>时</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">In</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">X</span><span class=\"token operator\">></span> In <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>In begin<span class=\"token punctuation\">,</span>In end<span class=\"token punctuation\">,</span><span class=\"token keyword\">const</span> X<span class=\"token operator\">&amp;</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>begin <span class=\"token operator\">!=</span> end <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">*</span>begin <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">++</span>begin<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> begin<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">// ++ 用于实现顺序访问</span>\n<span class=\"token comment\">// * 用于访问iter指向的容器元素</span>\n<span class=\"token comment\">// != 用于比较iter是否相等</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用其他操作时候的递归风格<code>find_template2.cpp</code></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">In</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">X</span><span class=\"token operator\">></span> In <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>In begin<span class=\"token punctuation\">,</span>In end<span class=\"token punctuation\">,</span><span class=\"token keyword\">const</span> X<span class=\"token operator\">&amp;</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>begin <span class=\"token operator\">==</span> end <span class=\"token operator\">||</span> <span class=\"token operator\">*</span>begin <span class=\"token operator\">==</span> x<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> begin<span class=\"token punctuation\">;</span>\n \tbegin<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>begin<span class=\"token punctuation\">,</span>end<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"copy-template-cpp\"><a href=\"#copy-template-cpp\" class=\"headerlink\" title=\"copy_template.cpp\"></a><code>copy_template.cpp</code></h4><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">In</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">out</span><span class=\"token operator\">></span>\nOut <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>In begin<span class=\"token punctuation\">,</span>In end<span class=\"token punctuation\">,</span>Out dest<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>begin <span class=\"token operator\">!=</span> end<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">*</span>dest<span class=\"token operator\">++</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>begin<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> dest<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//前两个迭代器指示了一个序列，函数会从这个序列进行复制</span>\n<span class=\"token comment\">//第三个指示了目的序列的开头</span>\n<span class=\"token comment\">//begin和end是输入迭代器，只用它们读元素</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"replace-template-cpp\"><a href=\"#replace-template-cpp\" class=\"headerlink\" title=\"replace_template.cpp\"></a><code>replace_template.cpp</code></h4><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">For</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">X</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>For beg<span class=\"token punctuation\">,</span>For end<span class=\"token punctuation\">,</span><span class=\"token keyword\">const</span> X<span class=\"token operator\">&amp;</span> x<span class=\"token punctuation\">,</span><span class=\"token keyword\">const</span> Y<span class=\"token operator\">&amp;</span> y<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>beg <span class=\"token operator\">!=</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>beg <span class=\"token operator\">==</span> x<span class=\"token punctuation\">)</span>\n      <span class=\"token operator\">*</span>beg <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">++</span>beg<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//这个函数检查了在区间[beg,end)中的元素并用y来替换所有等于x的元素</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"reverse-template-cpp\"><a href=\"#reverse-template-cpp\" class=\"headerlink\" title=\"reverse_template.cpp\"></a><code>reverse_template.cpp</code></h4><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">Bi</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">void</span> reverse<span class=\"token operator\">&lt;</span>Bi begin<span class=\"token punctuation\">,</span>Bi end<span class=\"token operator\">></span>\n<span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>begin <span class=\"token operator\">!=</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token operator\">--</span>end<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>begin <span class=\"token operator\">!=</span> end<span class=\"token punctuation\">)</span>\n      <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>begin<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span><span class=\"token operator\">*</span>end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//从向量的尾部自后向前逆向推进end并从向量的开头正向推进begin</span>\n<span class=\"token comment\">//这个过程中，交换它们所指向的元素</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"binary-search-template-cpp\"><a href=\"#binary-search-template-cpp\" class=\"headerlink\" title=\"binary_search_template.cpp\"></a><code>binary_search_template.cpp</code></h4><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">Ran</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">X</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">bool</span> <span class=\"token function\">binary_search</span><span class=\"token punctuation\">(</span>Ran begin<span class=\"token punctuation\">,</span>Ran end<span class=\"token punctuation\">,</span><span class=\"token keyword\">const</span> X<span class=\"token operator\">&amp;</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>begin<span class=\"token operator\">&lt;</span>end<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        Ran mid <span class=\"token operator\">=</span> begin <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>end <span class=\"token operator\">-</span> begin<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;</span> <span class=\"token operator\">*</span>mid<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#123;</span>\n            end <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>mid <span class=\"token operator\">&lt;</span> x<span class=\"token punctuation\">)</span>\n            begin <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"迭代器区间和越界值\"><a href=\"#迭代器区间和越界值\" class=\"headerlink\" title=\"迭代器区间和越界值\"></a>迭代器区间和越界值</h3><p>为什么要指定紧位于区间最后的元素之后的一个位置？</p>\n<ul>\n<li>区间无元素，无法找到一个最后的元素以标记终点</li>\n<li>如果用迭代器标记区间终点，就可以仅是为了判定相等或不相等而去比较迭代器，而且使用了这种标记方法之后，就无须再定义“一个迭代器小于另一个迭代器”的具体意义</li>\n<li>这种方式下可以以一种自然的方式表示“区间之外”</li>\n</ul>\n<h2 id=\"输入和输出迭代器\"><a href=\"#输入和输出迭代器\" class=\"headerlink\" title=\"输入和输出迭代器\"></a>输入和输出迭代器</h2><h2 id=\"使用迭代器提高适应性\"><a href=\"#使用迭代器提高适应性\" class=\"headerlink\" title=\"使用迭代器提高适应性\"></a>使用迭代器提高适应性</h2><p><code>split_template.cpp</code></p>\n<p>​    </p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">Out</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> string<span class=\"token operator\">&amp;</span> str<span class=\"token punctuation\">,</span>Out os<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">typedef</span> string<span class=\"token double-colon punctuation\">::</span>const_iterator iter<span class=\"token punctuation\">;</span>\n\n    iter i <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        i <span class=\"token operator\">=</span> <span class=\"token function\">find_if</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>not_space<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        iter j <span class=\"token operator\">=</span> <span class=\"token function\">find_if</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>space<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token operator\">*</span>os<span class=\"token operator\">++</span> <span class=\"token operator\">=</span> <span class=\"token function\">string</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        i <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>调用形式</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token function\">split</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span><span class=\"token function\">back_inserter</span><span class=\"token punctuation\">(</span>word_list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>测试程序</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n  string s<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">getline</span><span class=\"token punctuation\">(</span>cin<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">split</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span><span class=\"token generic-function\"><span class=\"token function\">ostream_iterator</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>cout<span class=\"token punctuation\">,</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","text":"编写泛型函数本书第一部分：编写程序以便解决某些具体问题 使用c++语言基本要素以及标准库提供的抽象 从这一章开始：学习编写抽象的方法 C8 讨论泛型函数 C9-C12 演示如何实现抽象数据类型 从C13开始：学习面向对象程序设计方法OOP 什么是泛型函数表面上看，我们在编写函数时...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">编写泛型函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">什么是泛型函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%AA%E7%9F%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%AD%E5%80%BC\"><span class=\"toc-text\">未知类型的中值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E4%BE%8B%E5%8C%96\"><span class=\"toc-text\">模板实例化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E5%92%8C%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">泛型函数和类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%8B%AC%E7%AB%8B%E6%80%A7\"><span class=\"toc-text\">数据结构独立性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">算法与迭代器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#find-template-cpp\"><span class=\"toc-text\">find_template.cpp</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#copy-template-cpp\"><span class=\"toc-text\">copy_template.cpp</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#replace-template-cpp\"><span class=\"toc-text\">replace_template.cpp</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#reverse-template-cpp\"><span class=\"toc-text\">reverse_template.cpp</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#binary-search-template-cpp\"><span class=\"toc-text\">binary_search_template.cpp</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8C%BA%E9%97%B4%E5%92%8C%E8%B6%8A%E7%95%8C%E5%80%BC\"><span class=\"toc-text\">迭代器区间和越界值</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">输入和输出迭代器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8F%90%E9%AB%98%E9%80%82%E5%BA%94%E6%80%A7\"><span class=\"toc-text\">使用迭代器提高适应性</span></a></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"CPP7 使用关联容器","uid":"c6bbdc5859805502fec5f66437416592","slug":"CPP/C7 使用关联容器","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:49:01.000Z","comments":true,"path":"api/articles/CPP/C7 使用关联容器.json","keywords":null,"cover":[],"text":"使用关联容器 顺序容器：给容器元素选择适当顺序后，它们会按照我们所选择的顺序将元素保存起来 关联容器：容器会自动将它们的元素安排在一个序列中 支持高效查找的容器关联容器：自动将它们元素安排在一个序列中，利用这种排序方法让我们可以更快速地对特定元素进行定位—并不需要我们自己保持容器...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"CPP9 定义新类型","uid":"260ea000f421b3eddad461c7e5d42b80","slug":"CPP/C9 定义新类型","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:48:54.000Z","comments":true,"path":"api/articles/CPP/C9 定义新类型.json","keywords":null,"cover":[],"text":"定义新类型可以将C++分成两种 内部类型 -&gt; 被定义成语言核心的一部分 自定义类型(class type) C+设计思想 应该让程序员创建与内部类型一样易于使用的类型 创建具有简明直观的接口的类型 实质性的语言支持 类的设计过程中的体验和判断 Student_info回顾...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}