{"title":"DSA36 AC自动机","uid":"06d10bcf0dacb0e855883f8036c8872c","slug":"DSA/C36 AC自动机","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:16.033Z","comments":true,"path":"api/articles/DSA/C36 AC自动机.json","keywords":null,"cover":[],"content":"<h1 id=\"AC自动机：如何用多模式串匹配实现敏感词过滤功能？\"><a href=\"#AC自动机：如何用多模式串匹配实现敏感词过滤功能？\" class=\"headerlink\" title=\"AC自动机：如何用多模式串匹配实现敏感词过滤功能？\"></a>AC自动机：如何用多模式串匹配实现敏感词过滤功能？</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>敏感词过滤功能是如何实现的？</p>\n<ul>\n<li>字符串匹配算法<ul>\n<li>通过维护一个敏感词的字典，当用户输入一段文字内容之后，通过字符串匹配算法查找用户输入的文字，包含敏感词则用“***”替换掉</li>\n</ul>\n</li>\n</ul>\n<p>访问量巨大的网站来说，如何实现一个高性能的敏感词过滤系统？</p>\n<ul>\n<li>多模式串匹配算法<ul>\n<li>问题处理很高效</li>\n</ul>\n</li>\n</ul>\n<p>如何用Trie树实现敏感词过滤功能？</p>\n<ul>\n<li>对敏感词字典进行预处理，构建成Trie树结构</li>\n<li>敏感词字典动态更新，如删除、添加敏感词，只需要动态更新一下Trie树即可</li>\n</ul>\n<p>借鉴单模式串的优化改进方法，能否对多模式串Trie树进行改进，进一步提高Trie树的效率？</p>\n<ul>\n<li>AC自动机算法</li>\n</ul>\n<h2 id=\"经典的多模式串匹配算法：AC自动机\"><a href=\"#经典的多模式串匹配算法：AC自动机\" class=\"headerlink\" title=\"经典的多模式串匹配算法：AC自动机\"></a>经典的多模式串匹配算法：AC自动机</h2><p>Aho-Corasicksuanfa </p>\n<p>AC自动机实际上就是在Trie树之上，加了类似KMP的next数组，只不过此处的next数组构建在树上</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AcNode</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">char</span> data<span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">AcNode</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> children <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AcNode</span><span class=\"token punctuation\">[</span><span class=\"token number\">26</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 字符集只包含a~z这26个字符</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> isEndingChar <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 结尾字符为true</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 当isEndingChar=true时，记录模式串长度</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">AcNode</span> fail<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 失败指针</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">AcNode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>所以AC自动机的构建包含两个操作</p>\n<ul>\n<li>将多个模式串构建成Trie树 （上一节已经解决）</li>\n<li>在Trie树上构建失败指针（本章解决）</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/f8/f1/f80487051d8f44cabf488195de8db1f1.jpg\" alt=\"img\"></p>\n<p>构件失败指针</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void buildFailurePointer() &#123;\n  Queue&lt;AcNode&gt; queue &#x3D; new LinkedList&lt;&gt;();\n  root.fail &#x3D; null;\n  queue.add(root);\n  while (!queue.isEmpty()) &#123;\n    AcNode p &#x3D; queue.remove();\n    for (int i &#x3D; 0; i &lt; 26; ++i) &#123;\n      AcNode pc &#x3D; p.children[i];\n      if (pc &#x3D;&#x3D; null) continue;\n      if (p &#x3D;&#x3D; root) &#123;\n        pc.fail &#x3D; root;\n      &#125; else &#123;\n        AcNode q &#x3D; p.fail;\n        while (q !&#x3D; null) &#123;\n          AcNode qc &#x3D; q.children[pc.data - &#39;a&#39;];\n          if (qc !&#x3D; null) &#123;\n            pc.fail &#x3D; qc;\n            break;\n          &#125;\n          q &#x3D; q.fail;\n        &#125;\n        if (q &#x3D;&#x3D; null) &#123;\n          pc.fail &#x3D; root;\n        &#125;\n      &#125;\n      queue.add(pc);\n    &#125;\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>构建完成的AC自动机</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/51/3c/5150d176502dda4adfc63e9b2915b23c.jpg\" alt=\"img\"></p>\n<p>如何在AC自动机上匹配主串？</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public void match(char[] text) &#123; &#x2F;&#x2F; text是主串\n  int n &#x3D; text.length;\n  AcNode p &#x3D; root;\n  for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n    int idx &#x3D; text[i] - &#39;a&#39;;\n    while (p.children[idx] &#x3D;&#x3D; null &amp;&amp; p !&#x3D; root) &#123;\n      p &#x3D; p.fail; &#x2F;&#x2F; 失败指针发挥作用的地方\n    &#125;\n    p &#x3D; p.children[idx];\n    if (p &#x3D;&#x3D; null) p &#x3D; root; &#x2F;&#x2F; 如果没有匹配的，从root开始重新匹配\n    AcNode tmp &#x3D; p;\n    while (tmp !&#x3D; root) &#123; &#x2F;&#x2F; 打印出可以匹配的模式串\n      if (tmp.isEndingChar &#x3D;&#x3D; true) &#123;\n        int pos &#x3D; i-tmp.length+1;\n        System.out.println(&quot;匹配起始下标&quot; + pos + &quot;; 长度&quot; + tmp.length);\n      &#125;\n      tmp &#x3D; tmp.fail;\n    &#125;\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","text":"AC自动机：如何用多模式串匹配实现敏感词过滤功能？引入敏感词过滤功能是如何实现的？ 字符串匹配算法 通过维护一个敏感词的字典，当用户输入一段文字内容之后，通过字符串匹配算法查找用户输入的文字，包含敏感词则用“***”替换掉 访问量巨大的网站来说，如何实现一个高性能的敏感词过滤系统...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E5%A4%9A%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD%EF%BC%9F\"><span class=\"toc-text\">AC自动机：如何用多模式串匹配实现敏感词过滤功能？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">引入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%8F%E5%85%B8%E7%9A%84%E5%A4%9A%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%9AAC%E8%87%AA%E5%8A%A8%E6%9C%BA\"><span class=\"toc-text\">经典的多模式串匹配算法：AC自动机</span></a></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DSA37 Greedy Algorithm","uid":"a9e32e2621fbdc03b2a42efbcf0ce8e5","slug":"DSA/C37 贪心算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:30.880Z","comments":true,"path":"api/articles/DSA/C37 贪心算法.json","keywords":null,"cover":[],"text":"贪心算法：如何用贪心算法实现Huffman压缩编码？几个基本的算法思想 贪心算法 Huffman Coding Prim和Kruskal最小生成树算法 Dijkstra单源最短路径 分治算法 回溯算法 动态规划 本章如何利用贪心算法实现对数据压缩编码，有效节省数据存储空间 如何理...","link":"","photos":[],"count_time":{"symbolsCount":678,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DSA40 回溯算法","uid":"cab4c9495dd444030efce39574aea74e","slug":"DSA/C39 回溯算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:28:02.190Z","comments":true,"path":"api/articles/DSA/C39 回溯算法.json","keywords":null,"cover":[],"text":"回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想引入回溯算法的应用 深度优先搜索 经典数学问题 数独 八皇后 0-1背包 图的着色 旅行商问题 全排列 如何理解回溯算法笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}