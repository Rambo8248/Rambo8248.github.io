{"title":"DSA29 Heap Application","uid":"3d8241738a6ca807ab996c00fc84c560","slug":"DSA/C29 堆的应用","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:47.000Z","comments":true,"path":"api/articles/DSA/C29 堆的应用.json","keywords":null,"cover":[],"content":"<h1 id=\"堆的应用：如何快速获取到Top-10最热门的搜索关键词？\"><a href=\"#堆的应用：如何快速获取到Top-10最热门的搜索关键词？\" class=\"headerlink\" title=\"堆的应用：如何快速获取到Top 10最热门的搜索关键词？\"></a>堆的应用：如何快速获取到Top 10最热门的搜索关键词？</h1><p>堆的几个经典应用</p>\n<ul>\n<li>优先级队列</li>\n<li>求Top K</li>\n<li>求中位数</li>\n</ul>\n<h2 id=\"堆的应用一：优先级队列\"><a href=\"#堆的应用一：优先级队列\" class=\"headerlink\" title=\"堆的应用一：优先级队列\"></a>堆的应用一：优先级队列</h2><ul>\n<li>优先级队列<ul>\n<li>队列</li>\n<li>出队顺序按照优先级来</li>\n</ul>\n</li>\n<li>优先级队列与堆很像<ul>\n<li>插入元素→堆中插入元素</li>\n<li>取出优先级最高的元素→取出堆顶元素</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"合并有序小文件\"><a href=\"#合并有序小文件\" class=\"headerlink\" title=\"合并有序小文件\"></a>合并有序小文件</h3><ul>\n<li>问题描述<ul>\n<li>100个小文件</li>\n<li>每个文件大小为100MB</li>\n<li>每个文件中存储的都是有序字符串</li>\n<li>希望将100个小文件合并为有序大文件</li>\n</ul>\n</li>\n<li>整体思路1：数组<ul>\n<li><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gtub2doehfj60bo0abt9102.jpg\" alt=\"image-20210802113005265\"></li>\n</ul>\n</li>\n</ul>\n<pre class=\"mermaid\">graph TD\n从100个文件中各取第一个字符串 --> 放入数组中比较大小--> 最小的字符串放入合并后的大文件中--> 删除对应数组</pre>\n\n<ul>\n<li>整体思路2：优先级队列<ul>\n<li><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gtub2ff1v8j60b30agmxk02.jpg\" alt=\"image-20210802113011494\"></li>\n</ul>\n</li>\n</ul>\n<pre class=\"mermaid\">graph TD\n小文件中取出的字符串放入小顶堆中 --> 将字符串放入到大文件中.并将其从堆中删除\n--> 再从小文件中取出下一个字符串.放入堆中 --> 循环操作</pre>\n\n<h3 id=\"高性能定时器\"><a href=\"#高性能定时器\" class=\"headerlink\" title=\"高性能定时器\"></a>高性能定时器</h3><p><img src=\"https://static001.geekbang.org/resource/image/b0/e7/b04656d27fd0ba112a38a28c892069e7.jpg?wh=1142*484\" alt=\"img\"></p>\n<p>解决方案</p>\n<ul>\n<li>每过1秒就扫描一遍任务列表→低效<ul>\n<li>任务约定执行时间离当前时间可能还有很久</li>\n<li>每次都要扫描整个任务列表，列表大则会很耗时</li>\n</ul>\n</li>\n<li>优先级队列<ul>\n<li><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gtub2i5qu6j60g50bz0t902.jpg\" alt=\"image-20210802113019984\"></li>\n</ul>\n</li>\n</ul>\n<pre class=\"mermaid\">graph TD\n任务 --按照任务设定的执行时间 -->存储在优先级队列中 -->拿队首任务的执行时间点与当前时间点相减得到间隔T \n--> 经过T后执行任务 --新一轮-->任务</pre>\n\n<h2 id=\"堆的应用二：求Top-K\"><a href=\"#堆的应用二：求Top-K\" class=\"headerlink\" title=\"堆的应用二：求Top K\"></a>堆的应用二：求Top K</h2><p>抽象为两类</p>\n<ul>\n<li>静态数据集合<ul>\n<li>数据集合事先确定，不会再变</li>\n</ul>\n</li>\n<li>动态数据集合<ul>\n<li>数据集合事先并不确定，有数据动态加入到集合中</li>\n</ul>\n</li>\n</ul>\n<p>静态：</p>\n<p><img src=\"/Users/zhangweijian/Desktop/公众号/数据结构与算法/C29 堆的应用.assets/image-20210802113028230.png\" alt=\"image-20210802113028230\"></p>\n<pre class=\"mermaid\">graph TD\n维护一个大小为K的小顶堆 --> 顺序遍历数组 --> 从数组中取出数据与堆顶元素比较\n--> 比堆顶元素大 -->  堆顶元素删除且将该元素插入堆中\n\n从数组中取出数据与堆顶元素比较 --> 比堆顶元素小  --> 不作处理 --> 继续遍历数组</pre>\n\n<p>动态：<img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gtub2l4abij60e70b7wf202.jpg\" alt=\"image-20210802113034468\"></p>\n<pre class=\"mermaid\">graph TD\n维护一个K大小的小顶堆 --数据被添加到集合中时-->拿它与堆顶元素对比 --> 比堆顶元素大 \n\n--> 堆顶元素删除且将该元素插入堆中\n\n拿它与堆顶元素对比 --> 比堆顶元素小 --> 不作处理</pre>\n\n<h2 id=\"堆的应用三：求中位数\"><a href=\"#堆的应用三：求中位数\" class=\"headerlink\" title=\"堆的应用三：求中位数\"></a>堆的应用三：求中位数</h2><p>如何求动态数据集合中的中位数</p>\n<p>借助堆这种数据结构，我们不用排序，就可以非常高效地实现求中位数操作</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/08/99/08c29d3e014a4baf5f8148c2271e6099.jpg?wh=1142*552\" alt=\"img\"></p>\n<p><img src=\"https://static001.geekbang.org/resource/image/ae/b1/aee4dcaf9d34111870a1d66a6e109fb1.jpg?wh=1142*745\" alt=\"img\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gtub2nyvhpj60g20ingmq02.jpg\" alt=\"image-20210802113045937\"></p>\n<pre class=\"mermaid\">graph TD \n维护两个堆 --> 大顶堆存储前半部分数据 -->加入元素 --小于等于大顶堆堆顶元素?-->yes -->新数据插入到大顶堆 --> 元素不满足约定 -->堆中不停将堆顶元素移到另一个堆\n维护两个堆 --> 小顶堆存储后半部分数据-->加入元素--小于等于大顶堆堆顶元素?-->no -->新数据插入到小顶堆--> 元素不满足约定-->堆中不停将堆顶元素移到另一个堆</pre>\n\n<h2 id=\"解答开篇\"><a href=\"#解答开篇\" class=\"headerlink\" title=\"解答开篇\"></a>解答开篇</h2><p>假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？</p>\n<p>处理场景限定为单机、可使用内存为1GB</p>\n<h3 id=\"散列表解决方案\"><a href=\"#散列表解决方案\" class=\"headerlink\" title=\"散列表解决方案\"></a>散列表解决方案<img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gtub2qsroyj60de0ilmy302.jpg\" alt=\"image-20210802113121262\"></h3><pre class=\"mermaid\">graph TD\n顺序扫描10亿个搜索关键词 --> 散列表查询 -->存在 -->次数加1 --> 用堆求TOPK \n 散列表查询 -->不存在 --> 插入到散列表并记录次数为1  --> 用堆求TOPK\n\n 用堆求TOPK --> 建立一个大小为10的小顶堆 --> 遍历散列表依次取出每个搜索关键词即对应出现的次数 -->与堆顶搜索关键词对比 --出现次数比堆顶搜索关键词的次数多--> 删除堆顶关键词并将这个出现次数更多地关键词加入到堆中</pre>\n\n<p>漏洞</p>\n<p>10 亿的关键词还是很多的。我们假设 10 亿条搜索关键词中不重复的有 1 亿条，如果每个搜索关键词的平均长度是 50 个字节，那存储 1 亿个关键词起码需要 5GB 的内存空间，而散列表因为要避免频繁冲突，不会选择太大的装载因子，所以消耗的内存空间就更多了。而我们的机器只有 1GB 的可用内存空间，所以我们无法一次性将所有的搜索关键词加入到内存中。</p>\n<h3 id=\"哈希算法引入\"><a href=\"#哈希算法引入\" class=\"headerlink\" title=\"哈希算法引入\"></a>哈希算法引入</h3><pre class=\"mermaid\">graph TD\n创建10个空文件 -->遍历10亿个关键词 --哈希算法-->哈希值 --与10取模-->搜索关键词应该被分到的文件编号 --> 散列表+堆分别求出TOP10 --> 合并并再求TOP10</pre>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gtub2wcv32j607j0d0t8z02.jpg\" alt=\"image-20210802113133621\"></p>\n","text":"堆的应用：如何快速获取到Top 10最热门的搜索关键词？堆的几个经典应用 优先级队列 求Top K 求中位数 堆的应用一：优先级队列 优先级队列 队列 出队顺序按照优先级来 优先级队列与堆很像 插入元素→堆中插入元素 取出优先级最高的元素→取出堆顶元素 合并有序小文件 问题描述 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96%E5%88%B0Top-10%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%EF%BC%9F\"><span class=\"toc-text\">堆的应用：如何快速获取到Top 10最热门的搜索关键词？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%80%EF%BC%9A%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97\"><span class=\"toc-text\">堆的应用一：优先级队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E5%B0%8F%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">合并有序小文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AB%98%E6%80%A7%E8%83%BD%E5%AE%9A%E6%97%B6%E5%99%A8\"><span class=\"toc-text\">高性能定时器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8%E4%BA%8C%EF%BC%9A%E6%B1%82Top-K\"><span class=\"toc-text\">堆的应用二：求Top K</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%89%EF%BC%9A%E6%B1%82%E4%B8%AD%E4%BD%8D%E6%95%B0\"><span class=\"toc-text\">堆的应用三：求中位数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E7%AD%94%E5%BC%80%E7%AF%87\"><span class=\"toc-text\">解答开篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">散列表解决方案</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">哈希算法引入</span></a></li></ol></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DSA27 Recursion Tree","uid":"134dfc72e46d7c11aedb7ca140c26710","slug":"DSA/C27 递归树","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:19.000Z","comments":true,"path":"api/articles/DSA/C27 递归树.json","keywords":null,"cover":[],"text":"递归树：如何借助树来求解递归算法的时间复杂度？递归树与时间复杂度分析 实战1：分析快速排序的时间复杂度假设平均情况下，每次分区后，两个分区的大小比例为1:k，当k=9时，递推公式为： T(n) = T(\\frac{n}{10})+T(\\frac{9n}{10})+n用递归树来分析...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DSA28 Heap","uid":"1ecdd1e00fb73a51c0511d1921f5b63c","slug":"DSA/C28 堆和堆排序","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:33.000Z","comments":true,"path":"api/articles/DSA/C28 堆和堆排序.json","keywords":null,"cover":[],"text":"堆和堆排序：为什么说堆排序没有快速排序快？特殊的树：堆(Heap) 堆排序 原地 时间复杂度为$O(nlogn)$ 实际软件开发中，快速排序的性能要比堆排序好 如何理解堆？ 完全二叉树 堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值 大顶堆 小顶堆 如何实现一...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}