{"title":"DSA35 Trie Tree","uid":"6ac917baf75da522e92f8103dc9fe5ea","slug":"DSA/C35 Trie树","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:00.561Z","comments":true,"path":"api/articles/DSA/C35 Trie树.json","keywords":null,"cover":[],"content":"<h1 id=\"Trie树：如何实现搜索引擎的搜索关键词提示功能？\"><a href=\"#Trie树：如何实现搜索引擎的搜索关键词提示功能？\" class=\"headerlink\" title=\"Trie树：如何实现搜索引擎的搜索关键词提示功能？\"></a>Trie树：如何实现搜索引擎的搜索关键词提示功能？</h1><p>搜索引擎的搜索关键词提示功能</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/ce/9e/ceb8738453401d5fc067acd513b57a9e.png\" alt=\"img\"></p>\n<h2 id=\"什么是Trie树？\"><a href=\"#什么是Trie树？\" class=\"headerlink\" title=\"什么是Trie树？\"></a>什么是Trie树？</h2><ul>\n<li>字典树，树形结构</li>\n<li>专门处理字符串匹配的数据结构</li>\n<li>解决在一组字符串集合中快速查找某个字符串的问题</li>\n</ul>\n<p>先看看Trie树长什么样</p>\n<p>本质：<strong>利用字符串之间公共前缀，将重复前缀合并在一起</strong></p>\n<ul>\n<li>6个字符串分别为：how hi her hello so see</li>\n<li>希望在里面多次查找某个字符串是否存在</li>\n<li>每次查找都要匹配导致低效</li>\n<li>故对6个字符串预处理，组织成Trie树结构，之后每次查找都是在Trie树中进行匹配查找</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/28/32/280fbc0bfdef8380fcb632af39e84b32.jpg\" alt=\"利用字符串之间公共前缀，将重复前缀合并在一起\"></p>\n<p><img src=\"https://static001.geekbang.org/resource/image/6d/b9/6dbed0579a60c6d170bd8fde5990bfb9.jpg\" alt=\"匹配her\"></p>\n<p><img src=\"https://static001.geekbang.org/resource/image/05/f9/05c3c5d534921f00a9ae33e7e65b1bf9.jpg\" alt=\"匹配he\"></p>\n<h2 id=\"如何实现一棵Trie树？\"><a href=\"#如何实现一棵Trie树？\" class=\"headerlink\" title=\"如何实现一棵Trie树？\"></a>如何实现一棵Trie树？</h2><p>两个操作</p>\n<ul>\n<li>将字符串集合构造成Trie树</li>\n<li>在Trie树中查询一个字符串</li>\n</ul>\n<p>如何存储</p>\n<ul>\n<li>多叉树<ul>\n<li>借助散列表思想，通过一个下标与字符一一映射的数组来存储子节点的指针</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/f5/35/f5a4a9cb7f0fe9dcfbf29eb1e5da6d35.jpg\" alt=\"img\"></p>\n<p>假设字符串只有a到z这26个小写字母，数组中下标为0的位置存储指向子节点a的指针</p>\n<p>如果某个字符子节点不存在，就在对应的下标位置存储null</p>\n<p>字符的ASCII码减去“a”的ASCII码，迅速找到匹配的子节点的指针</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public class Trie &#123;\n  private TrieNode root &#x3D; new TrieNode(&#39;&#x2F;&#39;); &#x2F;&#x2F; 存储无意义字符\n\n  &#x2F;&#x2F; 往Trie树中插入一个字符串\n  public void insert(char[] text) &#123;\n    TrieNode p &#x3D; root;\n    for (int i &#x3D; 0; i &lt; text.length; ++i) &#123;\n      int index &#x3D; text[i] - &#39;a&#39;;\n      if (p.children[index] &#x3D;&#x3D; null) &#123;\n        TrieNode newNode &#x3D; new TrieNode(text[i]);\n        p.children[index] &#x3D; newNode;\n      &#125;\n      p &#x3D; p.children[index];\n    &#125;\n    p.isEndingChar &#x3D; true;\n  &#125;\n\n  &#x2F;&#x2F; 在Trie树中查找一个字符串\n  public boolean find(char[] pattern) &#123;\n    TrieNode p &#x3D; root;\n    for (int i &#x3D; 0; i &lt; pattern.length; ++i) &#123;\n      int index &#x3D; pattern[i] - &#39;a&#39;;\n      if (p.children[index] &#x3D;&#x3D; null) &#123;\n        return false; &#x2F;&#x2F; 不存在pattern\n      &#125;\n      p &#x3D; p.children[index];\n    &#125;\n    if (p.isEndingChar &#x3D;&#x3D; false) return false; &#x2F;&#x2F; 不能完全匹配，只是前缀\n    else return true; &#x2F;&#x2F; 找到pattern\n  &#125;\n\n  public class TrieNode &#123;\n    public char data;\n    public TrieNode[] children &#x3D; new TrieNode[26];\n    public boolean isEndingChar &#x3D; false;\n    public TrieNode(char data) &#123;\n      this.data &#x3D; data;\n    &#125;\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Trie树真的很耗内存吗？\"><a href=\"#Trie树真的很耗内存吗？\" class=\"headerlink\" title=\"Trie树真的很耗内存吗？\"></a>Trie树真的很耗内存吗？</h2><p>我们可以稍微牺牲一点查询的效率，将每个节点中的数组换成其他数据结构，来存储一个节点的子节点指针</p>\n<h2 id=\"Trie树与散列表、红黑树的比较\"><a href=\"#Trie树与散列表、红黑树的比较\" class=\"headerlink\" title=\"Trie树与散列表、红黑树的比较\"></a>Trie树与散列表、红黑树的比较</h2><p>Trie树在刚刚的场景中，对要处理的字符串有极其严苛的要求</p>\n<ul>\n<li>字符串中包含的字符集不能太大→存储空间浪费很多</li>\n<li>要求字符串前缀重合比较多→否则空间消耗大很多</li>\n<li>需要从零开始实现→简单问题复杂化</li>\n<li>通过指针穿起来的数据块不连续→缓存不友好，性能打折扣</li>\n</ul>\n<h2 id=\"解答开篇\"><a href=\"#解答开篇\" class=\"headerlink\" title=\"解答开篇\"></a>解答开篇</h2><p><img src=\"https://static001.geekbang.org/resource/image/4c/0d/4ca9d9f78f2206cad93836a2b1d6d80d.jpg\" alt=\"img\"></p>\n","text":"Trie树：如何实现搜索引擎的搜索关键词提示功能？搜索引擎的搜索关键词提示功能 什么是Trie树？ 字典树，树形结构 专门处理字符串匹配的数据结构 解决在一组字符串集合中快速查找某个字符串的问题 先看看Trie树长什么样 本质：利用字符串之间公共前缀，将重复前缀合并在一起 6个字...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Trie%E6%A0%91%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD%EF%BC%9F\"><span class=\"toc-text\">Trie树：如何实现搜索引擎的搜索关键词提示功能？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFTrie%E6%A0%91%EF%BC%9F\"><span class=\"toc-text\">什么是Trie树？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%A3%B5Trie%E6%A0%91%EF%BC%9F\"><span class=\"toc-text\">如何实现一棵Trie树？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Trie%E6%A0%91%E7%9C%9F%E7%9A%84%E5%BE%88%E8%80%97%E5%86%85%E5%AD%98%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">Trie树真的很耗内存吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Trie%E6%A0%91%E4%B8%8E%E6%95%A3%E5%88%97%E8%A1%A8%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">Trie树与散列表、红黑树的比较</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E7%AD%94%E5%BC%80%E7%AF%87\"><span class=\"toc-text\">解答开篇</span></a></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DSA33 String Match2","uid":"0ec81c6d3aa8372bc4bd0a74846f2430","slug":"DSA/C33 字符串匹配基础(中)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:26:35.770Z","comments":true,"path":"api/articles/DSA/C33 字符串匹配基础(中).json","keywords":null,"cover":[],"text":"字符串匹配基础（中）：如何实现文本编辑器中的查找功能？文本编辑器中的查找替换功能 BM算法，Boyer-Moore KMP算法 BM算法核心思想 当模式串和主串某个字符不匹配的时候，能够跳过一些可定不会匹配的情况，将模式串往后多滑动几位 算法原理分析坏字符规则 graph TD ...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DSA34 String Match3","uid":"9ae95ab2c9e432ffcdddad19b3709cb8","slug":"DSA/C34 字符串匹配基础(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:26:45.892Z","comments":true,"path":"api/articles/DSA/C34 字符串匹配基础(下).json","keywords":null,"cover":[],"text":"字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法？所有字符串匹配算法中，最知名的一种非KMP算法莫属 KMP算法基本原理Knuth-Morris-Pratt 核心思想 模式串与主串匹配过程中，当遇到不可匹配的字符时，希望找到一些规律，将模式串向后多滑动几位，跳过那些肯定不...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}