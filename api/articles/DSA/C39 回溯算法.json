{"title":"DSA40 回溯算法","uid":"cab4c9495dd444030efce39574aea74e","slug":"DSA/C39 回溯算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:28:02.190Z","comments":true,"path":"api/articles/DSA/C39 回溯算法.json","keywords":null,"cover":[],"content":"<h1 id=\"回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想\"><a href=\"#回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想\" class=\"headerlink\" title=\"回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想\"></a>回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>回溯算法的应用</p>\n<ul>\n<li>深度优先搜索</li>\n<li>经典数学问题<ul>\n<li>数独</li>\n<li>八皇后</li>\n<li>0-1背包</li>\n<li>图的着色</li>\n<li>旅行商问题</li>\n<li>全排列</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何理解回溯算法\"><a href=\"#如何理解回溯算法\" class=\"headerlink\" title=\"如何理解回溯算法\"></a>如何理解回溯算法</h2><p>笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索算法，而是<strong>在一组可能的解中，搜索满足期望的解。</strong></p>\n<p>八皇后问题</p>\n<ul>\n<li> 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子</li>\n<li>期望找到所有满足这种要求的放棋子方式</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/a0/f5/a0e3994319732ca77c81e0f92cc77ff5.jpg\" alt=\"img\"></p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">int[] result &#x3D; new int[8];&#x2F;&#x2F;全局或成员变量,下标表示行,值表示queen存储在哪一列\npublic void cal8queens(int row) &#123; &#x2F;&#x2F; 调用方式：cal8queens(0);\n  if (row &#x3D;&#x3D; 8) &#123; &#x2F;&#x2F; 8个棋子都放置好了，打印结果\n    printQueens(result);\n    return; &#x2F;&#x2F; 8行棋子都放好了，已经没法再往下递归了，所以就return\n  &#125;\n  for (int column &#x3D; 0; column &lt; 8; ++column) &#123; &#x2F;&#x2F; 每一行都有8中放法\n    if (isOk(row, column)) &#123; &#x2F;&#x2F; 有些放法不满足要求\n      result[row] &#x3D; column; &#x2F;&#x2F; 第row行的棋子放到了column列\n      cal8queens(row+1); &#x2F;&#x2F; 考察下一行\n    &#125;\n  &#125;\n&#125;\n\nprivate boolean isOk(int row, int column) &#123;&#x2F;&#x2F;判断row行column列放置是否合适\n  int leftup &#x3D; column - 1, rightup &#x3D; column + 1;\n  for (int i &#x3D; row-1; i &gt;&#x3D; 0; --i) &#123; &#x2F;&#x2F; 逐行往上考察每一行\n    if (result[i] &#x3D;&#x3D; column) return false; &#x2F;&#x2F; 第i行的column列有棋子吗？\n    if (leftup &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 考察左上对角线：第i行leftup列有棋子吗？\n      if (result[i] &#x3D;&#x3D; leftup) return false;\n    &#125;\n    if (rightup &lt; 8) &#123; &#x2F;&#x2F; 考察右上对角线：第i行rightup列有棋子吗？\n      if (result[i] &#x3D;&#x3D; rightup) return false;\n    &#125;\n    --leftup; ++rightup;\n  &#125;\n  return true;\n&#125;\n\nprivate void printQueens(int[] result) &#123; &#x2F;&#x2F; 打印出一个二维矩阵\n  for (int row &#x3D; 0; row &lt; 8; ++row) &#123;\n    for (int column &#x3D; 0; column &lt; 8; ++column) &#123;\n      if (result[row] &#x3D;&#x3D; column) System.out.print(&quot;Q &quot;);\n      else System.out.print(&quot;* &quot;);\n    &#125;\n    System.out.println();\n  &#125;\n  System.out.println();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"两个回溯算法的经典应用\"><a href=\"#两个回溯算法的经典应用\" class=\"headerlink\" title=\"两个回溯算法的经典应用\"></a>两个回溯算法的经典应用</h2><h3 id=\"0-1背包\"><a href=\"#0-1背包\" class=\"headerlink\" title=\"0-1背包\"></a>0-1背包</h3><p>我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且<strong>不可分割</strong>。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public int maxW &#x3D; Integer.MIN_VALUE; &#x2F;&#x2F;存储背包中物品总重量的最大值\n&#x2F;&#x2F; cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；\n&#x2F;&#x2F; w背包重量；items表示每个物品的重量；n表示物品个数\n&#x2F;&#x2F; 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：\n&#x2F;&#x2F; f(0, 0, a, 10, 100)\npublic void f(int i, int cw, int[] items, int n, int w) &#123;\n  if (cw &#x3D;&#x3D; w || i &#x3D;&#x3D; n) &#123; &#x2F;&#x2F; cw&#x3D;&#x3D;w表示装满了;i&#x3D;&#x3D;n表示已经考察完所有的物品\n    if (cw &gt; maxW) maxW &#x3D; cw;\n    return;\n  &#125;\n  f(i+1, cw, items, n, w);\n  if (cw + items[i] &lt;&#x3D; w) &#123;&#x2F;&#x2F; 已经超过可以背包承受的重量的时候，就不要再装了\n    f(i+1,cw + items[i], items, n, w);\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><p><a href=\"https://baike.baidu.com/item/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1700215\">https://baike.baidu.com/item/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1700215</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1da4y1p7iZ?from=search&amp;seid=1413946293500492218\">https://www.bilibili.com/video/BV1da4y1p7iZ?from=search&amp;seid=1413946293500492218</a></p>\n<p>前提</p>\n<ul>\n<li>*匹配任意多个任意字符</li>\n<li>？匹配零个或者一个任意字符</li>\n</ul>\n<p>过程</p>\n<p>![image-20210805165523503](/Users/zhangweijian/Desktop/公众号/数据结构与算法/C39 回溯算法.assets/image-20210805165523503.png)</p>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">graph TD\n依次考察正则表达式中的每个字符 --&gt; 是非通配符时直接跟文本的字符进行匹配 \n--相同--&gt;继续向下处理\n是非通配符时直接跟文本的字符进行匹配 \n--不同--&gt;回溯\n\n 依次考察正则表达式中的每个字符 --&gt;  遇到特殊字符时 --&gt;*有多种匹配方案.匹配任意个文本串中字符\n --&gt; 随意选择一种匹配方案 --&gt;然后继续考察剩下的字符 --&gt; 中途发现无法继续匹配下去了 \n --&gt;*有多种匹配方案.匹配任意个文本串中字符<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public class Pattern &#123;\n  private boolean matched &#x3D; false;\n  private char[] pattern; &#x2F;&#x2F; 正则表达式\n  private int plen; &#x2F;&#x2F; 正则表达式长度\n\n  public Pattern(char[] pattern, int plen) &#123;\n    this.pattern &#x3D; pattern;\n    this.plen &#x3D; plen;\n  &#125;\n\n  public boolean match(char[] text, int tlen) &#123; &#x2F;&#x2F; 文本串及长度\n    matched &#x3D; false;\n    rmatch(0, 0, text, tlen);\n    return matched;\n  &#125;\n\n  private void rmatch(int ti, int pj, char[] text, int tlen) &#123;\n    if (matched) return; &#x2F;&#x2F; 如果已经匹配了，就不要继续递归了\n    if (pj &#x3D;&#x3D; plen) &#123; &#x2F;&#x2F; 正则表达式到结尾了\n      if (ti &#x3D;&#x3D; tlen) matched &#x3D; true; &#x2F;&#x2F; 文本串也到结尾了\n      return;\n    &#125;\n    if (pattern[pj] &#x3D;&#x3D; &#39;*&#39;) &#123; &#x2F;&#x2F; *匹配任意个字符\n      for (int k &#x3D; 0; k &lt;&#x3D; tlen-ti; ++k) &#123;\n        rmatch(ti+k, pj+1, text, tlen);\n      &#125;\n    &#125; else if (pattern[pj] &#x3D;&#x3D; &#39;?&#39;) &#123; &#x2F;&#x2F; ?匹配0个或者1个字符\n      rmatch(ti, pj+1, text, tlen);\n      rmatch(ti+1, pj+1, text, tlen);\n    &#125; else if (ti &lt; tlen &amp;&amp; pattern[pj] &#x3D;&#x3D; text[ti]) &#123; &#x2F;&#x2F; 纯字符匹配才行\n      rmatch(ti+1, pj+1, text, tlen);\n    &#125;\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","text":"回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想引入回溯算法的应用 深度优先搜索 经典数学问题 数独 八皇后 0-1背包 图的着色 旅行商问题 全排列 如何理解回溯算法笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BB%8E%E7%94%B5%E5%BD%B1%E3%80%8A%E8%9D%B4%E8%9D%B6%E6%95%88%E5%BA%94%E3%80%8B%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">引入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">如何理解回溯算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E4%B8%AA%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">两个回溯算法的经典应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#0-1%E8%83%8C%E5%8C%85\"><span class=\"toc-text\">0-1背包</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">正则表达式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DSA38 分治算法","uid":"28170d54ceec31fbbfec4bc7706417d1","slug":"DSA/C38 分治算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:48.625Z","comments":true,"path":"api/articles/DSA/C38 分治算法.json","keywords":null,"cover":[],"text":"分治算法：谈一谈大规模计算框架MapReduce中的分治思想引入Google大数据处理三驾马车 MapReduce GFS Bigtable 如何理解分治算法核心：分而治之 将原问题划分成n个规模较小，并且结构与原问题相似的子问题 递归地解决这些子问题 然后合并其结果 分治算法的...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DSA40 初识动态规划","uid":"7315897fe4af98b9a72088541e465f37","slug":"DSA/C40 初识动态规划","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:28:16.832Z","comments":true,"path":"api/articles/DSA/C40 初识动态规划.json","keywords":null,"cover":null,"text":"初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？引入 双十一满200减50，选出来的商品价格总和最大程度接近满减条件，极大限度薅羊毛 动态规划学习路线动态规划比较适合用来求解最优问题，比如求最大值、最小值等 初识动态规划 两个经典动态规划问题模型 为什么动态规划 动态规划解...","link":"","photos":[],"count_time":{"symbolsCount":220,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}