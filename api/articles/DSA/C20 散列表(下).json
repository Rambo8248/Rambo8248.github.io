{"title":"DSA20 Hash Table3","uid":"4b485bd537f5fd1e1b5f6120bc5388d2","slug":"DSA/C20 散列表(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:10.699Z","comments":true,"path":"api/articles/DSA/C20 散列表(下).json","keywords":null,"cover":[],"content":"<h1 id=\"散列表（下）：为什么散列表和链表经常会一起使用？\"><a href=\"#散列表（下）：为什么散列表和链表经常会一起使用？\" class=\"headerlink\" title=\"散列表（下）：为什么散列表和链表经常会一起使用？\"></a>散列表（下）：为什么散列表和链表经常会一起使用？</h1><h2 id=\"LRU缓存淘汰算法\"><a href=\"#LRU缓存淘汰算法\" class=\"headerlink\" title=\"LRU缓存淘汰算法\"></a>LRU缓存淘汰算法</h2><h3 id=\"链表实现回顾\"><a href=\"#链表实现回顾\" class=\"headerlink\" title=\"链表实现回顾\"></a>链表实现回顾</h3><p><img src=\"/Users/zhangweijian/Desktop/公众号/数据结构与算法/C20 散列表(下\" alt=\"image-20210724173623972\">.assets/image-20210724173623972-1627546113415.png)</p>\n<p>一个缓存cache系统包含下面几个操作</p>\n<ul>\n<li>添加数据</li>\n<li>删除数据</li>\n<li>查找数据</li>\n</ul>\n<p>如果我们将散列表和链表两种数据结构组合使用，三个操作的时间复杂度都可降低到$O(1)$</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg\" alt=\"img\"></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>data</td>\n<td>存储数据</td>\n</tr>\n<tr>\n<td>prev</td>\n<td>前驱指针</td>\n</tr>\n<tr>\n<td>next</td>\n<td>后继指针</td>\n</tr>\n<tr>\n<td>hnext</td>\n<td>为了将结点串在散列表的拉链中</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>具体</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>查找数据</td>\n<td>1.散列表在缓存中找到数据<br />2.移动到双向链表尾部</td>\n</tr>\n<tr>\n<td>删除数据</td>\n<td>1.找到数据所在结点<br />2.将结点删除</td>\n</tr>\n<tr>\n<td>添加数据</td>\n<td>如下图</td>\n</tr>\n</tbody>\n</table>\n</div>\n<pre class=\"mermaid\">graph TD\n看数据是否在缓存中 -->在缓存中 -->移动到双向链表尾部\n看数据是否在缓存中 --> 不在缓存中 --> 看缓存有没有满 -->已满 -->将双向链表头部结点删除.再将数据放到链表尾部\n看缓存有没有满 -->未满--> 直接将数据放到链表尾部</pre>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gtuaxq23y7j60lt0ctdgh02.jpg\" alt=\"image-20210729163350162\"></p>\n<h2 id=\"Redis有序集合\"><a href=\"#Redis有序集合\" class=\"headerlink\" title=\"Redis有序集合\"></a>Redis有序集合</h2><p>细化Redis有序集合的操作</p>\n<ul>\n<li>添加一个成员对象</li>\n<li>按照键值删除一个成员对象</li>\n<li>按照键值查找一个成员对象</li>\n<li>按照分值区间查找数据</li>\n<li>按照分值从小到大排序成员变量</li>\n</ul>\n<h2 id=\"Java-LinkedHashMap\"><a href=\"#Java-LinkedHashMap\" class=\"headerlink\" title=\"Java LinkedHashMap\"></a>Java LinkedHashMap</h2><p>LinkedHashMap并非是一个通过链表法解决散列冲突的散列表</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">HashMap&lt;Integer, Integer&gt; m &#x3D; new LinkedHashMap&lt;&gt;();\nm.put(3, 11);\nm.put(1, 12);\nm.put(5, 23);\nm.put(2, 22);\n\nfor (Map.Entry e : m.entrySet()) &#123;\n  System.out.println(e.getKey());\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>结果：打印<code>3,1,5,2</code>→支持按照插入顺序遍历数据</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">&#x2F;&#x2F; 10是初始大小，0.75是装载因子，true是表示按照访问时间排序\nHashMap&lt;Integer, Integer&gt; m &#x3D; new LinkedHashMap&lt;&gt;(10, 0.75f, true);\nm.put(3, 11);\nm.put(1, 12);\nm.put(5, 23);\nm.put(2, 22);\n\nm.put(3, 26);\nm.get(5);\n\nfor (Map.Entry e : m.entrySet()) &#123;\n  System.out.println(e.getKey());\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>结果：打印<code>1,2,3,5</code>→支持按照访问顺序来遍历数据</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/17/98/17ac41d9dac454e454dcb289100bf198.jpg\" alt=\"img\"></p>\n<p><img src=\"https://static001.geekbang.org/resource/image/fe/8c/fe313ed327bcf234c73ba738d975b18c.jpg\" alt=\"img\"></p>\n<p><img src=\"https://static001.geekbang.org/resource/image/b5/11/b5e07bb34d532d46d127f4fcc4b78f11.jpg\" alt=\"img\"></p>\n<p>LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突</p>\n","text":"散列表（下）：为什么散列表和链表经常会一起使用？LRU缓存淘汰算法链表实现回顾.assets/image-20210724173623972-1627546113415.png) 一个缓存cache系统包含下面几个操作 添加数据 删除数据 查找数据 如果我们将散列表和链表两种数据...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%A3%E5%88%97%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%B8%B8%E4%BC%9A%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">散列表（下）：为什么散列表和链表经常会一起使用？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">LRU缓存淘汰算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">链表实现回顾</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88\"><span class=\"toc-text\">Redis有序集合</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java-LinkedHashMap\"><span class=\"toc-text\">Java LinkedHashMap</span></a></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DSA11 Sort1","uid":"dc2049cb2b924724d0d9c0e20e1cbe8f","slug":"DSA/C11 排序(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:32.914Z","comments":true,"path":"api/articles/DSA/C11 排序(上).json","keywords":null,"cover":[],"text":"排序（上）：为什么插入排序比冒泡排序更受欢迎？概述 如何分析一个排序算法？ 执行效率 最好、最坏、平均情况时间复杂度 时间复杂度的系数、常数、低阶 比较次数和交换次数 内存消耗 原地排序特指空间复杂度是$O(1)$的排序算法 稳定性 如果待排序的序列中存在值相等的元素，经过排序之...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DSA21 Hash Algorithm1","uid":"df821ff4999b5ea1cca6788fc47b1fb5","slug":"DSA/C21 哈希算法(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:32.250Z","comments":true,"path":"api/articles/DSA/C21 哈希算法(上).json","keywords":null,"cover":[],"text":"哈希算法（上）：如何防止数据库中的用户信息被脱库？引入 2011CSDN“脱库”事件 在实际开发中，如何用哈希算法解决问题 什么是哈希算法？哈希算法：将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法。而通过原始数据映射之后得到的二进制值串就是哈希值。 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}