{"title":"DSA20 Hash Table3","uid":"4b485bd537f5fd1e1b5f6120bc5388d2","slug":"DSA/C20 散列表(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:10.699Z","comments":true,"path":"api/articles/DSA/C20 散列表(下).json","keywords":null,"cover":[],"content":"<h1 id=\"散列表（下）：为什么散列表和链表经常会一起使用？\"><a href=\"#散列表（下）：为什么散列表和链表经常会一起使用？\" class=\"headerlink\" title=\"散列表（下）：为什么散列表和链表经常会一起使用？\"></a>散列表（下）：为什么散列表和链表经常会一起使用？</h1><h2 id=\"LRU缓存淘汰算法\"><a href=\"#LRU缓存淘汰算法\" class=\"headerlink\" title=\"LRU缓存淘汰算法\"></a>LRU缓存淘汰算法</h2><h3 id=\"链表实现回顾\"><a href=\"#链表实现回顾\" class=\"headerlink\" title=\"链表实现回顾\"></a>链表实现回顾</h3><p>![image-20210724173623972](/Users/zhangweijian/Desktop/公众号/数据结构与算法/C20 散列表(下).assets/image-20210724173623972-1627546113415.png)</p>\n<p>一个缓存cache系统包含下面几个操作</p>\n<ul>\n<li>添加数据</li>\n<li>删除数据</li>\n<li>查找数据</li>\n</ul>\n<p>如果我们将散列表和链表两种数据结构组合使用，三个操作的时间复杂度都可降低到$O(1)$</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>data</td>\n<td>存储数据</td>\n</tr>\n<tr>\n<td>prev</td>\n<td>前驱指针</td>\n</tr>\n<tr>\n<td>next</td>\n<td>后继指针</td>\n</tr>\n<tr>\n<td>hnext</td>\n<td>为了将结点串在散列表的拉链中</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>具体</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>查找数据</td>\n<td>1.散列表在缓存中找到数据<br />2.移动到双向链表尾部</td>\n</tr>\n<tr>\n<td>删除数据</td>\n<td>1.找到数据所在结点<br />2.将结点删除</td>\n</tr>\n<tr>\n<td>添加数据</td>\n<td>如下图</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">graph TD\n看数据是否在缓存中 --&gt;在缓存中 --&gt;移动到双向链表尾部\n看数据是否在缓存中 --&gt; 不在缓存中 --&gt; 看缓存有没有满 --&gt;已满 --&gt;将双向链表头部结点删除.再将数据放到链表尾部\n看缓存有没有满 --&gt;未满--&gt; 直接将数据放到链表尾部<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gtuaxq23y7j60lt0ctdgh02.jpg\" alt=\"image-20210729163350162\"></p>\n<h2 id=\"Redis有序集合\"><a href=\"#Redis有序集合\" class=\"headerlink\" title=\"Redis有序集合\"></a>Redis有序集合</h2><p>细化Redis有序集合的操作</p>\n<ul>\n<li>添加一个成员对象</li>\n<li>按照键值删除一个成员对象</li>\n<li>按照键值查找一个成员对象</li>\n<li>按照分值区间查找数据</li>\n<li>按照分值从小到大排序成员变量</li>\n</ul>\n<h2 id=\"Java-LinkedHashMap\"><a href=\"#Java-LinkedHashMap\" class=\"headerlink\" title=\"Java LinkedHashMap\"></a>Java LinkedHashMap</h2><p>LinkedHashMap并非是一个通过链表法解决散列冲突的散列表</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">HashMap&lt;Integer, Integer&gt; m &#x3D; new LinkedHashMap&lt;&gt;();\nm.put(3, 11);\nm.put(1, 12);\nm.put(5, 23);\nm.put(2, 22);\n\nfor (Map.Entry e : m.entrySet()) &#123;\n  System.out.println(e.getKey());\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果：打印<code>3,1,5,2</code>→支持按照插入顺序遍历数据</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">&#x2F;&#x2F; 10是初始大小，0.75是装载因子，true是表示按照访问时间排序\nHashMap&lt;Integer, Integer&gt; m &#x3D; new LinkedHashMap&lt;&gt;(10, 0.75f, true);\nm.put(3, 11);\nm.put(1, 12);\nm.put(5, 23);\nm.put(2, 22);\n\nm.put(3, 26);\nm.get(5);\n\nfor (Map.Entry e : m.entrySet()) &#123;\n  System.out.println(e.getKey());\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果：打印<code>1,2,3,5</code>→支持按照访问顺序来遍历数据</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/17/98/17ac41d9dac454e454dcb289100bf198.jpg\" alt=\"img\"></p>\n<p><img src=\"https://static001.geekbang.org/resource/image/fe/8c/fe313ed327bcf234c73ba738d975b18c.jpg\" alt=\"img\"></p>\n<p><img src=\"https://static001.geekbang.org/resource/image/b5/11/b5e07bb34d532d46d127f4fcc4b78f11.jpg\" alt=\"img\"></p>\n<p>LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突</p>\n","text":"散列表（下）：为什么散列表和链表经常会一起使用？LRU缓存淘汰算法链表实现回顾![image-20210724173623972](/Users/zhangweijian/Desktop/公众号/数据结构与算法/C20 散列表(下).assets/image-2021072417...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%A3%E5%88%97%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%B8%B8%E4%BC%9A%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">散列表（下）：为什么散列表和链表经常会一起使用？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">LRU缓存淘汰算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">链表实现回顾</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88\"><span class=\"toc-text\">Redis有序集合</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java-LinkedHashMap\"><span class=\"toc-text\">Java LinkedHashMap</span></a></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DSA2 如何抓住重点","uid":"5baaeff214933c2b700d2810a6a1c372","slug":"DSA/C2 如何抓住重点","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:18:16.933Z","comments":true,"path":"api/articles/DSA/C2 如何抓住重点.json","keywords":null,"cover":[],"text":"如何抓住重点，系统高效地学习数据结构与算法？什么是数据结构？什么是算法？广义 数据结构：一组数据的存储结构 算法：操作数据的一组方法 狭义 著名的数据结构和算法 数据结构与算法的关系 数据结构为算法服务 算法作用于特定的数据结构 需要的基础 数学基础 编程基础 学习重点 复杂度分...","link":"","photos":[],"count_time":{"symbolsCount":378,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DSA22 Hash Algorithm2","uid":"a8b428ae06db3a75338b25077c7c9ca3","slug":"DSA/C22 哈希算法(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:40.177Z","comments":true,"path":"api/articles/DSA/C22 哈希算法(下).json","keywords":null,"cover":[],"text":"哈希算法（下）：哈希算法在分布式系统中有哪些应用？哈希算法是如何解决这些分布式问题的 负载均衡负载均衡算法很多，如何才能实现一个会话粘滞的负载均衡算法？即需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上 直接的办法 维护一张映射关系表 弊端 客户端很多，映射表很...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}