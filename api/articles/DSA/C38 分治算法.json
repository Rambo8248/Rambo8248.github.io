{"title":"DSA38 分治算法","uid":"28170d54ceec31fbbfec4bc7706417d1","slug":"DSA/C38 分治算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:48.000Z","comments":true,"path":"api/articles/DSA/C38 分治算法.json","keywords":null,"cover":[],"content":"<h1 id=\"分治算法：谈一谈大规模计算框架MapReduce中的分治思想\"><a href=\"#分治算法：谈一谈大规模计算框架MapReduce中的分治思想\" class=\"headerlink\" title=\"分治算法：谈一谈大规模计算框架MapReduce中的分治思想\"></a>分治算法：谈一谈大规模计算框架MapReduce中的分治思想</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>Google大数据处理三驾马车</p>\n<ul>\n<li>MapReduce</li>\n<li>GFS</li>\n<li>Bigtable</li>\n</ul>\n<h2 id=\"如何理解分治算法\"><a href=\"#如何理解分治算法\" class=\"headerlink\" title=\"如何理解分治算法\"></a>如何理解分治算法</h2><p>核心：分而治之</p>\n<ul>\n<li>将原问题划分成n个规模较小，并且结构与原问题相似的子问题</li>\n<li>递归地解决这些子问题</li>\n<li>然后合并其结果</li>\n</ul>\n<p>分治算法的递归实现，每一层递归都会涉及三个操作</p>\n<ul>\n<li>分解：将原问题分解成一系列子问题</li>\n<li>解决：递归地求解各个子问题，若子问题足够小，则直接求解</li>\n<li>合并：将子问题的结果合并成原问题</li>\n</ul>\n<p>分治算法能解决的问题一般需要满足几个条件</p>\n<ul>\n<li>原问题与分解成的小问题具有相同的模式</li>\n<li>原问题分解的子问题可以独立求解，子问题之间没有相关性</li>\n<li>具有分解终止条件，也即问题足够小时，可以直接求解</li>\n<li>可以将子问题合并成原问题，合并操作复杂度不能太高，否则起不到减小算法总体复杂度的效果</li>\n</ul>\n<h2 id=\"分治算法应用举例分析\"><a href=\"#分治算法应用举例分析\" class=\"headerlink\" title=\"分治算法应用举例分析\"></a>分治算法应用举例分析</h2><h3 id=\"如何编程求出一组数据的有序对个数或者逆序对个数？\"><a href=\"#如何编程求出一组数据的有序对个数或者逆序对个数？\" class=\"headerlink\" title=\"如何编程求出一组数据的有序对个数或者逆序对个数？\"></a>如何编程求出一组数据的有序对个数或者逆序对个数？</h3><p>分治算法</p>\n<ul>\n<li><p>将数组分成前后两半A1和A2</p>\n</li>\n<li><p>分别计算A1和A2的逆序对个数K1和K2</p>\n</li>\n<li><p>计算A1与A2之间逆序对个数K3</p>\n<ul>\n<li><p><img src=\"https://static001.geekbang.org/resource/image/e8/32/e835cab502bec3ebebab92381c667532.jpg\" alt=\"img\"></p>\n</li>\n<li><pre><code class=\"lang-java\">private int num = 0; // 全局变量或者成员变量\n\npublic int count(int[] a, int n) &#123;\n  num = 0;\n  mergeSortCounting(a, 0, n-1);\n  return num;\n&#125;\n\nprivate void mergeSortCounting(int[] a, int p, int r) &#123;\n  if (p &gt;= r) return;\n  int q = (p+r)/2;\n  mergeSortCounting(a, p, q);\n  mergeSortCounting(a, q+1, r);\n  merge(a, p, q, r);\n&#125;\n\nprivate void merge(int[] a, int p, int q, int r) &#123;\n  int i = p, j = q+1, k = 0;\n  int[] tmp = new int[r-p+1];\n  while (i&lt;=q &amp;&amp; j&lt;=r) &#123;\n    if (a[i] &lt;= a[j]) &#123;\n      tmp[k++] = a[i++];\n    &#125; else &#123;\n      num += (q-i+1); // 统计p-q之间，比a[j]大的元素个数\n      tmp[k++] = a[j++];\n    &#125;\n  &#125;\n  while (i &lt;= q) &#123; // 处理剩下的\n    tmp[k++] = a[i++];\n  &#125;\n  while (j &lt;= r) &#123; // 处理剩下的\n    tmp[k++] = a[j++];\n  &#125;\n  for (i = 0; i &lt;= r-p; ++i) &#123; // 从tmp拷贝回a\n    a[p+i] = tmp[i];\n  &#125;\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>逆序对个数 = K1 + K2 + K3</p>\n</li>\n</ul>\n<h3 id=\"分治思想在海量数据处理中的应用\"><a href=\"#分治思想在海量数据处理中的应用\" class=\"headerlink\" title=\"分治思想在海量数据处理中的应用\"></a>分治思想在海量数据处理中的应用</h3><ul>\n<li>海量数据集合根据某种方法划分为几个小的数据集合</li>\n<li>每个小的数据集合单独加载到内存解决</li>\n<li>将小数据集合合并成大数据集合</li>\n</ul>\n","text":"分治算法：谈一谈大规模计算框架MapReduce中的分治思想引入Google大数据处理三驾马车 MapReduce GFS Bigtable 如何理解分治算法核心：分而治之 将原问题划分成n个规模较小，并且结构与原问题相似的子问题 递归地解决这些子问题 然后合并其结果 分治算法的...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%EF%BC%9A%E8%B0%88%E4%B8%80%E8%B0%88%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6MapReduce%E4%B8%AD%E7%9A%84%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">分治算法：谈一谈大规模计算框架MapReduce中的分治思想</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">引入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">如何理解分治算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">分治算法应用举例分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%BC%96%E7%A8%8B%E6%B1%82%E5%87%BA%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%89%E5%BA%8F%E5%AF%B9%E4%B8%AA%E6%95%B0%E6%88%96%E8%80%85%E9%80%86%E5%BA%8F%E5%AF%B9%E4%B8%AA%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">如何编程求出一组数据的有序对个数或者逆序对个数？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E5%9C%A8%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">分治思想在海量数据处理中的应用</span></a></li></ol></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DSA37 Greedy Algorithm","uid":"a9e32e2621fbdc03b2a42efbcf0ce8e5","slug":"DSA/C37 贪心算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:30.000Z","comments":true,"path":"api/articles/DSA/C37 贪心算法.json","keywords":null,"cover":[],"text":"贪心算法：如何用贪心算法实现Huffman压缩编码？几个基本的算法思想 贪心算法 Huffman Coding Prim和Kruskal最小生成树算法 Dijkstra单源最短路径 分治算法 回溯算法 动态规划 本章如何利用贪心算法实现对数据压缩编码，有效节省数据存储空间 如何理...","link":"","photos":[],"count_time":{"symbolsCount":678,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DSA40 初识动态规划","uid":"7315897fe4af98b9a72088541e465f37","slug":"DSA/C40 初识动态规划","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:28:16.000Z","comments":true,"path":"api/articles/DSA/C40 初识动态规划.json","keywords":null,"cover":null,"text":"初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？引入 双十一满200减50，选出来的商品价格总和最大程度接近满减条件，极大限度薅羊毛 动态规划学习路线动态规划比较适合用来求解最优问题，比如求最大值、最小值等 初识动态规划 两个经典动态规划问题模型 为什么动态规划 动态规划解...","link":"","photos":[],"count_time":{"symbolsCount":220,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}