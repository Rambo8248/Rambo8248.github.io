{"title":"DSA27 Recursion Tree","uid":"134dfc72e46d7c11aedb7ca140c26710","slug":"DSA/C27 递归树","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:19.000Z","comments":true,"path":"api/articles/DSA/C27 递归树.json","keywords":null,"cover":[],"content":"<h1 id=\"递归树：如何借助树来求解递归算法的时间复杂度？\"><a href=\"#递归树：如何借助树来求解递归算法的时间复杂度？\" class=\"headerlink\" title=\"递归树：如何借助树来求解递归算法的时间复杂度？\"></a>递归树：如何借助树来求解递归算法的时间复杂度？</h1><h2 id=\"递归树与时间复杂度分析\"><a href=\"#递归树与时间复杂度分析\" class=\"headerlink\" title=\"递归树与时间复杂度分析\"></a>递归树与时间复杂度分析</h2><p> <img src=\"https://static001.geekbang.org/resource/image/1d/a3/1d9648b7f43e430473d76d24803159a3.jpg\" alt=\"img\"></p>\n<p><img src=\"https://static001.geekbang.org/resource/image/c6/d0/c66bfc3d02d3b7b8f64c208bf4c948d0.jpg\" alt=\"img\"></p>\n<h2 id=\"实战1：分析快速排序的时间复杂度\"><a href=\"#实战1：分析快速排序的时间复杂度\" class=\"headerlink\" title=\"实战1：分析快速排序的时间复杂度\"></a>实战1：分析快速排序的时间复杂度</h2><p>假设平均情况下，每次分区后，两个分区的大小比例为1:k，当k=9时，递推公式为：</p>\n<script type=\"math/tex; mode=display\">\nT(n) = T(\\frac{n}{10})+T(\\frac{9n}{10})+n</script><p>用递归树来分析：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/44/43/44972a3531dae0b7a0ccc935bc13f243.jpg\" alt=\"img\"></p>\n<ul>\n<li>每一层分区操作所遍历的数据的个数之和就是n</li>\n<li>递归树的高度h<ul>\n<li>如何求解</li>\n<li><img src=\"https://static001.geekbang.org/resource/image/7c/ed/7cea8607f0d92a901f3152341830d6ed.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n<li>快排过程遍历的数据个数就是h<em>n，时间复杂度为$O(h\\</em>n)$<ul>\n<li>所以$O(nlogn)$</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"实战2：分析斐波那契数列的时间复杂度\"><a href=\"#实战2：分析斐波那契数列的时间复杂度\" class=\"headerlink\" title=\"实战2：分析斐波那契数列的时间复杂度\"></a>实战2：分析斐波那契数列的时间复杂度</h2><p><img src=\"https://static001.geekbang.org/resource/image/9c/ce/9ccbce1a70c7e2def52701dcf176a4ce.jpg\" alt=\"img\"></p>\n<ul>\n<li>时间复杂度介于$O(2^n)$与$O(2^{\\frac{n}{2}})$</li>\n</ul>\n<h2 id=\"实战3：分析全排列的时间复杂度\"><a href=\"#实战3：分析全排列的时间复杂度\" class=\"headerlink\" title=\"实战3：分析全排列的时间复杂度\"></a>实战3：分析全排列的时间复杂度</h2><p>递推公式</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">假设数组中存储的是1，2， 3...n。\n        \nf(1,2,...n) &#x3D; &#123;最后一位是1, f(n-1)&#125; + &#123;最后一位是2, f(n-1)&#125; +...+&#123;最后一位是n, f(n-1)&#125;。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 调用方式：</span>\n<span class=\"token comment\">// int[]a = a=&#123;1, 2, 3, 4&#125;; printPermutations(a, 4, 4);</span>\n<span class=\"token comment\">// k表示要处理的子数组的数据个数</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">printPermutations</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> k<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    data<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span>k<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    data<span class=\"token punctuation\">[</span>k<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printPermutations</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> k <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    tmp <span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    data<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span>k<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    data<span class=\"token punctuation\">[</span>k<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://static001.geekbang.org/resource/image/82/9b/82f40bed489cf29b14192b44decf059b.jpg\" alt=\"img\"></p>\n<p>时间复杂度介于$O(n!)$与$O(n*n!)$之间</p>\n","text":"递归树：如何借助树来求解递归算法的时间复杂度？递归树与时间复杂度分析 实战1：分析快速排序的时间复杂度假设平均情况下，每次分区后，两个分区的大小比例为1:k，当k=9时，递推公式为： T(n) = T(\\frac{n}{10})+T(\\frac{9n}{10})+n用递归树来分析...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92%E6%A0%91%EF%BC%9A%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E6%A0%91%E6%9D%A5%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9F\"><span class=\"toc-text\">递归树：如何借助树来求解递归算法的时间复杂度？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92%E6%A0%91%E4%B8%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\"><span class=\"toc-text\">递归树与时间复杂度分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%88%981%EF%BC%9A%E5%88%86%E6%9E%90%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">实战1：分析快速排序的时间复杂度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%88%982%EF%BC%9A%E5%88%86%E6%9E%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">实战2：分析斐波那契数列的时间复杂度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%88%983%EF%BC%9A%E5%88%86%E6%9E%90%E5%85%A8%E6%8E%92%E5%88%97%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">实战3：分析全排列的时间复杂度</span></a></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DSA26 Red-Black Tree2","uid":"7693d3ff77636135d449fe9da08ce394","slug":"DSA/C26 红黑树(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:24:48.000Z","comments":true,"path":"api/articles/DSA/C26 红黑树(下).json","keywords":null,"cover":[],"text":"红黑树（下）：掌握这些技巧，你也可以实现一个红黑树 爱：稳定、高效的性能 恨：实现起来比较难 实现红黑树的基本思想大致过程遇到什么样的节点排布，我们就对应怎么去调整 回顾红黑树的要求 节点类型 颜色 根节点 黑色 叶子节点 黑色的空节点，不存储数据 相邻节点 不能同时为红色 每个...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DSA29 Heap Application","uid":"3d8241738a6ca807ab996c00fc84c560","slug":"DSA/C29 堆的应用","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:47.000Z","comments":true,"path":"api/articles/DSA/C29 堆的应用.json","keywords":null,"cover":[],"text":"堆的应用：如何快速获取到Top 10最热门的搜索关键词？堆的几个经典应用 优先级队列 求Top K 求中位数 堆的应用一：优先级队列 优先级队列 队列 出队顺序按照优先级来 优先级队列与堆很像 插入元素→堆中插入元素 取出优先级最高的元素→取出堆顶元素 合并有序小文件 问题描述 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}