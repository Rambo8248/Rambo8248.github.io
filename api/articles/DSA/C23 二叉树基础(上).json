{"title":"DSA23 Binary Tree1","uid":"56aa12aba5d53418e62bb5c5f6efe64b","slug":"DSA/C23 二叉树基础(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:57.541Z","comments":true,"path":"api/articles/DSA/C23 二叉树基础(上).json","keywords":null,"cover":[],"content":"<h1 id=\"二叉树基础（上）：什么样的二叉树适合用数组来存储？\"><a href=\"#二叉树基础（上）：什么样的二叉树适合用数组来存储？\" class=\"headerlink\" title=\"二叉树基础（上）：什么样的二叉树适合用数组来存储？\"></a>二叉树基础（上）：什么样的二叉树适合用数组来存储？</h1><h2 id=\"问题引入\"><a href=\"#问题引入\" class=\"headerlink\" title=\"问题引入\"></a>问题引入</h2><p><img src=\"https://static001.geekbang.org/resource/image/6c/c9/6ce8707f43e1a3e7e5368167cca6a4c9.jpg\" alt=\"img\"></p>\n<p>二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？</p>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><p><img src=\"https://static001.geekbang.org/resource/image/b7/29/b7043bf29a253bb36221eaec62b2e129.jpg\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>名词</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>节点</td>\n<td>树中的每个元素</td>\n</tr>\n<tr>\n<td>父子关系</td>\n<td>用来连接相邻节点之间的关系</td>\n</tr>\n<tr>\n<td>父节点</td>\n<td>上级节点</td>\n</tr>\n<tr>\n<td>子节点</td>\n<td>下级节点</td>\n</tr>\n<tr>\n<td>兄弟节点</td>\n<td>同级节点</td>\n</tr>\n<tr>\n<td>叶子节点/叶节点</td>\n<td>没有子节点的节点</td>\n</tr>\n<tr>\n<td>节点高度</td>\n<td>节点到叶子节点的最长路径（边数）</td>\n</tr>\n<tr>\n<td>节点深度</td>\n<td>根节点到这个节点所经历的边的个数</td>\n</tr>\n<tr>\n<td>节点层数</td>\n<td>节点深度+1</td>\n</tr>\n<tr>\n<td>树的高度</td>\n<td>根节点的高度</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://static001.geekbang.org/resource/image/50/b4/50f89510ad1f7570791dd12f4e9adeb4.jpg\" alt=\"img\"></p>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><h3 id=\"相关定义\"><a href=\"#相关定义\" class=\"headerlink\" title=\"相关定义\"></a>相关定义</h3><p>每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/09/2b/09c2972d56eb0cf67e727deda0e9412b.jpg\" alt=\"img\"></p>\n<ul>\n<li>满二叉树，2，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点</li>\n<li>完全二叉树，3，叶子节点都在最底两层，最后一层叶子节点靠左排列，除了最后一层，其它层节点个数都要达到最大</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/18/60/18413c6597c2850b75367393b401ad60.jpg\" alt=\"img\"></p>\n<h3 id=\"如何表示（存储）一棵二叉树？\"><a href=\"#如何表示（存储）一棵二叉树？\" class=\"headerlink\" title=\"如何表示（存储）一棵二叉树？\"></a>如何表示（存储）一棵二叉树？</h3><ul>\n<li>链式存储法<ul>\n<li>基于指针或者引用</li>\n<li><img src=\"https://static001.geekbang.org/resource/image/12/8e/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n<li>顺序存储法<ul>\n<li>基于数组</li>\n<li><img src=\"https://static001.geekbang.org/resource/image/14/30/14eaa820cb89a17a7303e8847a412330.jpg\" alt=\"img\"></li>\n<li>节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点</li>\n<li>反过来，下标为 i/2 的位置存储就是它的父节点。</li>\n</ul>\n</li>\n</ul>\n<p>非完全二叉树会浪费比较多的数组存储空间</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/08/23/08bd43991561ceeb76679fbb77071223.jpg\" alt=\"img\"></p>\n<p>结论：</p>\n<p>如果某棵二叉树是一棵完全二叉树，用数组无疑是最节省内存的一种方式。数组不需额外存储左右子节点指针</p>\n<h2 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h2><p><img src=\"https://static001.geekbang.org/resource/image/ab/16/ab103822e75b5b15c615b68560cb2416.jpg\" alt=\"img\"></p>\n<p>递推公式</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">前序遍历的递推公式：\npreOrder(r) &#x3D; print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)\n\n中序遍历的递推公式：\ninOrder(r) &#x3D; inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)\n\n后序遍历的递推公式：\npostOrder(r) &#x3D; postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">preOrder</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Node</span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  print root <span class=\"token comment\">// 此处为伪代码，表示打印root节点</span>\n  <span class=\"token function\">preOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">preOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">inOrder</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Node</span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">inOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  print root <span class=\"token comment\">// 此处为伪代码，表示打印root节点</span>\n  <span class=\"token function\">inOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">postOrder</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Node</span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">postOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">postOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  print root <span class=\"token comment\">// 此处为伪代码，表示打印root节点</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>遍历的时间复杂度</p>\n<p>$O(n)$</p>\n","text":"二叉树基础（上）：什么样的二叉树适合用数组来存储？问题引入 二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？ 树 名词 定义 节点 树中的每个元素 父子关系 用来连接相邻节点之间的关系 父节点 上级节点 子节点 下级节点 兄弟节点 同级节点 叶子节点/叶节点 没有子节点的...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8%EF%BC%9F\"><span class=\"toc-text\">二叉树基础（上）：什么样的二叉树适合用数组来存储？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">问题引入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%91\"><span class=\"toc-text\">树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">二叉树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%85%B3%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">相关定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%EF%BC%88%E5%AD%98%E5%82%A8%EF%BC%89%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F\"><span class=\"toc-text\">如何表示（存储）一棵二叉树？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">二叉树的遍历</span></a></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DSA21 Hash Algorithm1","uid":"df821ff4999b5ea1cca6788fc47b1fb5","slug":"DSA/C21 哈希算法(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:32.250Z","comments":true,"path":"api/articles/DSA/C21 哈希算法(上).json","keywords":null,"cover":[],"text":"哈希算法（上）：如何防止数据库中的用户信息被脱库？引入 2011CSDN“脱库”事件 在实际开发中，如何用哈希算法解决问题 什么是哈希算法？哈希算法：将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法。而通过原始数据映射之后得到的二进制值串就是哈希值。 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DSA24 Binary Tree2","uid":"17d7fb60ad31417e734a0509256cfdc1","slug":"DSA/C24 二叉树基础(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:24:08.589Z","comments":true,"path":"api/articles/DSA/C24 二叉树基础(下).json","keywords":null,"cover":[],"text":"二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？二叉查找树的最大特点：支持动态数据集合的快速插入、删除、查找 散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是 O(1)。既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}