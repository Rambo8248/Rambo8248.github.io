{"title":"DSA18 Hash Table1","uid":"f2a6a2cecbbac22b23528956a3dabf70","slug":"DSA/C18 散列表(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:22:42.000Z","comments":true,"path":"api/articles/DSA/C18 散列表(上).json","keywords":null,"cover":[],"content":"<h1 id=\"散列表（上）：Word文档中的单词拼写检查功能是如何实现的？\"><a href=\"#散列表（上）：Word文档中的单词拼写检查功能是如何实现的？\" class=\"headerlink\" title=\"散列表（上）：Word文档中的单词拼写检查功能是如何实现的？\"></a>散列表（上）：Word文档中的单词拼写检查功能是如何实现的？</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>Word拼写检查功能</p>\n<h2 id=\"散列思想\"><a href=\"#散列思想\" class=\"headerlink\" title=\"散列思想\"></a>散列思想</h2><p>Hash Table</p>\n<p>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表</p>\n<p>经典例子</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/92/73/92c89a57e21f49d2f14f4424343a2773.jpg\" alt=\"img\"></p>\n<ul>\n<li><p>参赛选手的编号：key 关键字</p>\n<ul>\n<li>标识一个选手</li>\n</ul>\n</li>\n<li><p>参赛编号转化为数组下标的映射方法：Hash函数</p>\n<ul>\n<li>在本例中为选取key的后两位</li>\n</ul>\n</li>\n<li><p>散列函数计算得到的值：Hash值</p>\n</li>\n<li><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gtuawtrnwcj607m08674602.jpg\" alt=\"image-20210729163111652\"></p>\n</li>\n<li><pre class=\"mermaid\">  graph TD\nKey --HashFunction-->table -->索引</pre>\n\n</li>\n</ul>\n<p>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性</p>\n<p>我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置</p>\n<p>当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据</p>\n<h2 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h2><script type=\"math/tex; mode=display\">\n散列函数 = hash(key)</script><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>String key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">// 获取后两位字符</span>\n  string lastTwoChars <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span>length<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 将后两位字符转换为整数</span>\n  <span class=\"token keyword\">int</span> hashValue <span class=\"token operator\">=</span> convert lastTwoChas to <span class=\"token keyword\">int</span><span class=\"token operator\">-</span>type<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> hashValue<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>散列函数设计基本要求</p>\n<ul>\n<li><p>散列函数计算得到的散列值是一个非负整数</p>\n</li>\n<li><script type=\"math/tex; mode=display\">\nif \\quad key1 == key2 →hash(key1) == hash(key2)</script></li>\n<li><script type=\"math/tex; mode=display\">\nif \\quad key1 \\not= key2 →hash(key1) \\not= hash(key2)</script></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>散列冲突：</p>\n<p>要想找到一个不同的key对应的散列值都不一样的散列函数，几乎是不可能的；</p>\n<p>而且因为数组的存储空间有限，也会加大散列冲突的概率</p></blockquote>\n<h2 id=\"散列冲突\"><a href=\"#散列冲突\" class=\"headerlink\" title=\"散列冲突\"></a>散列冲突</h2><p>如何解决散列冲突问题呢？</p>\n<ul>\n<li>开放寻址法 Open Addressing<ul>\n<li>如果出现了散列冲突，重新探测一个空闲位置，将其插入</li>\n<li>线性探测Linear  Probing</li>\n<li>二次探测Quadratic Probing</li>\n<li>双重散列Double hashing</li>\n</ul>\n</li>\n<li>链表法 Chaining</li>\n</ul>\n<h3 id=\"开放寻址法\"><a href=\"#开放寻址法\" class=\"headerlink\" title=\"开放寻址法\"></a>开放寻址法</h3><h4 id=\"线性探测法\"><a href=\"#线性探测法\" class=\"headerlink\" title=\"线性探测法\"></a>线性探测法</h4><p>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次向后查找，看是否有空闲位置，直到找到为止</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/5c/d5/5c31a3127cbc00f0c63409bbe1fbd0d5.jpg\" alt=\"img\"></p>\n<p><img src=\"https://static001.geekbang.org/resource/image/91/ff/9126b0d33476777e7371b96e676e90ff.jpg\" alt=\"img\"></p>\n<ul>\n<li>插入</li>\n<li>查找</li>\n<li>删除→不能单纯把要删除的元素设置为空，会导致查找算法失效，故可以将删除的元素标记为deleted<ul>\n<li>当线性探测查找时，遇到标记为deleted空间并不是停下来而是继续往下探测</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/fe/1d/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg\" alt=\"img\"></p>\n<p>线性探测法的问题</p>\n<ul>\n<li>散列表中插入数据越来越多时，散列冲突发生可能性越来越大，空闲位置越来越少</li>\n</ul>\n<h4 id=\"二次探测\"><a href=\"#二次探测\" class=\"headerlink\" title=\"二次探测\"></a>二次探测</h4><p>二次探测步长为原来的二次方</p>\n<script type=\"math/tex; mode=display\">\nhash(key)+0\\\\\nhash(key)+1^2\\\\\nhash(key) + 2^2\\\\\n\\cdots</script><h4 id=\"双重散列\"><a href=\"#双重散列\" class=\"headerlink\" title=\"双重散列\"></a>双重散列</h4><p>不仅要使用一个散列函数，而是使用一组散列函数</p>\n<script type=\"math/tex; mode=display\">\nhash1(key1) \\\\\nhash2(key2)\\\\\nhash3(key3)</script><h4 id=\"装载因子\"><a href=\"#装载因子\" class=\"headerlink\" title=\"装载因子\"></a>装载因子</h4><script type=\"math/tex; mode=display\">\nload\\_factor = 填入表中的元素个数 /散列表的长度</script><h3 id=\"链表法\"><a href=\"#链表法\" class=\"headerlink\" title=\"链表法\"></a>链表法</h3><ul>\n<li>每个bucket或slot会对应一条链表</li>\n<li>所有散列值相同的元素都放到相同槽位对应的链表中</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg\" alt=\"img\"></p>\n","text":"散列表（上）：Word文档中的单词拼写检查功能是如何实现的？引入Word拼写检查功能 散列思想Hash Table 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表 经典例子 参赛选手的编号：ke...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9AWord%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%8A%9F%E8%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">散列表（上）：Word文档中的单词拼写检查功能是如何实现的？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">引入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">散列思想</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">散列函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81\"><span class=\"toc-text\">散列冲突</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95\"><span class=\"toc-text\">开放寻址法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95\"><span class=\"toc-text\">线性探测法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B\"><span class=\"toc-text\">二次探测</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E9%87%8D%E6%95%A3%E5%88%97\"><span class=\"toc-text\">双重散列</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A3%85%E8%BD%BD%E5%9B%A0%E5%AD%90\"><span class=\"toc-text\">装载因子</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E6%B3%95\"><span class=\"toc-text\">链表法</span></a></li></ol></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DSA17 Skip List","uid":"0bec27181caef93fd79c11aa3edf5064","slug":"DSA/C17 跳表","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:22:29.000Z","comments":true,"path":"api/articles/DSA/C17 跳表.json","keywords":null,"cover":[],"text":"跳表：为什么Redis一定要用跳表来实现有序集合？引入如果数据存储在链表中，真的没法用二分查找算法了吗？ 跳表是一种各方面性能都比较优秀的动态数据结构，支持快速地插入、删除、查找操作 如何理解跳表 跳表 = 链表 + 多级索引用跳表查询到底有多快？graph TD 链表n个结点 ...","link":"","photos":[],"count_time":{"symbolsCount":683,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DSA2 如何抓住重点","uid":"5baaeff214933c2b700d2810a6a1c372","slug":"DSA/C2 如何抓住重点","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:18:16.000Z","comments":true,"path":"api/articles/DSA/C2 如何抓住重点.json","keywords":null,"cover":[],"text":"如何抓住重点，系统高效地学习数据结构与算法？什么是数据结构？什么是算法？广义 数据结构：一组数据的存储结构 算法：操作数据的一组方法 狭义 著名的数据结构和算法 数据结构与算法的关系 数据结构为算法服务 算法作用于特定的数据结构 需要的基础 数学基础 编程基础 学习重点 复杂度分...","link":"","photos":[],"count_time":{"symbolsCount":378,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}