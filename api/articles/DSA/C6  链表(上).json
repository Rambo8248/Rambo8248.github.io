{"title":"DSA6 Linked List1","uid":"85ae2c10dc6f2d0c388a295260d12e29","slug":"DSA/C6  链表(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:19:23.070Z","comments":true,"path":"api/articles/DSA/C6  链表(上).json","keywords":null,"cover":[],"content":"<h1 id=\"链表（上）：如何实现LRU缓存淘汰算法？\"><a href=\"#链表（上）：如何实现LRU缓存淘汰算法？\" class=\"headerlink\" title=\"链表（上）：如何实现LRU缓存淘汰算法？\"></a>链表（上）：如何实现LRU缓存淘汰算法？</h1><h2 id=\"缓存淘汰概述\"><a href=\"#缓存淘汰概述\" class=\"headerlink\" title=\"缓存淘汰概述\"></a>缓存淘汰概述</h2><p>缓存</p>\n<ul>\n<li>提高数据读取性能的技术</li>\n<li>大小有限，缓存被用满时，数据清理和保留 —&gt; 缓存淘汰策略<ul>\n<li>FIFO，先进先出策略</li>\n<li>LFU，最少使用策略</li>\n<li>LRU，最近最少使用策略</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"链表结构\"><a href=\"#链表结构\" class=\"headerlink\" title=\"链表结构\"></a>链表结构</h2><h3 id=\"与数组的对比\"><a href=\"#与数组的对比\" class=\"headerlink\" title=\"与数组的对比\"></a>与数组的对比</h3><ul>\n<li>数组<ul>\n<li>连续的内存空间存储，对内存的要求比较高</li>\n</ul>\n</li>\n<li>链表<ul>\n<li>通过“指针”将一组零散的内存块串联起来使用</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg\" alt=\"img\"></p>\n<h3 id=\"几种结构\"><a href=\"#几种结构\" class=\"headerlink\" title=\"几种结构\"></a>几种结构</h3><ul>\n<li>单链表<ul>\n<li><img src=\"https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n<li>双链表<ul>\n<li><img src=\"https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n<li>循环链表<ul>\n<li>单向<img src=\"https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg\" alt=\"img\"></li>\n<li>双向<img src=\"https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>链表结构</th>\n<th>特点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>单链表</td>\n<td>结点=数据+后继指针</td>\n<td>1.插入和删除数据非常快速<br />2.想要随机访问第k个元素需要逐个结点遍历</td>\n</tr>\n<tr>\n<td>双链表</td>\n<td>尾结点指针指向链表头结点</td>\n<td>从链尾到链头比较方便，要处理的数据具有环形结构</td>\n</tr>\n<tr>\n<td>循环链表</td>\n<td>后继指针next+前驱指针prev</td>\n<td>1.额外两个空间<br />2.支持双向遍历 —&gt; $O(1)$时间复杂度情况下找到前驱结点</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"删除操作中的对比\"><a href=\"#删除操作中的对比\" class=\"headerlink\" title=\"删除操作中的对比\"></a>删除操作中的对比</h4><p><img src=\"https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg\" alt=\"img\"></p>\n<p>删除的情况</p>\n<ul>\n<li>删除结点中“值等于某个给定值”的结点</li>\n<li>删除给定指针指向的结点</li>\n</ul>\n<p>链表情况</p>\n<ul>\n<li>第一种情况，单链表和双链表，为了查找到值等于给定值的结点，都需要从头结点开始逐个遍历</li>\n<li>第二种情况<ul>\n<li>单链表：需要找到前驱结点</li>\n<li>双链表：保存前驱结点指针，不需要逐个遍历</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"空间-时间辩证关系\"><a href=\"#空间-时间辩证关系\" class=\"headerlink\" title=\"空间-时间辩证关系\"></a>空间-时间辩证关系</h2><ul>\n<li>空间换时间：内存空间充足，更加追求代码执行速度</li>\n<li>时间换空间：内存比较紧缺</li>\n</ul>\n<h2 id=\"链表vs数组性能比拼\"><a href=\"#链表vs数组性能比拼\" class=\"headerlink\" title=\"链表vs数组性能比拼\"></a>链表vs数组性能比拼</h2><p><img src=\"https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg\" alt=\"img\"></p>\n<h2 id=\"解答开篇\"><a href=\"#解答开篇\" class=\"headerlink\" title=\"解答开篇\"></a>解答开篇</h2><p>如何基于链表实现LRU缓存淘汰算法？</p>\n<p>维护一个有序单链表，越靠近链表尾部结点是越早之前访问的，当有一个新的数据被访问时，从链表头开始顺序遍历链表</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gtuaugttq5j60mw08zt9e02.jpg\" alt=\"image-20210724173623972\"></p>\n<pre class=\"mermaid\">graph TD\n维护一个有序单链表 -->数据已被缓存在链表中 --> 遍历得到数据对应结点.从原来位置删除.插入到链表头部\n维护一个有序单链表 -->数据未被缓存在链表中 -->缓存未满 -->将此结点直接插入到链表头部\n数据未被缓存在链表中 -->缓存已满 --> 链表尾结点删除.将新的数据结点插入链表头部</pre>\n\n","text":"链表（上）：如何实现LRU缓存淘汰算法？缓存淘汰概述缓存 提高数据读取性能的技术 大小有限，缓存被用满时，数据清理和保留 —&gt; 缓存淘汰策略 FIFO，先进先出策略 LFU，最少使用策略 LRU，最近最少使用策略 链表结构与数组的对比 数组 连续的内存空间存储，对内存的要求...","link":"","photos":[],"count_time":{"symbolsCount":837,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">链表（上）：如何实现LRU缓存淘汰算法？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">缓存淘汰概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">链表结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">与数组的对比</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%A0%E7%A7%8D%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">几种结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">对比</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">删除操作中的对比</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E9%97%B4-%E6%97%B6%E9%97%B4%E8%BE%A9%E8%AF%81%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">空间-时间辩证关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8vs%E6%95%B0%E7%BB%84%E6%80%A7%E8%83%BD%E6%AF%94%E6%8B%BC\"><span class=\"toc-text\">链表vs数组性能比拼</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E7%AD%94%E5%BC%80%E7%AF%87\"><span class=\"toc-text\">解答开篇</span></a></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DSA9 Quene","uid":"d631f4f7e4cb3f5655d7dbbeb5a6587c","slug":"DSA/C9 队列","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:09.920Z","comments":true,"path":"api/articles/DSA/C9 队列.json","keywords":null,"cover":[],"text":"队列：队列在线程池等有限资源中的应用问题引入当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？ 如何理解“队列”？ 先进先出 入队enqueue() 出队dequeue() ...","link":"","photos":[],"count_time":{"symbolsCount":195,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}