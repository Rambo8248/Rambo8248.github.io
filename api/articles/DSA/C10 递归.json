{"title":"DSA10 Recursion","uid":"cfd5571b43938e7edf361ab5277ffd65","slug":"DSA/C10 递归","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:22.000Z","comments":true,"path":"api/articles/DSA/C10 递归.json","keywords":null,"cover":[],"content":"<h1 id=\"递归：如何用三行代码找到“最终推荐人”？\"><a href=\"#递归：如何用三行代码找到“最终推荐人”？\" class=\"headerlink\" title=\"递归：如何用三行代码找到“最终推荐人”？\"></a>递归：如何用三行代码找到“最终推荐人”？</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p><img src=\"https://static001.geekbang.org/resource/image/29/0e/2984d45578440e9a348144c70d124a0e.jpg\" alt=\"img\"></p>\n<h2 id=\"如何理解“递归”？\"><a href=\"#如何理解“递归”？\" class=\"headerlink\" title=\"如何理解“递归”？\"></a>如何理解“递归”？</h2><p>递归应用广泛</p>\n<ul>\n<li>DFS深度优先搜索</li>\n<li>前中后序二叉树遍历</li>\n</ul>\n<p>满足的三个条件</p>\n<ul>\n<li>一个问题的解可以分解为几个子问题的解</li>\n<li>问题与分解后的子问题，除了数据规模不同，求解思路完全一样</li>\n<li>存在递归终止条件</li>\n</ul>\n<h2 id=\"如何编写递归代码？\"><a href=\"#如何编写递归代码？\" class=\"headerlink\" title=\"如何编写递归代码？\"></a>如何编写递归代码？</h2><p>写出递推公式、找到终止条件</p>\n<p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</p>\n<p>注意：</p>\n<ul>\n<li>分解为多个子问题，递归代码没那么好理解</li>\n<li>我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，再一层一层返回，很容易被绕进去</li>\n<li>正确的思维方式<ul>\n<li>如果一个问题 A 可以分解为若干子问题 B、C、D</li>\n<li>可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A</li>\n<li>只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系</li>\n<li>屏蔽掉递归细节，这样子理解起来就简单多了</li>\n</ul>\n</li>\n</ul>\n<p>只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</p>\n<h2 id=\"递归代码要警惕堆栈溢出\"><a href=\"#递归代码要警惕堆栈溢出\" class=\"headerlink\" title=\"递归代码要警惕堆栈溢出\"></a>递归代码要警惕堆栈溢出</h2><h3 id=\"问题由来\"><a href=\"#问题由来\" class=\"headerlink\" title=\"问题由来\"></a>问题由来</h3><pre class=\"mermaid\">graph TD\n函数调用会使用栈来保存临时变量 --> 调用函数.临时变量封装为函数调用会使用栈来保存临时变量\n--> 函数执行完成返回.出栈-->递归求解数据规模很大.调用层次很深.一直入栈 -->堆栈溢出</pre>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gtuavg4vm0j60eq0d5t9g02.jpg\" alt=\"image-20210728193815392\"></p>\n<h3 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h3><ul>\n<li>限制递归调用最大深度</li>\n<li>避免重复计算<ul>\n<li>通过一个数据结构来保存已经求解过的$f(k)$</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">// 全局变量，表示递归的深度。</span>\n<span class=\"token keyword\">int</span> depth <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token operator\">++</span>depth；\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>depth <span class=\"token operator\">></span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> throw exception<span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://static001.geekbang.org/resource/image/e7/bf/e7e778994e90265344f6ac9da39e01bf.jpg\" alt=\"img\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token comment\">// hasSolvedList可以理解成一个Map，key是n，value是f(n)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hasSolvedList<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> hasSolvedList<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n  \n  <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  hasSolvedList<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"怎样将递归代码改写为非递归代码\"><a href=\"#怎样将递归代码改写为非递归代码\" class=\"headerlink\" title=\"怎样将递归代码改写为非递归代码\"></a>怎样将递归代码改写为非递归代码</h2><h3 id=\"递归代码优缺点\"><a href=\"#递归代码优缺点\" class=\"headerlink\" title=\"递归代码优缺点\"></a>递归代码优缺点</h3><ul>\n<li>优点<ul>\n<li>表达力强、写起来简洁</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>空间复杂度高</li>\n<li>堆栈溢出风险</li>\n<li>存在重复计算</li>\n<li>过多函数调用耗时较多</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><script type=\"math/tex; mode=display\">\nf(x) = f(x-1)+1</script><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    ret <span class=\"token operator\">=</span> ret <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"是不是所有递归代码都可以改为迭代循环的非递归写法？\"><a href=\"#是不是所有递归代码都可以改为迭代循环的非递归写法？\" class=\"headerlink\" title=\"是不是所有递归代码都可以改为迭代循环的非递归写法？\"></a>是不是所有递归代码都可以改为迭代循环的非递归写法？</h3><ul>\n<li>笼统讲，是的<ul>\n<li>递归本身借助栈来实现，只不过使用的栈是系统或者虚拟机本身提供</li>\n<li>如果自己在内存堆上实现栈，手动模拟入栈、出栈，任何递归代码都可以改写成看上去不是递归代码的样子</li>\n</ul>\n</li>\n<li>但是实际上将递归改为了“手动”递归，本质没有变，也没有解决问题，徒增复杂度</li>\n</ul>\n<h2 id=\"解答开篇\"><a href=\"#解答开篇\" class=\"headerlink\" title=\"解答开篇\"></a>解答开篇</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">long</span> <span class=\"token function\">findRootReferrerId</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> actorId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  Long referrerId <span class=\"token operator\">=</span> select referrer_id from <span class=\"token punctuation\">[</span>table<span class=\"token punctuation\">]</span> where actor_id <span class=\"token operator\">=</span> actorId<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>referrerId <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> actorId<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">findRootReferrerId</span><span class=\"token punctuation\">(</span>referrerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>存在的问题</p>\n<ul>\n<li>递归很深→堆栈溢出</li>\n<li>数据库存在脏数据→无限递归问题</li>\n</ul>\n","text":"递归：如何用三行代码找到“最终推荐人”？引入 如何理解“递归”？递归应用广泛 DFS深度优先搜索 前中后序二叉树遍历 满足的三个条件 一个问题的解可以分解为几个子问题的解 问题与分解后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 如何编写递归代码？写出递推公式、...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%BE%E5%88%B0%E2%80%9C%E6%9C%80%E7%BB%88%E6%8E%A8%E8%8D%90%E4%BA%BA%E2%80%9D%EF%BC%9F\"><span class=\"toc-text\">递归：如何用三行代码找到“最终推荐人”？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">引入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%9C%E9%80%92%E5%BD%92%E2%80%9D%EF%BC%9F\"><span class=\"toc-text\">如何理解“递归”？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%80%92%E5%BD%92%E4%BB%A3%E7%A0%81%EF%BC%9F\"><span class=\"toc-text\">如何编写递归代码？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92%E4%BB%A3%E7%A0%81%E8%A6%81%E8%AD%A6%E6%83%95%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">递归代码要警惕堆栈溢出</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E7%94%B1%E6%9D%A5\"><span class=\"toc-text\">问题由来</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D\"><span class=\"toc-text\">如何避免</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%8E%E6%A0%B7%E5%B0%86%E9%80%92%E5%BD%92%E4%BB%A3%E7%A0%81%E6%94%B9%E5%86%99%E4%B8%BA%E9%9D%9E%E9%80%92%E5%BD%92%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">怎样将递归代码改写为非递归代码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92%E4%BB%A3%E7%A0%81%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">递归代码优缺点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BE%E4%BE%8B\"><span class=\"toc-text\">举例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E9%80%92%E5%BD%92%E4%BB%A3%E7%A0%81%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%94%B9%E4%B8%BA%E8%BF%AD%E4%BB%A3%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">是不是所有递归代码都可以改为迭代循环的非递归写法？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E7%AD%94%E5%BC%80%E7%AF%87\"><span class=\"toc-text\">解答开篇</span></a></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DSA1 Why DSA?","uid":"971ce7cf635f389a131d803d3ca3c395","slug":"DSA/C1  WHY DSA","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:18:01.000Z","comments":true,"path":"api/articles/DSA/C1  WHY DSA.json","keywords":null,"cover":null,"text":"为什么要学习数据结构和算法 大厂面试 业务开发工程师 不需要自己实现，不代表不需要了解 评估代码的性能和资源的消耗 基础框架中糅合了基础数据结构和算法的设计思想 基础架构研发工程师 不被淘汰 ","link":"","photos":[],"count_time":{"symbolsCount":99,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DSA11 Sort1","uid":"dc2049cb2b924724d0d9c0e20e1cbe8f","slug":"DSA/C11 排序(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:32.000Z","comments":true,"path":"api/articles/DSA/C11 排序(上).json","keywords":null,"cover":[],"text":"排序（上）：为什么插入排序比冒泡排序更受欢迎？概述 如何分析一个排序算法？ 执行效率 最好、最坏、平均情况时间复杂度 时间复杂度的系数、常数、低阶 比较次数和交换次数 内存消耗 原地排序特指空间复杂度是$O(1)$的排序算法 稳定性 如果待排序的序列中存在值相等的元素，经过排序之...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}