{"title":"DSA19 Hash Table2","uid":"81c6479ab642eb7be2481f941202d8fb","slug":"DSA/C19 散列表(中)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:22:58.442Z","comments":true,"path":"api/articles/DSA/C19 散列表(中).json","keywords":null,"cover":[],"content":"<h1 id=\"散列表（中）：如何打造一个工业级水平的散列表？\"><a href=\"#散列表（中）：如何打造一个工业级水平的散列表？\" class=\"headerlink\" title=\"散列表（中）：如何打造一个工业级水平的散列表？\"></a>散列表（中）：如何打造一个工业级水平的散列表？</h1><p>如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？</p>\n<h2 id=\"如何设计散列函数\"><a href=\"#如何设计散列函数\" class=\"headerlink\" title=\"如何设计散列函数\"></a>如何设计散列函数</h2><p>好的散列函数要求</p>\n<ul>\n<li>设计不能太复杂<ul>\n<li>过于复杂散列函数，消耗很多计算时间</li>\n</ul>\n</li>\n<li>散列函数生成的值要尽可能随机且均匀分布<ul>\n<li>避免或者最小化散列冲突</li>\n<li>即使冲突，散列到每个槽里的数据也会比较平均</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"装载因子过大怎么办\"><a href=\"#装载因子过大怎么办\" class=\"headerlink\" title=\"装载因子过大怎么办\"></a>装载因子过大怎么办</h2><ul>\n<li>静态数据集合<ul>\n<li>没有频繁插入和删除</li>\n<li>容易根据数据特点、分布，设计完美、极少冲突的散列函数</li>\n</ul>\n</li>\n<li>动态散列表<ul>\n<li>数据频繁变动，事先无法预估将要加入的数据个数</li>\n<li>无法事前申请一个足够大的散列表</li>\n<li>数据慢慢加入，装填因子变大，大到一定程度，散列冲突不可接受</li>\n</ul>\n</li>\n</ul>\n<p>解决方法：动态扩容</p>\n<ul>\n<li>重新申请一个更大的散列表，将数据搬移到这个新散列表中</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/67/43/67d12e07a7d673a9c1d14354ad029443.jpg\" alt=\"img\"></p>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">graph TD\n插入数据 --&gt;最好情况 --&gt;不需扩容\n插入数据 --&gt; 最坏情况 --&gt; 装载因子过高 --&gt;启动扩容 --&gt;重新申请内存空间 --&gt;重新计算哈希位置 --&gt;搬移数据<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gtuaxa4w6gj60bi0i7wf002.jpg\" alt=\"image-20210729154414302\"></p>\n<h2 id=\"如何避免低效的扩容\"><a href=\"#如何避免低效的扩容\" class=\"headerlink\" title=\"如何避免低效的扩容\"></a>如何避免低效的扩容</h2><p>为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/6d/cb/6d6736f986ec4b75dabc5472965fb9cb.jpg\" alt=\"img\"></p>\n<p>这期间的查询操作如何来做？</p>\n<p>答：先从新散列表中查找，如果没有找到，再去老散列表中查找</p>\n<h2 id=\"如何选择冲突解决办法\"><a href=\"#如何选择冲突解决办法\" class=\"headerlink\" title=\"如何选择冲突解决办法\"></a>如何选择冲突解决办法</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>开放寻址法</th>\n<th>链表法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>优点</td>\n<td>散列表中数据都存储在数组中，可以有效地利用CPU缓存加快查询速度<br />序列化起来比较简单</td>\n<td>对内存的利用率比开放寻址法要高<br />对大装载因子的容忍度更高</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据<br />所有数据都存储在一个数组中，比起链表法来说，冲突代价更高</td>\n<td>对比较小的对象存储，比较消耗内存<br />结点零散分布，不连续，对CPU缓存不友好</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>数据量比较小<br />装载因子小</td>\n<td>存储大对象、大数据量的散列表</td>\n</tr>\n</tbody></table>\n<p>对链表法的改造</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/10/29/103b84d7173277c5565607b413c40129.jpg\" alt=\"img\"></p>\n<h2 id=\"工业级散列表举例分析\"><a href=\"#工业级散列表举例分析\" class=\"headerlink\" title=\"工业级散列表举例分析\"></a>工业级散列表举例分析</h2><p><code>Java Hash Map</code></p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>设计</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>初始大小</td>\n<td>16</td>\n</tr>\n<tr>\n<td>装载因子和动态扩容</td>\n<td>最大装载因子默认为0.75，扩容为原来两倍大小</td>\n</tr>\n<tr>\n<td>散列冲突解决方法</td>\n<td>底层采用链表法<br />JDK1.8版本中，当链表长度太长(默认超过8时)，链表就转换为红黑树<br />红黑树结点少于8个时，将红黑树转化为链表</td>\n</tr>\n<tr>\n<td>散列函数</td>\n<td><code>hash(object key)</code> <code>hashCode()</code></td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> h <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>；\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>capicity <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//capicity表示散列表的大小</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">int</span> var1 <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>hash<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>var1 <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> var2 <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> var3 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> var3 <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>var3<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      var1 <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token operator\">*</span> var1 <span class=\"token operator\">+</span> var2<span class=\"token punctuation\">[</span>var3<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>hash <span class=\"token operator\">=</span> var1<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">return</span> var1<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"解答开篇\"><a href=\"#解答开篇\" class=\"headerlink\" title=\"解答开篇\"></a>解答开篇</h2><p>工业级散列表特性</p>\n<ul>\n<li>支持快速查询、插入、删除操作</li>\n<li>内存占用合理，不能浪费过多内存空间</li>\n<li>性能稳定，极端情况下也不会退化到无法接受的情况</li>\n</ul>\n<p>如何实现</p>\n<ul>\n<li>合适散列函数</li>\n<li>定义装载因子阈值，设计动态扩容策略</li>\n<li>合适散列冲突解决方法</li>\n</ul>\n","text":"散列表（中）：如何打造一个工业级水平的散列表？如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？ 如何设计散列函数好的散列函数要求 设计不能太复杂 过于复杂散列函数，消耗很多计算时间 散列函数生成的值要尽可能随...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%B8%9A%E7%BA%A7%E6%B0%B4%E5%B9%B3%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%9F\"><span class=\"toc-text\">散列表（中）：如何打造一个工业级水平的散列表？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">如何设计散列函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A3%85%E8%BD%BD%E5%9B%A0%E5%AD%90%E8%BF%87%E5%A4%A7%E6%80%8E%E4%B9%88%E5%8A%9E\"><span class=\"toc-text\">装载因子过大怎么办</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%BD%8E%E6%95%88%E7%9A%84%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">如何避免低效的扩容</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">如何选择冲突解决办法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%B8%9A%E7%BA%A7%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%BE%E4%BE%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">工业级散列表举例分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E7%AD%94%E5%BC%80%E7%AF%87\"><span class=\"toc-text\">解答开篇</span></a></li></ol></li></ol>","author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DSA18 Hash Table1","uid":"f2a6a2cecbbac22b23528956a3dabf70","slug":"DSA/C18 散列表(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:22:42.811Z","comments":true,"path":"api/articles/DSA/C18 散列表(上).json","keywords":null,"cover":[],"text":"散列表（上）：Word文档中的单词拼写检查功能是如何实现的？引入Word拼写检查功能 散列思想Hash Table 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表 经典例子 参赛选手的编号：ke...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DSA2 如何抓住重点","uid":"5baaeff214933c2b700d2810a6a1c372","slug":"DSA/C2 如何抓住重点","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:18:16.933Z","comments":true,"path":"api/articles/DSA/C2 如何抓住重点.json","keywords":null,"cover":[],"text":"如何抓住重点，系统高效地学习数据结构与算法？什么是数据结构？什么是算法？广义 数据结构：一组数据的存储结构 算法：操作数据的一组方法 狭义 著名的数据结构和算法 数据结构与算法的关系 数据结构为算法服务 算法作用于特定的数据结构 需要的基础 数学基础 编程基础 学习重点 复杂度分...","link":"","photos":[],"count_time":{"symbolsCount":378,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}