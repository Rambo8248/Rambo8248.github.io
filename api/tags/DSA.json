{"name":"DSA","slug":"DSA","count":41,"postlist":[{"title":"DSA0 开篇词","uid":"cdf1a7f1db00ebb74a977ba17a93dbe1","slug":"DSA/C0开篇词","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:17:45.000Z","comments":true,"path":"api/articles/DSA/C0开篇词.json","keywords":null,"cover":null,"text":"跨过“数据结构与算法”技术人所需修炼的“内功” 操作系统 计算机网络 编译原理 数据结构与算法 …… 专栏内容设计 众多数据结构和算法中，选取最实用的内容讲解 数据结构和算法中背后的设计思想 结合真实软件开发案例 模块 入门 时间、空间复杂度 大O表示法由来 复杂度分析技巧 最好...","link":"","photos":[],"count_time":{"symbolsCount":238,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA1 Why DSA?","uid":"971ce7cf635f389a131d803d3ca3c395","slug":"DSA/C1  WHY DSA","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:18:01.000Z","comments":true,"path":"api/articles/DSA/C1  WHY DSA.json","keywords":null,"cover":null,"text":"为什么要学习数据结构和算法 大厂面试 业务开发工程师 不需要自己实现，不代表不需要了解 评估代码的性能和资源的消耗 基础框架中糅合了基础数据结构和算法的设计思想 基础架构研发工程师 不被淘汰 ","link":"","photos":[],"count_time":{"symbolsCount":99,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA10 Recursion","uid":"cfd5571b43938e7edf361ab5277ffd65","slug":"DSA/C10 递归","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:22.000Z","comments":true,"path":"api/articles/DSA/C10 递归.json","keywords":null,"cover":[],"text":"递归：如何用三行代码找到“最终推荐人”？引入 如何理解“递归”？递归应用广泛 DFS深度优先搜索 前中后序二叉树遍历 满足的三个条件 一个问题的解可以分解为几个子问题的解 问题与分解后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 如何编写递归代码？写出递推公式、...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA11 Sort1","uid":"dc2049cb2b924724d0d9c0e20e1cbe8f","slug":"DSA/C11 排序(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:32.000Z","comments":true,"path":"api/articles/DSA/C11 排序(上).json","keywords":null,"cover":[],"text":"排序（上）：为什么插入排序比冒泡排序更受欢迎？概述 如何分析一个排序算法？ 执行效率 最好、最坏、平均情况时间复杂度 时间复杂度的系数、常数、低阶 比较次数和交换次数 内存消耗 原地排序特指空间复杂度是$O(1)$的排序算法 稳定性 如果待排序的序列中存在值相等的元素，经过排序之...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA12 Sort2","uid":"9be35293ffa6798064be3bddd6f599aa","slug":"DSA/C12 排序(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:45.000Z","comments":true,"path":"api/articles/DSA/C12 排序(下).json","keywords":null,"cover":[],"text":"排序（下）：如何用快排思想在$O(n)$​内查找第K大元素？引入两种时间复杂度为$O(nlogn)$的排序算法 归并排序 快速排序 归并排序（Merge sort）原理及实现 数组从中间分成前后两部分 对前后两部分分别排序 再将排好序的两部分合并在一起 递推公式： merge_s...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA13 Sort3","uid":"f0bf7281fb0e82f54bc8de918f6f9204","slug":"DSA/C13 线性排序","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:57.000Z","comments":true,"path":"api/articles/DSA/C13 线性排序.json","keywords":null,"cover":[],"text":"线性排序：如何根据年龄给100万用户数据排序？引入三种时间复杂度为$O(n)$的排序算法 桶排序 计数排序 基数排序 非基于比较的排序算法→时间复杂度为线性 桶排序（Bucket sort） 计数排序（counting sort） 桶排序的特殊情况 所处范围不大，最大值为k，划分...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA14 Sort4","uid":"bb3030af5d71baf7746e61c6c316baf8","slug":"DSA/C14 排序优化","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:21:05.000Z","comments":true,"path":"api/articles/DSA/C14 排序优化.json","keywords":null,"cover":[],"text":"排序优化：如何实现一个通用的、高性能的排序函数？如何选择合适的排序算法 线性排序场景特殊，不选用 为了兼顾任意规模，首选时间复杂度为$O(nlogn)$ 归并排序空间复杂度可能较高 故选择快速排序 如何优化快速排序理想分区点：被分区点分开的两个分区中，数据的数量差不多 三数取中法...","link":"","photos":[],"count_time":{"symbolsCount":149,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA15 Binary Search1","uid":"4fbc272395db721664d9df9e591dbece","slug":"DSA/C15 二分查找(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:21:16.000Z","comments":true,"path":"api/articles/DSA/C15 二分查找(上).json","keywords":null,"cover":[],"text":"二分查找（上）：如何用最省内存的方式实现快速查找功能？无处不在的二分思想 二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0 O(logn)惊人的查找速度 log...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA16 Binary Search2","uid":"4c75cfdca780ea6522270fb11aab65bd","slug":"DSA/C16 二分查找(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:21:28.000Z","comments":true,"path":"api/articles/DSA/C16 二分查找(下).json","keywords":null,"cover":[],"text":"二分查找（下）：如何快速定位IP对应的省份地址？引入 查找第一个值等于给定值的元素 public int bsearch(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; while (low &lt...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA17 Skip List","uid":"0bec27181caef93fd79c11aa3edf5064","slug":"DSA/C17 跳表","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:22:29.000Z","comments":true,"path":"api/articles/DSA/C17 跳表.json","keywords":null,"cover":[],"text":"跳表：为什么Redis一定要用跳表来实现有序集合？引入如果数据存储在链表中，真的没法用二分查找算法了吗？ 跳表是一种各方面性能都比较优秀的动态数据结构，支持快速地插入、删除、查找操作 如何理解跳表 跳表 = 链表 + 多级索引用跳表查询到底有多快？graph TD 链表n个结点 ...","link":"","photos":[],"count_time":{"symbolsCount":683,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA18 Hash Table1","uid":"f2a6a2cecbbac22b23528956a3dabf70","slug":"DSA/C18 散列表(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:22:42.000Z","comments":true,"path":"api/articles/DSA/C18 散列表(上).json","keywords":null,"cover":[],"text":"散列表（上）：Word文档中的单词拼写检查功能是如何实现的？引入Word拼写检查功能 散列思想Hash Table 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表 经典例子 参赛选手的编号：ke...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA2 如何抓住重点","uid":"5baaeff214933c2b700d2810a6a1c372","slug":"DSA/C2 如何抓住重点","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:18:16.000Z","comments":true,"path":"api/articles/DSA/C2 如何抓住重点.json","keywords":null,"cover":[],"text":"如何抓住重点，系统高效地学习数据结构与算法？什么是数据结构？什么是算法？广义 数据结构：一组数据的存储结构 算法：操作数据的一组方法 狭义 著名的数据结构和算法 数据结构与算法的关系 数据结构为算法服务 算法作用于特定的数据结构 需要的基础 数学基础 编程基础 学习重点 复杂度分...","link":"","photos":[],"count_time":{"symbolsCount":378,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA19 Hash Table2","uid":"81c6479ab642eb7be2481f941202d8fb","slug":"DSA/C19 散列表(中)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:22:58.000Z","comments":true,"path":"api/articles/DSA/C19 散列表(中).json","keywords":null,"cover":[],"text":"散列表（中）：如何打造一个工业级水平的散列表？如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？ 如何设计散列函数好的散列函数要求 设计不能太复杂 过于复杂散列函数，消耗很多计算时间 散列函数生成的值要尽可能随...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA20 Hash Table3","uid":"4b485bd537f5fd1e1b5f6120bc5388d2","slug":"DSA/C20 散列表(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:10.000Z","comments":true,"path":"api/articles/DSA/C20 散列表(下).json","keywords":null,"cover":[],"text":"散列表（下）：为什么散列表和链表经常会一起使用？LRU缓存淘汰算法链表实现回顾.assets/image-20210724173623972-1627546113415.png) 一个缓存cache系统包含下面几个操作 添加数据 删除数据 查找数据 如果我们将散列表和链表两种数据...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA21 Hash Algorithm1","uid":"df821ff4999b5ea1cca6788fc47b1fb5","slug":"DSA/C21 哈希算法(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:32.000Z","comments":true,"path":"api/articles/DSA/C21 哈希算法(上).json","keywords":null,"cover":[],"text":"哈希算法（上）：如何防止数据库中的用户信息被脱库？引入 2011CSDN“脱库”事件 在实际开发中，如何用哈希算法解决问题 什么是哈希算法？哈希算法：将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法。而通过原始数据映射之后得到的二进制值串就是哈希值。 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA22 Hash Algorithm2","uid":"a8b428ae06db3a75338b25077c7c9ca3","slug":"DSA/C22 哈希算法(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:40.000Z","comments":true,"path":"api/articles/DSA/C22 哈希算法(下).json","keywords":null,"cover":[],"text":"哈希算法（下）：哈希算法在分布式系统中有哪些应用？哈希算法是如何解决这些分布式问题的 负载均衡负载均衡算法很多，如何才能实现一个会话粘滞的负载均衡算法？即需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上 直接的办法 维护一张映射关系表 弊端 客户端很多，映射表很...","link":"","photos":[],"count_time":{"symbolsCount":970,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA23 Binary Tree1","uid":"56aa12aba5d53418e62bb5c5f6efe64b","slug":"DSA/C23 二叉树基础(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:57.000Z","comments":true,"path":"api/articles/DSA/C23 二叉树基础(上).json","keywords":null,"cover":[],"text":"二叉树基础（上）：什么样的二叉树适合用数组来存储？问题引入 二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？ 树 名词 定义 节点 树中的每个元素 父子关系 用来连接相邻节点之间的关系 父节点 上级节点 子节点 下级节点 兄弟节点 同级节点 叶子节点/叶节点 没有子节点的...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA24 Binary Tree2","uid":"17d7fb60ad31417e734a0509256cfdc1","slug":"DSA/C24 二叉树基础(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:24:08.000Z","comments":true,"path":"api/articles/DSA/C24 二叉树基础(下).json","keywords":null,"cover":[],"text":"二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？二叉查找树的最大特点：支持动态数据集合的快速插入、删除、查找 散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是 O(1)。既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA25 Red-Black Tree1","uid":"d603cea4e398050da6c08bad435d355e","slug":"DSA/C25 红黑树(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:24:34.000Z","comments":true,"path":"api/articles/DSA/C25 红黑树(上).json","keywords":null,"cover":[],"text":"红黑树（上）：为什么工程中都用红黑树这种二叉树？引入 二叉查找树各个操作时间复杂度跟树的高度成正比，理想情况下，时间复杂度是$O(logn)$ 不过二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于$log_2n$的情况，从而导致各个操作的效率下降 为什么工程中都喜欢用红...","link":"","photos":[],"count_time":{"symbolsCount":971,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA27 Recursion Tree","uid":"134dfc72e46d7c11aedb7ca140c26710","slug":"DSA/C27 递归树","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:19.000Z","comments":true,"path":"api/articles/DSA/C27 递归树.json","keywords":null,"cover":[],"text":"递归树：如何借助树来求解递归算法的时间复杂度？递归树与时间复杂度分析 实战1：分析快速排序的时间复杂度假设平均情况下，每次分区后，两个分区的大小比例为1:k，当k=9时，递推公式为： T(n) = T(\\frac{n}{10})+T(\\frac{9n}{10})+n用递归树来分析...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA26 Red-Black Tree2","uid":"7693d3ff77636135d449fe9da08ce394","slug":"DSA/C26 红黑树(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:24:48.000Z","comments":true,"path":"api/articles/DSA/C26 红黑树(下).json","keywords":null,"cover":[],"text":"红黑树（下）：掌握这些技巧，你也可以实现一个红黑树 爱：稳定、高效的性能 恨：实现起来比较难 实现红黑树的基本思想大致过程遇到什么样的节点排布，我们就对应怎么去调整 回顾红黑树的要求 节点类型 颜色 根节点 黑色 叶子节点 黑色的空节点，不存储数据 相邻节点 不能同时为红色 每个...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA29 Heap Application","uid":"3d8241738a6ca807ab996c00fc84c560","slug":"DSA/C29 堆的应用","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:47.000Z","comments":true,"path":"api/articles/DSA/C29 堆的应用.json","keywords":null,"cover":[],"text":"堆的应用：如何快速获取到Top 10最热门的搜索关键词？堆的几个经典应用 优先级队列 求Top K 求中位数 堆的应用一：优先级队列 优先级队列 队列 出队顺序按照优先级来 优先级队列与堆很像 插入元素→堆中插入元素 取出优先级最高的元素→取出堆顶元素 合并有序小文件 问题描述 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA3 Complexity Analysis1","uid":"503921898d741f6fd2003fcfcab3b5d3","slug":"DSA/C3 复杂度分析(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:18:38.000Z","comments":true,"path":"api/articles/DSA/C3 复杂度分析(上).json","keywords":null,"cover":[],"text":"复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？为什么需要复杂度分析？事后统计法的局限 测试结果依赖于测试环境 i9 vs i3 测试结果受数据规模影响大 小规模数据排序，出入排序&gt;快速排序 大O复杂度表示法code1 int cal(int n) &#123; ...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA28 Heap","uid":"1ecdd1e00fb73a51c0511d1921f5b63c","slug":"DSA/C28 堆和堆排序","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:33.000Z","comments":true,"path":"api/articles/DSA/C28 堆和堆排序.json","keywords":null,"cover":[],"text":"堆和堆排序：为什么说堆排序没有快速排序快？特殊的树：堆(Heap) 堆排序 原地 时间复杂度为$O(nlogn)$ 实际软件开发中，快速排序的性能要比堆排序好 如何理解堆？ 完全二叉树 堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值 大顶堆 小顶堆 如何实现一...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA30 Graph","uid":"23870052c199bf06d18a4a93d8161ea8","slug":"DSA/C30 图的表示","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:56.000Z","comments":true,"path":"api/articles/DSA/C30 图的表示.json","keywords":null,"cover":[],"text":"图的表示：如何存储微博、微信等社交网络中的好友关系？如何理解图？ 名词 定义 顶点vertex 图中的元素 边edge 图中顶点与任意其他顶点建立的关系 度degree 跟顶点相连接的边的条数 有向图 边有方向的图 无向图 边无方向的图 带权图 每条边都有一个权重 入度 in-d...","link":"","photos":[],"count_time":{"symbolsCount":597,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA31 DFS&BFS","uid":"7e4c0f4e2f510c4e8317f9775d710031","slug":"DSA/C31 深度和广度优先搜索","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:26:07.000Z","comments":true,"path":"api/articles/DSA/C31 深度和广度优先搜索.json","keywords":null,"cover":[],"text":"深度和广度优先搜索：如何找出社交网络中的三度好友关系？什么是搜索算法？ DFS，Depth-First-Search，深度优先搜索 BFS，Breadth-First-Search，广度优先搜索 都是基于图结构的。在图中找出从一个顶点出发，到另一个顶点的路径 图的代码实现publ...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA32 String Match1","uid":"2786242c5ba6ce0832bbacd81c75d253","slug":"DSA/C32 字符串匹配基础(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:26:22.000Z","comments":true,"path":"api/articles/DSA/C32 字符串匹配基础(上).json","keywords":null,"cover":[],"text":"字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？字符串匹配 算法 单模式串匹配的算法：一个串跟一个串进行匹配 BF算法 RK算法 多模式串匹配的算法：在一个串中同时查找多个串 BM算法 KMP算法 BF算法Brute Force，暴力匹配算法，朴素匹配算法 在字符串A中...","link":"","photos":[],"count_time":{"symbolsCount":748,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA33 String Match2","uid":"0ec81c6d3aa8372bc4bd0a74846f2430","slug":"DSA/C33 字符串匹配基础(中)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:26:35.000Z","comments":true,"path":"api/articles/DSA/C33 字符串匹配基础(中).json","keywords":null,"cover":[],"text":"字符串匹配基础（中）：如何实现文本编辑器中的查找功能？文本编辑器中的查找替换功能 BM算法，Boyer-Moore KMP算法 BM算法核心思想 当模式串和主串某个字符不匹配的时候，能够跳过一些可定不会匹配的情况，将模式串往后多滑动几位 算法原理分析坏字符规则 graph TD ...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA35 Trie Tree","uid":"6ac917baf75da522e92f8103dc9fe5ea","slug":"DSA/C35 Trie树","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:00.000Z","comments":true,"path":"api/articles/DSA/C35 Trie树.json","keywords":null,"cover":[],"text":"Trie树：如何实现搜索引擎的搜索关键词提示功能？搜索引擎的搜索关键词提示功能 什么是Trie树？ 字典树，树形结构 专门处理字符串匹配的数据结构 解决在一组字符串集合中快速查找某个字符串的问题 先看看Trie树长什么样 本质：利用字符串之间公共前缀，将重复前缀合并在一起 6个字...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA34 String Match3","uid":"9ae95ab2c9e432ffcdddad19b3709cb8","slug":"DSA/C34 字符串匹配基础(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:26:45.000Z","comments":true,"path":"api/articles/DSA/C34 字符串匹配基础(下).json","keywords":null,"cover":[],"text":"字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法？所有字符串匹配算法中，最知名的一种非KMP算法莫属 KMP算法基本原理Knuth-Morris-Pratt 核心思想 模式串与主串匹配过程中，当遇到不可匹配的字符时，希望找到一些规律，将模式串向后多滑动几位，跳过那些肯定不...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA36 AC自动机","uid":"06d10bcf0dacb0e855883f8036c8872c","slug":"DSA/C36 AC自动机","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:16.000Z","comments":true,"path":"api/articles/DSA/C36 AC自动机.json","keywords":null,"cover":[],"text":"AC自动机：如何用多模式串匹配实现敏感词过滤功能？引入敏感词过滤功能是如何实现的？ 字符串匹配算法 通过维护一个敏感词的字典，当用户输入一段文字内容之后，通过字符串匹配算法查找用户输入的文字，包含敏感词则用“*”替换掉 访问量巨大的网站来说，如何实现一个高性能的敏感词过滤系统？ ...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA37 Greedy Algorithm","uid":"a9e32e2621fbdc03b2a42efbcf0ce8e5","slug":"DSA/C37 贪心算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:30.000Z","comments":true,"path":"api/articles/DSA/C37 贪心算法.json","keywords":null,"cover":[],"text":"贪心算法：如何用贪心算法实现Huffman压缩编码？几个基本的算法思想 贪心算法 Huffman Coding Prim和Kruskal最小生成树算法 Dijkstra单源最短路径 分治算法 回溯算法 动态规划 本章如何利用贪心算法实现对数据压缩编码，有效节省数据存储空间 如何理...","link":"","photos":[],"count_time":{"symbolsCount":678,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA38 分治算法","uid":"28170d54ceec31fbbfec4bc7706417d1","slug":"DSA/C38 分治算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:48.000Z","comments":true,"path":"api/articles/DSA/C38 分治算法.json","keywords":null,"cover":[],"text":"分治算法：谈一谈大规模计算框架MapReduce中的分治思想引入Google大数据处理三驾马车 MapReduce GFS Bigtable 如何理解分治算法核心：分而治之 将原问题划分成n个规模较小，并且结构与原问题相似的子问题 递归地解决这些子问题 然后合并其结果 分治算法的...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA40 回溯算法","uid":"cab4c9495dd444030efce39574aea74e","slug":"DSA/C39 回溯算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:28:02.000Z","comments":true,"path":"api/articles/DSA/C39 回溯算法.json","keywords":null,"cover":[],"text":"回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想引入回溯算法的应用 深度优先搜索 经典数学问题 数独 八皇后 0-1背包 图的着色 旅行商问题 全排列 如何理解回溯算法笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA4 Complexity Analysis2","uid":"fc19127153caeb9baa595a1d01d3f0d7","slug":"DSA/C4 复杂度分析(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:18:54.000Z","comments":true,"path":"api/articles/DSA/C4 复杂度分析(下).json","keywords":null,"cover":null,"text":"复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度// n表示数组array的长度 int find(int[] array, int n, int x) &#123; int i = 0; int pos = -1; for (; i &lt; n; ++i) &#123;...","link":"","photos":[],"count_time":{"symbolsCount":906,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA40 初识动态规划","uid":"7315897fe4af98b9a72088541e465f37","slug":"DSA/C40 初识动态规划","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:28:16.000Z","comments":true,"path":"api/articles/DSA/C40 初识动态规划.json","keywords":null,"cover":null,"text":"初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？引入 双十一满200减50，选出来的商品价格总和最大程度接近满减条件，极大限度薅羊毛 动态规划学习路线动态规划比较适合用来求解最优问题，比如求最大值、最小值等 初识动态规划 两个经典动态规划问题模型 为什么动态规划 动态规划解...","link":"","photos":[],"count_time":{"symbolsCount":220,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA5 Array","uid":"be65ef045a392dbdd6233f994cc17ed3","slug":"DSA/C5 数组","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:19:05.000Z","comments":true,"path":"api/articles/DSA/C5 数组.json","keywords":null,"cover":[],"text":"数组：为什么很多编程语言中数组都从0开始编号？如何实现随机访问？ 数组(array) 一种线性表数据结构。用一组连续的内存空间，来存储一组具有相同类型的数据 线性表与非线性表 线性表 数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向 非线性表 数据之间并不是简...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA6 Linked List1","uid":"85ae2c10dc6f2d0c388a295260d12e29","slug":"DSA/C6  链表(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:19:23.000Z","comments":true,"path":"api/articles/DSA/C6  链表(上).json","keywords":null,"cover":[],"text":"链表（上）：如何实现LRU缓存淘汰算法？缓存淘汰概述缓存 提高数据读取性能的技术 大小有限，缓存被用满时，数据清理和保留 —&gt; 缓存淘汰策略 FIFO，先进先出策略 LFU，最少使用策略 LRU，最近最少使用策略 链表结构与数组的对比 数组 连续的内存空间存储，对内存的要求...","link":"","photos":[],"count_time":{"symbolsCount":837,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA7 Linked List2","uid":"4d2b8ed889fbd369f571fec1667609a5","slug":"DSA/C7 链表(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:19:36.000Z","comments":true,"path":"api/articles/DSA/C7 链表(下).json","keywords":null,"cover":[],"text":"链表（下）：如何轻松写出正确的链表代码？几个技巧 理解指针或引用的含义 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量 警惕指针丢失和内存泄漏 情况 代码 p-&gt;next =...","link":"","photos":[],"count_time":{"symbolsCount":310,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA9 Quene","uid":"d631f4f7e4cb3f5655d7dbbeb5a6587c","slug":"DSA/C9 队列","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:09.000Z","comments":true,"path":"api/articles/DSA/C9 队列.json","keywords":null,"cover":[],"text":"队列：队列在线程池等有限资源中的应用问题引入当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？ 如何理解“队列”？ 先进先出 入队enqueue() 出队dequeue() ...","link":"","photos":[],"count_time":{"symbolsCount":195,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA8 Stack","uid":"a75362207a5dc66d40d312cda296e3d4","slug":"DSA/C8 栈","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:19:48.000Z","comments":true,"path":"api/articles/DSA/C8 栈.json","keywords":null,"cover":[],"text":"栈：如何实现浏览器的前进和后退功能如何理解“栈” 后进先出 “操作受限”的线性表 Why 栈？ 数组或链表暴露了太多操作接口，灵活自由但也比较不可控，容易出错 当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。 如何...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}