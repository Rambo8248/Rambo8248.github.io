{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}},"post_list":[{"title":"学习方法随想","uid":"6995ec6ebd5c76b2ee7554a070e80b76","slug":"StudyMethod/学习方法随想","date":"2021-08-29T01:51:53.000Z","updated":"2021-08-29T02:08:44.529Z","comments":true,"path":"api/articles/StudyMethod/学习方法随想.json","keywords":null,"cover":[],"text":"学习方法随想在学习过程中，其实有很多自己的经验。但是很多碎片化的经验并不能够帮助自己更好的了解自身和提升效率。于是在2021-08-29 09:51:53阅读【CSAPP 第4章 处理器体系架构】的一个早晨，我决定把自己的学习方法记录下来，期待能够得到一个系统化的学习思路。 技术...","link":"","photos":[],"count_time":{"symbolsCount":609,"symbolsTime":"1 mins."},"categories":[{"name":"Study Method","slug":"Study-Method","count":1,"path":"api/categories/Study-Method.json"}],"tags":[{"name":"Study Method","slug":"Study-Method","count":1,"path":"api/tags/Study-Method.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"C4 处理器体系结构","uid":"54eea516d81b966dd64e8dfcff34d389","slug":"CSAPP/C4-处理器体系结构","date":"2021-08-29T01:38:53.000Z","updated":"2021-08-31T03:05:54.935Z","comments":true,"path":"api/articles/CSAPP/C4-处理器体系结构.json","keywords":null,"cover":[],"text":"处理器体系结构引入微处理器架构简述 现代微处理器复杂 到目前为止，我们看到的计算机系统只限于机器语言程序级 graph LR 处理器 --执行--> 指令.简单操作 --编码--> 一个或多个字节序列组成的二进制格式 指令集体系结构(ISA)：一个处理器支持的指令和指令的字节级编...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"CSAPP","slug":"CSAPP","count":4,"path":"api/categories/CSAPP.json"}],"tags":[{"name":"CSAPP","slug":"CSAPP","count":4,"path":"api/tags/CSAPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"C3 程序的机器级表示","uid":"56f4d97bcf32df033b2c7f1482475692","slug":"CSAPP/C3-程序的机器级表示","date":"2021-08-26T04:15:53.000Z","updated":"2021-08-28T09:30:05.367Z","comments":true,"path":"api/articles/CSAPP/C3-程序的机器级表示.json","keywords":null,"cover":[],"text":"程序的机器级表示引入 代码类型 定义 机器代码 用字节序列编码低级的操作 包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信 汇编代码 机器代码的文本表示 给出程序中的每一条指令 高级语言编程 机器屏蔽程序的细节，即机器级的实现 抽象级别高，效率高，更可靠 可以在不同...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"CSAPP","slug":"CSAPP","count":4,"path":"api/categories/CSAPP.json"}],"tags":[{"name":"CSAPP","slug":"CSAPP","count":4,"path":"api/tags/CSAPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"C2 信息的表示和处理","uid":"60ed0f7899e93e3dd0dff8a77b279977","slug":"CSAPP/C2-信息的表示和处理","date":"2021-08-26T04:14:27.000Z","updated":"2021-08-29T01:37:35.487Z","comments":true,"path":"api/articles/CSAPP/C2-信息的表示和处理.json","keywords":null,"cover":[],"text":"信息的表示和处理引入二值信号 容易被表示、存储和传输 位的组合加解释(group bits together and apply some interpretation) 能够表示任何有限集合的元素 三种重要数字表示 unsigned：基于传统的二进制表示法，表示大于或者等于0的...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"CSAPP","slug":"CSAPP","count":4,"path":"api/categories/CSAPP.json"}],"tags":[{"name":"CSAPP","slug":"CSAPP","count":4,"path":"api/tags/CSAPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C1_计算机系统漫游","uid":"a7f1ed76601ff92b732ab0f222c2a42f","slug":"CSAPP/C1-计算机系统漫游","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-27T09:00:58.717Z","comments":true,"path":"api/articles/CSAPP/C1-计算机系统漫游.json","keywords":null,"cover":[],"text":"A Tour of Computer Systems 计算机系统漫游主要内容 计算机系统：硬件+软件 内部信息 表示为一组组的位 依据context有不同的解释方式 编译过程被翻译成不同形式 层次结构 复制$\\to$开销 高层次存储设备作为低层次设备的cache 操作系统 文件$...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"CSAPP","slug":"CSAPP","count":4,"path":"api/categories/CSAPP.json"}],"tags":[{"name":"CSAPP","slug":"CSAPP","count":4,"path":"api/tags/CSAPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"B1 多文件编译","uid":"af14c5521b037875d1206060f4590b98","slug":"CPP/B1 多文件编译","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:32:19.899Z","comments":true,"path":"api/articles/CPP/B1 多文件编译.json","keywords":null,"cover":[],"text":"Ubuntu下g++编译多个*.h和*.cpp文件文件介绍 文件 内容 main.cpp 主函数 median.cpp 用于返回一个序列的中位数 median.h median函数声明 grade.cpp 若干个重载的grade函数函数体 grade.h grade函数声明 St...","link":"","photos":[],"count_time":{"symbolsCount":575,"symbolsTime":"1 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"B3 C++菜鸟教程","uid":"fceb7de2def1c17dcd8f404b9c66b25c","slug":"CPP/C++菜鸟教程","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:34:13.566Z","comments":true,"path":"api/articles/CPP/C++菜鸟教程.json","keywords":null,"cover":null,"text":"代码组成结构在 C++ 中，分别使用.h 和.cpp 来定义一个类。 .h 中存放类的声明，函数原型（放在类的声明中）。 .cpp 存放函数体。 也就是说，一个存放声明(declaration)，一个存放定义（definition)。 如果我们在一个头文件里声明了一个函数，当我们...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP1 字符串的使用","uid":"d469c0aa6900bf80ac5103ca8bfe40c5","slug":"CPP/C1 字符串的使用","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:49:22.200Z","comments":true,"path":"api/articles/CPP/C1 字符串的使用.json","keywords":null,"cover":null,"text":"字符串的使用输入#include&lt;iostream> #include&lt;string> int main() &#123; //请某人输入其姓名 std::cout &lt;&lt; \"Plz Enter ur name:\" ; //读姓名 std::string n...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"B2 C++函数调用图生成","uid":"ddabc27d0a61a83349413c6612afe50d","slug":"CPP/B2 C++编译函数调用图生成","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:32:54.642Z","comments":true,"path":"api/articles/CPP/B2 C++编译函数调用图生成.json","keywords":null,"cover":[],"text":"C++函数调用图生成(Ubuntu18.04)https://github.com/jmarkowski/codevizsudo apt-get install graphviz git clone https://github.com/jmarkowski/codeviz.gi...","link":"","photos":[],"count_time":{"symbolsCount":751,"symbolsTime":"1 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP11 定义抽象数据类型","uid":"6f7b722034727aa8d501a289bcdc43b2","slug":"CPP/C11 定义抽象数据类型","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:48:48.962Z","comments":true,"path":"api/articles/CPP/C11 定义抽象数据类型.json","keywords":null,"cover":null,"text":"定义抽象数据类型 创建一个类似于向量的类以加深我们对如何设计和实现一个类的理解 先写一些简单的成员函数，再回来看看如何控制进行复制、赋值以及删除操作 Vec类开始设计类时，通常需要首先确定要在类中提供什么样的接口$\\to$研究类的使用者将用我们所写的类编写什么样的程序，比如说： ...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C00 前言","uid":"86a055ce60f57b41bde29b259c469871","slug":"CPP/C00 前言","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:34:46.120Z","comments":true,"path":"api/articles/CPP/C00 前言.json","keywords":null,"cover":null,"text":"前言全新的C++编程方法 高级数据结构开始$\\to$数据结构所依赖的基础进行解释$\\to$地道C++ 集中注意力解决问题，而非专门探究语言与库的特征 初学者和熟练程序员均可获益 从开始就使用标准库 掌握高效使用各种语言的细节知识后，才对细节深入探讨 抽象 能够忽略细节的能力是成熟...","link":"","photos":[],"count_time":{"symbolsCount":373,"symbolsTime":"1 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP13 继承与动态绑定的使用","uid":"f1fd64304e69297c15b134a3ddae98c2","slug":"CPP/C13 继承与动态绑定的使用","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:48:41.470Z","comments":true,"path":"api/articles/CPP/C13 继承与动态绑定的使用.json","keywords":null,"cover":[],"text":"继承与动态绑定的使用继承成绩问题中，研究生学分成绩的记录与本科生的学分成绩记录基本一致，唯一差别在于研究生学分成绩记录添加了一个与论文相关的属性。对于这种关系来说，最自然的解决办法就是使用继承(inheritance) 定义两个类 一个类集成一些核心的公共操作 另一个类增加了与研...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP2 循环与计数","uid":"0a24b61512170bdfb39d64a4b932bf18","slug":"CPP/C2 循环与计数","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:49:19.523Z","comments":true,"path":"api/articles/CPP/C2 循环与计数.json","keywords":null,"cover":[],"text":"循环与计数本章中进一步增加程序的灵活性，允许我们无需重新编写程序就可以直接改变框架的长度 问题上一节中的输出 存在如下缺陷 每行输出都要与程序的某一部分（以及一个变量）相对应 即使大堆输出格式的一个简单修改，都要求我们重新编写程序 故 构造一个更为灵活的输出形式$\\to$​无需将...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP3 使用批量数据","uid":"3555062c5fedfb27efa69ce78e83937d","slug":"CPP/C3 使用批量数据","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:49:16.985Z","comments":true,"path":"api/articles/CPP/C3 使用批量数据.json","keywords":null,"cover":[],"text":"使用批量数据 通常需要在程序中处理多个相似数据段 编写程序读取学生的考试和家庭作业成绩并计算出总成绩 计算学生成绩 学生课程总成绩为加权平均 第一次尝试的程序如下 #include&lt;iomanip> #include&lt;ios> #include&lt;iostream...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP4 组织程序与数据","uid":"bc5e708322b6829557ee8bb706942cbe","slug":"CPP/C4 组织程序和数据","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:49:14.187Z","comments":true,"path":"api/articles/CPP/C4 组织程序和数据.json","keywords":null,"cover":[],"text":"组织程序和数据库工具特征 能够解决某些特定类型的问题 独立于其他大多数工具 都有一个名称 我们自己编写的程序具备特性中的第一个，不具备另外两个。 对于小程序→不是坏事 更困难的问题→除非将解决方案分割成相互独立的具有名称的各个部分，否则会变得无法控制 C++提供两种基本方法以便让...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C0 开始","uid":"cad1a665aa5f56e359146a1c745e5ca7","slug":"CPP/C0 开始","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:34:31.791Z","comments":true,"path":"api/articles/CPP/C0 开始.json","keywords":null,"cover":[],"text":"开始程序源码//Hello world #include&lt;iostream> int main() &#123; std::cout &lt;&lt; \"Hello,World\" &lt;&lt; std::endl; return 0; &#125; 各部分含义 命令 含...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP10 管理内存与低级数据结构","uid":"f33231007a38d63e975cc1fea425a1a6","slug":"CPP/C10 管理内存与低级数据结构","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:48:51.512Z","comments":true,"path":"api/articles/CPP/C10 管理内存与低级数据结构.json","keywords":null,"cover":[],"text":"管理内存与低级数据结构由于使用标准库无法解决全部问题，因此非常多的C++程序经常使用“低级”技巧 本章 数组和指针 new和delete表达式动态地对内存进行分配 指针与数组 名词 定义 数组 容器的一种，与向量类似，但没有向量功能那么强大 指针 随机存取的迭代器，可用于存取数组...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP5 使用顺序容器和分析字符串","uid":"8634375c41badd07a389bc135cc9590c","slug":"CPP/C5 使用顺序容器和分析字符串","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:49:07.730Z","comments":true,"path":"api/articles/CPP/C5 使用顺序容器和分析字符串.json","keywords":null,"cover":[],"text":"使用顺序容器和分析字符串本章 更深入了解库的使用方法 标准库 提供有用的数据结构和函数 反映一个具有一致性的体系结构 一旦了解了一种容器的行为特性，就可以非常轻松地掌握全部库容器的使用方法 将学生进行分类要求：算出学生成绩之外，区分学生能否通过课程 实现思路： Student_i...","link":"","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP7 使用关联容器","uid":"c6bbdc5859805502fec5f66437416592","slug":"CPP/C7 使用关联容器","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:49:01.416Z","comments":true,"path":"api/articles/CPP/C7 使用关联容器.json","keywords":null,"cover":[],"text":"使用关联容器 顺序容器：给容器元素选择适当顺序后，它们会按照我们所选择的顺序将元素保存起来 关联容器：容器会自动将它们的元素安排在一个序列中 支持高效查找的容器关联容器：自动将它们元素安排在一个序列中，利用这种排序方法让我们可以更快速地对特定元素进行定位—并不需要我们自己保持容器...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP4 组织程序和数据 代码纯享","uid":"fb94724ad6a11796aa7671876e21935b","slug":"CPP/C4 组织程序和数据_精简版","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:49:11.031Z","comments":true,"path":"api/articles/CPP/C4 组织程序和数据_精简版.json","keywords":null,"cover":null,"text":"组织程序和数据C++多文件理解https://zhuanlan.zhihu.com/p/348798266 C++程序一般分三类文件： 头文件( .h )放置各种声明，用于被cpp文件包含 模块文件（.cpp）放置一些函数定义，也称为功能模块 主程序文件（.cpp）包含main(...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP9 定义新类型","uid":"260ea000f421b3eddad461c7e5d42b80","slug":"CPP/C9 定义新类型","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:48:54.644Z","comments":true,"path":"api/articles/CPP/C9 定义新类型.json","keywords":null,"cover":[],"text":"定义新类型可以将C++分成两种 内部类型 -&gt; 被定义成语言核心的一部分 自定义类型(class type) C+设计思想 应该让程序员创建与内部类型一样易于使用的类型 创建具有简明直观的接口的类型 实质性的语言支持 类的设计过程中的体验和判断 Student_info回顾...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP12 使类对象获得数值功能","uid":"32d2985524fbdfade0b6b9e9b6071676","slug":"CPP/C12使类对象获得数值功能","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:48:46.035Z","comments":true,"path":"api/articles/CPP/C12使类对象获得数值功能.json","keywords":null,"cover":null,"text":"使类对象获得数值功能 定义了自己的类之后，就可以控制对类进行的扩展，使其对象可以想数值一样工作 Box3 = Box1 + Box2 类的编写者可以设法让各个对象之间彼此保持独立 上一章我们在写Vec类时已经完成大部分工作 本章大部分讨论如何为Str类设计一个友好的接口 一个简单...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP8 编写泛型函数","uid":"916993f3303db0d9f66253cbc5cc5316","slug":"CPP/C8 编写泛型函数","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:48:58.328Z","comments":true,"path":"api/articles/CPP/C8 编写泛型函数.json","keywords":null,"cover":null,"text":"编写泛型函数本书第一部分：编写程序以便解决某些具体问题 使用c++语言基本要素以及标准库提供的抽象 从这一章开始：学习编写抽象的方法 C8 讨论泛型函数 C9-C12 演示如何实现抽象数据类型 从C13开始：学习面向对象程序设计方法OOP 什么是泛型函数表面上看，我们在编写函数时...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Manim1 Installation","uid":"45e3d46203ca5cc5718cda218b7c4f03","slug":"manim/C1 installation","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:58:07.799Z","comments":true,"path":"api/articles/manim/C1 installation.json","keywords":null,"cover":[],"text":"manim安装(MacOS)相关依赖项的安装https://docs.manim.community/en/stable/installation/mac.html To install cairo: brew install cairo To install ffmpeg: b...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"Manim","slug":"Manim","count":3,"path":"api/categories/Manim.json"}],"tags":[{"name":"Manim","slug":"Manim","count":3,"path":"api/tags/Manim.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CPP6 使用库算法","uid":"626917d17fb14af0007b94f4b30e0461","slug":"CPP/C6 使用库算法","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:49:05.173Z","comments":true,"path":"api/articles/CPP/C6 使用库算法.json","keywords":null,"cover":[],"text":"使用库算法 全部容器都提供了配套的迭代器类型 库保证了全部提供同一个操作的迭代器都通过同样的接口以实现其功能 本章 库如何利用公用接口来提供一个标准算法集合 通过使用这些算法能够避免重复编写同样的代码 字符处理应用1：连接两幅字符图案//方案1 for (vector&lt;st...","link":"","photos":[],"count_time":{"symbolsCount":"8.7k","symbolsTime":"8 mins."},"categories":[{"name":"CPP","slug":"CPP","count":19,"path":"api/categories/CPP.json"}],"tags":[{"name":"CPP","slug":"CPP","count":19,"path":"api/tags/CPP.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Manim3 UsingText","uid":"60bd8fd469f282ac6b13a9d5e27c3f6b","slug":"manim/C3 UsingText","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:59:20.369Z","comments":true,"path":"api/articles/manim/C3 UsingText.json","keywords":null,"cover":[],"text":"使用文本without $LaTeX$​​文本helloworld.py from manim import * class HelloWorld(Scene): def construct(self): text = Text(\"Hello world\").scale(3) s...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"Manim","slug":"Manim","count":3,"path":"api/categories/Manim.json"}],"tags":[{"name":"Manim","slug":"Manim","count":3,"path":"api/tags/Manim.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Manim2 A Deeper Look","uid":"a5157b4321de82dc35f7014351511ed5","slug":"manim/C2 a deeper look","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:59:05.072Z","comments":true,"path":"api/articles/manim/C2 a deeper look.json","keywords":null,"cover":[],"text":"Mainm BlocksManim涉及到的3个基本概念 mobject animation Scene 在mainm中定义了Mobject, Animation, and Scene这几个class Mobjects basic building block for all ma...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"Manim","slug":"Manim","count":3,"path":"api/categories/Manim.json"}],"tags":[{"name":"Manim","slug":"Manim","count":3,"path":"api/tags/Manim.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"NUDT考研经验贴分享","uid":"3d37c1a36f275310395f0cfef8cc99c3","slug":"Exam/考研经验贴知乎","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T04:27:08.253Z","comments":true,"path":"api/articles/Exam/考研经验贴知乎.json","keywords":null,"cover":[],"text":"国防科技大学考研经验贴（英一88）个人情况说明2021年考研报考国防科技大学智能科学学院电子信息-控制方向（专硕），初复试均为第一，具体成绩如下： 其中需要说明的几点 政治还好，正常水平，不过学校政治线为60分，有几个高分大佬被刷 英语确实出乎意料，有点幸运，不过也是有自己的一套...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"Exam","slug":"Exam","count":1,"path":"api/categories/Exam.json"}],"tags":[{"name":"Exam","slug":"Exam","count":1,"path":"api/tags/Exam.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Read1 山月记","uid":"16c6197a747c160400b2f8933851aa25","slug":"Reading/山月记","date":"2021-08-26T03:46:33.000Z","updated":"2021-08-26T07:55:19.895Z","comments":true,"path":"api/articles/Reading/山月记.json","keywords":null,"cover":[],"text":"山月记 中岛敦 对于中国文化故事的了解和再创造 寓思想于故事 言语之优美，寥寥数笔已入作者营造的环境 阅读这本书的过程中，最大的感受是是日本作家对于中国文化的解读。 由日本视角分析中国故事，得出自己的结论，日文写作后翻译为中文，行文之流畅，读起来是一种享受，这实在是难得的。很多时...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Reading","slug":"Reading","count":1,"path":"api/categories/Reading.json"}],"tags":[{"name":"Reading","slug":"Reading","count":1,"path":"api/tags/Reading.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"manim/C4 Example Gallery","date":"2021-08-09T15:09:36.276Z","updated":"2021-08-09T15:26:59.745Z","comments":true,"path":"api/articles/manim/C4 Example Gallery.json","keywords":null,"cover":null,"text":"Example GalleryBasic ConceptsAnimationsPlotting with ManimSpecial Camera SettingsAdvanced Projectshttps://docs.manim.community/en/stable/exa...","link":"","photos":[],"count_time":{"symbolsCount":151,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"CPP/C16 学习C++的后续方法","date":"2021-08-07T01:27:22.761Z","updated":"2021-08-07T01:27:29.769Z","comments":true,"path":"api/articles/CPP/C16 学习C++的后续方法.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"CPP/C15 再探字符图形","date":"2021-08-07T01:27:05.929Z","updated":"2021-08-17T07:52:21.821Z","comments":true,"path":"api/articles/CPP/C15 再探字符图形.json","keywords":null,"cover":null,"text":"再探字符图形设计实现","link":"","photos":[],"count_time":{"symbolsCount":10,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"CPP/C14 近乎自动地管理内存","date":"2021-08-07T01:26:53.301Z","updated":"2021-08-26T07:49:31.493Z","comments":true,"path":"api/articles/CPP/C14 近乎自动地管理内存.json","keywords":null,"cover":null,"text":"近乎自动地管理内存用于复制对象的句柄引用计数句柄可以让您决定何时共享数据的句柄可控句柄的一个改进","link":"","photos":[],"count_time":{"symbolsCount":48,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA10 Recursion","uid":"cfd5571b43938e7edf361ab5277ffd65","slug":"DSA/C10 递归","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:22.665Z","comments":true,"path":"api/articles/DSA/C10 递归.json","keywords":null,"cover":[],"text":"递归：如何用三行代码找到“最终推荐人”？引入 如何理解“递归”？递归应用广泛 DFS深度优先搜索 前中后序二叉树遍历 满足的三个条件 一个问题的解可以分解为几个子问题的解 问题与分解后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 如何编写递归代码？写出递推公式、...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA12 Sort2","uid":"9be35293ffa6798064be3bddd6f599aa","slug":"DSA/C12 排序(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:45.362Z","comments":true,"path":"api/articles/DSA/C12 排序(下).json","keywords":null,"cover":[],"text":"排序（下）：如何用快排思想在$O(n)$​内查找第K大元素？引入两种时间复杂度为$O(nlogn)$的排序算法 归并排序 快速排序 归并排序（Merge sort）原理及实现 数组从中间分成前后两部分 对前后两部分分别排序 再将排好序的两部分合并在一起 递推公式： merge_s...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA0 开篇词","uid":"cdf1a7f1db00ebb74a977ba17a93dbe1","slug":"DSA/C0开篇词","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:17:45.832Z","comments":true,"path":"api/articles/DSA/C0开篇词.json","keywords":null,"cover":null,"text":"跨过“数据结构与算法”技术人所需修炼的“内功” 操作系统 计算机网络 编译原理 数据结构与算法 …… 专栏内容设计 众多数据结构和算法中，选取最实用的内容讲解 数据结构和算法中背后的设计思想 结合真实软件开发案例 模块 入门 时间、空间复杂度 大O表示法由来 复杂度分析技巧 最好...","link":"","photos":[],"count_time":{"symbolsCount":238,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA1 Why DSA?","uid":"971ce7cf635f389a131d803d3ca3c395","slug":"DSA/C1  WHY DSA","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:18:01.066Z","comments":true,"path":"api/articles/DSA/C1  WHY DSA.json","keywords":null,"cover":null,"text":"为什么要学习数据结构和算法 大厂面试 业务开发工程师 不需要自己实现，不代表不需要了解 评估代码的性能和资源的消耗 基础框架中糅合了基础数据结构和算法的设计思想 基础架构研发工程师 不被淘汰 ","link":"","photos":[],"count_time":{"symbolsCount":99,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA13 Sort3","uid":"f0bf7281fb0e82f54bc8de918f6f9204","slug":"DSA/C13 线性排序","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:57.466Z","comments":true,"path":"api/articles/DSA/C13 线性排序.json","keywords":null,"cover":[],"text":"线性排序：如何根据年龄给100万用户数据排序？引入三种时间复杂度为$O(n)$的排序算法 桶排序 计数排序 基数排序 非基于比较的排序算法→时间复杂度为线性 桶排序（Bucket sort） 计数排序（counting sort） 桶排序的特殊情况 所处范围不大，最大值为k，划分...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA16 Binary Search2","uid":"4c75cfdca780ea6522270fb11aab65bd","slug":"DSA/C16 二分查找(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:21:28.081Z","comments":true,"path":"api/articles/DSA/C16 二分查找(下).json","keywords":null,"cover":[],"text":"二分查找（下）：如何快速定位IP对应的省份地址？引入 查找第一个值等于给定值的元素 public int bsearch(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; while (low &lt...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA17 Skip List","uid":"0bec27181caef93fd79c11aa3edf5064","slug":"DSA/C17 跳表","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:22:29.842Z","comments":true,"path":"api/articles/DSA/C17 跳表.json","keywords":null,"cover":[],"text":"跳表：为什么Redis一定要用跳表来实现有序集合？引入如果数据存储在链表中，真的没法用二分查找算法了吗？ 跳表是一种各方面性能都比较优秀的动态数据结构，支持快速地插入、删除、查找操作 如何理解跳表 跳表 = 链表 + 多级索引用跳表查询到底有多快？graph TD 链表n个结点 ...","link":"","photos":[],"count_time":{"symbolsCount":683,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA18 Hash Table1","uid":"f2a6a2cecbbac22b23528956a3dabf70","slug":"DSA/C18 散列表(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:22:42.811Z","comments":true,"path":"api/articles/DSA/C18 散列表(上).json","keywords":null,"cover":[],"text":"散列表（上）：Word文档中的单词拼写检查功能是如何实现的？引入Word拼写检查功能 散列思想Hash Table 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表 经典例子 参赛选手的编号：ke...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA14 Sort4","uid":"bb3030af5d71baf7746e61c6c316baf8","slug":"DSA/C14 排序优化","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:21:05.987Z","comments":true,"path":"api/articles/DSA/C14 排序优化.json","keywords":null,"cover":[],"text":"排序优化：如何实现一个通用的、高性能的排序函数？如何选择合适的排序算法 线性排序场景特殊，不选用 为了兼顾任意规模，首选时间复杂度为$O(nlogn)$ 归并排序空间复杂度可能较高 故选择快速排序 如何优化快速排序理想分区点：被分区点分开的两个分区中，数据的数量差不多 三数取中法...","link":"","photos":[],"count_time":{"symbolsCount":149,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA11 Sort1","uid":"dc2049cb2b924724d0d9c0e20e1cbe8f","slug":"DSA/C11 排序(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:32.914Z","comments":true,"path":"api/articles/DSA/C11 排序(上).json","keywords":null,"cover":[],"text":"排序（上）：为什么插入排序比冒泡排序更受欢迎？概述 如何分析一个排序算法？ 执行效率 最好、最坏、平均情况时间复杂度 时间复杂度的系数、常数、低阶 比较次数和交换次数 内存消耗 原地排序特指空间复杂度是$O(1)$的排序算法 稳定性 如果待排序的序列中存在值相等的元素，经过排序之...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA20 Hash Table3","uid":"4b485bd537f5fd1e1b5f6120bc5388d2","slug":"DSA/C20 散列表(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:10.699Z","comments":true,"path":"api/articles/DSA/C20 散列表(下).json","keywords":null,"cover":[],"text":"散列表（下）：为什么散列表和链表经常会一起使用？LRU缓存淘汰算法链表实现回顾.assets/image-20210724173623972-1627546113415.png) 一个缓存cache系统包含下面几个操作 添加数据 删除数据 查找数据 如果我们将散列表和链表两种数据...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA21 Hash Algorithm1","uid":"df821ff4999b5ea1cca6788fc47b1fb5","slug":"DSA/C21 哈希算法(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:32.250Z","comments":true,"path":"api/articles/DSA/C21 哈希算法(上).json","keywords":null,"cover":[],"text":"哈希算法（上）：如何防止数据库中的用户信息被脱库？引入 2011CSDN“脱库”事件 在实际开发中，如何用哈希算法解决问题 什么是哈希算法？哈希算法：将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法。而通过原始数据映射之后得到的二进制值串就是哈希值。 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA15 Binary Search1","uid":"4fbc272395db721664d9df9e591dbece","slug":"DSA/C15 二分查找(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:21:16.672Z","comments":true,"path":"api/articles/DSA/C15 二分查找(上).json","keywords":null,"cover":[],"text":"二分查找（上）：如何用最省内存的方式实现快速查找功能？无处不在的二分思想 二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0 O(logn)惊人的查找速度 log...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA23 Binary Tree1","uid":"56aa12aba5d53418e62bb5c5f6efe64b","slug":"DSA/C23 二叉树基础(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:57.541Z","comments":true,"path":"api/articles/DSA/C23 二叉树基础(上).json","keywords":null,"cover":[],"text":"二叉树基础（上）：什么样的二叉树适合用数组来存储？问题引入 二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？ 树 名词 定义 节点 树中的每个元素 父子关系 用来连接相邻节点之间的关系 父节点 上级节点 子节点 下级节点 兄弟节点 同级节点 叶子节点/叶节点 没有子节点的...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA24 Binary Tree2","uid":"17d7fb60ad31417e734a0509256cfdc1","slug":"DSA/C24 二叉树基础(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:24:08.589Z","comments":true,"path":"api/articles/DSA/C24 二叉树基础(下).json","keywords":null,"cover":[],"text":"二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？二叉查找树的最大特点：支持动态数据集合的快速插入、删除、查找 散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是 O(1)。既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA25 Red-Black Tree1","uid":"d603cea4e398050da6c08bad435d355e","slug":"DSA/C25 红黑树(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:24:34.611Z","comments":true,"path":"api/articles/DSA/C25 红黑树(上).json","keywords":null,"cover":[],"text":"红黑树（上）：为什么工程中都用红黑树这种二叉树？引入 二叉查找树各个操作时间复杂度跟树的高度成正比，理想情况下，时间复杂度是$O(logn)$ 不过二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于$log_2n$的情况，从而导致各个操作的效率下降 为什么工程中都喜欢用红...","link":"","photos":[],"count_time":{"symbolsCount":971,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA19 Hash Table2","uid":"81c6479ab642eb7be2481f941202d8fb","slug":"DSA/C19 散列表(中)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:22:58.442Z","comments":true,"path":"api/articles/DSA/C19 散列表(中).json","keywords":null,"cover":[],"text":"散列表（中）：如何打造一个工业级水平的散列表？如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？ 如何设计散列函数好的散列函数要求 设计不能太复杂 过于复杂散列函数，消耗很多计算时间 散列函数生成的值要尽可能随...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA26 Red-Black Tree2","uid":"7693d3ff77636135d449fe9da08ce394","slug":"DSA/C26 红黑树(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:24:48.210Z","comments":true,"path":"api/articles/DSA/C26 红黑树(下).json","keywords":null,"cover":[],"text":"红黑树（下）：掌握这些技巧，你也可以实现一个红黑树 爱：稳定、高效的性能 恨：实现起来比较难 实现红黑树的基本思想大致过程遇到什么样的节点排布，我们就对应怎么去调整 回顾红黑树的要求 节点类型 颜色 根节点 黑色 叶子节点 黑色的空节点，不存储数据 相邻节点 不能同时为红色 每个...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA27 Recursion Tree","uid":"134dfc72e46d7c11aedb7ca140c26710","slug":"DSA/C27 递归树","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:19.665Z","comments":true,"path":"api/articles/DSA/C27 递归树.json","keywords":null,"cover":[],"text":"递归树：如何借助树来求解递归算法的时间复杂度？递归树与时间复杂度分析 实战1：分析快速排序的时间复杂度假设平均情况下，每次分区后，两个分区的大小比例为1:k，当k=9时，递推公式为： T(n) = T(\\frac{n}{10})+T(\\frac{9n}{10})+n用递归树来分析...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA22 Hash Algorithm2","uid":"a8b428ae06db3a75338b25077c7c9ca3","slug":"DSA/C22 哈希算法(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:23:40.177Z","comments":true,"path":"api/articles/DSA/C22 哈希算法(下).json","keywords":null,"cover":[],"text":"哈希算法（下）：哈希算法在分布式系统中有哪些应用？哈希算法是如何解决这些分布式问题的 负载均衡负载均衡算法很多，如何才能实现一个会话粘滞的负载均衡算法？即需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上 直接的办法 维护一张映射关系表 弊端 客户端很多，映射表很...","link":"","photos":[],"count_time":{"symbolsCount":970,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA3 Complexity Analysis1","uid":"503921898d741f6fd2003fcfcab3b5d3","slug":"DSA/C3 复杂度分析(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:18:38.740Z","comments":true,"path":"api/articles/DSA/C3 复杂度分析(上).json","keywords":null,"cover":[],"text":"复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？为什么需要复杂度分析？事后统计法的局限 测试结果依赖于测试环境 i9 vs i3 测试结果受数据规模影响大 小规模数据排序，出入排序&gt;快速排序 大O复杂度表示法code1 int cal(int n) &#123; ...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA2 如何抓住重点","uid":"5baaeff214933c2b700d2810a6a1c372","slug":"DSA/C2 如何抓住重点","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:18:16.933Z","comments":true,"path":"api/articles/DSA/C2 如何抓住重点.json","keywords":null,"cover":[],"text":"如何抓住重点，系统高效地学习数据结构与算法？什么是数据结构？什么是算法？广义 数据结构：一组数据的存储结构 算法：操作数据的一组方法 狭义 著名的数据结构和算法 数据结构与算法的关系 数据结构为算法服务 算法作用于特定的数据结构 需要的基础 数学基础 编程基础 学习重点 复杂度分...","link":"","photos":[],"count_time":{"symbolsCount":378,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA29 Heap Application","uid":"3d8241738a6ca807ab996c00fc84c560","slug":"DSA/C29 堆的应用","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:47.086Z","comments":true,"path":"api/articles/DSA/C29 堆的应用.json","keywords":null,"cover":[],"text":"堆的应用：如何快速获取到Top 10最热门的搜索关键词？堆的几个经典应用 优先级队列 求Top K 求中位数 堆的应用一：优先级队列 优先级队列 队列 出队顺序按照优先级来 优先级队列与堆很像 插入元素→堆中插入元素 取出优先级最高的元素→取出堆顶元素 合并有序小文件 问题描述 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA31 DFS&BFS","uid":"7e4c0f4e2f510c4e8317f9775d710031","slug":"DSA/C31 深度和广度优先搜索","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:26:07.522Z","comments":true,"path":"api/articles/DSA/C31 深度和广度优先搜索.json","keywords":null,"cover":[],"text":"深度和广度优先搜索：如何找出社交网络中的三度好友关系？什么是搜索算法？ DFS，Depth-First-Search，深度优先搜索 BFS，Breadth-First-Search，广度优先搜索 都是基于图结构的。在图中找出从一个顶点出发，到另一个顶点的路径 图的代码实现publ...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA30 Graph","uid":"23870052c199bf06d18a4a93d8161ea8","slug":"DSA/C30 图的表示","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:56.469Z","comments":true,"path":"api/articles/DSA/C30 图的表示.json","keywords":null,"cover":[],"text":"图的表示：如何存储微博、微信等社交网络中的好友关系？如何理解图？ 名词 定义 顶点vertex 图中的元素 边edge 图中顶点与任意其他顶点建立的关系 度degree 跟顶点相连接的边的条数 有向图 边有方向的图 无向图 边无方向的图 带权图 每条边都有一个权重 入度 in-d...","link":"","photos":[],"count_time":{"symbolsCount":597,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA32 String Match1","uid":"2786242c5ba6ce0832bbacd81c75d253","slug":"DSA/C32 字符串匹配基础(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:26:22.494Z","comments":true,"path":"api/articles/DSA/C32 字符串匹配基础(上).json","keywords":null,"cover":[],"text":"字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？字符串匹配 算法 单模式串匹配的算法：一个串跟一个串进行匹配 BF算法 RK算法 多模式串匹配的算法：在一个串中同时查找多个串 BM算法 KMP算法 BF算法Brute Force，暴力匹配算法，朴素匹配算法 在字符串A中...","link":"","photos":[],"count_time":{"symbolsCount":748,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA34 String Match3","uid":"9ae95ab2c9e432ffcdddad19b3709cb8","slug":"DSA/C34 字符串匹配基础(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:26:45.892Z","comments":true,"path":"api/articles/DSA/C34 字符串匹配基础(下).json","keywords":null,"cover":[],"text":"字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法？所有字符串匹配算法中，最知名的一种非KMP算法莫属 KMP算法基本原理Knuth-Morris-Pratt 核心思想 模式串与主串匹配过程中，当遇到不可匹配的字符时，希望找到一些规律，将模式串向后多滑动几位，跳过那些肯定不...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA37 Greedy Algorithm","uid":"a9e32e2621fbdc03b2a42efbcf0ce8e5","slug":"DSA/C37 贪心算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:30.880Z","comments":true,"path":"api/articles/DSA/C37 贪心算法.json","keywords":null,"cover":[],"text":"贪心算法：如何用贪心算法实现Huffman压缩编码？几个基本的算法思想 贪心算法 Huffman Coding Prim和Kruskal最小生成树算法 Dijkstra单源最短路径 分治算法 回溯算法 动态规划 本章如何利用贪心算法实现对数据压缩编码，有效节省数据存储空间 如何理...","link":"","photos":[],"count_time":{"symbolsCount":678,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA28 Heap","uid":"1ecdd1e00fb73a51c0511d1921f5b63c","slug":"DSA/C28 堆和堆排序","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:33.089Z","comments":true,"path":"api/articles/DSA/C28 堆和堆排序.json","keywords":null,"cover":[],"text":"堆和堆排序：为什么说堆排序没有快速排序快？特殊的树：堆(Heap) 堆排序 原地 时间复杂度为$O(nlogn)$ 实际软件开发中，快速排序的性能要比堆排序好 如何理解堆？ 完全二叉树 堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值 大顶堆 小顶堆 如何实现一...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA33 String Match2","uid":"0ec81c6d3aa8372bc4bd0a74846f2430","slug":"DSA/C33 字符串匹配基础(中)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:26:35.770Z","comments":true,"path":"api/articles/DSA/C33 字符串匹配基础(中).json","keywords":null,"cover":[],"text":"字符串匹配基础（中）：如何实现文本编辑器中的查找功能？文本编辑器中的查找替换功能 BM算法，Boyer-Moore KMP算法 BM算法核心思想 当模式串和主串某个字符不匹配的时候，能够跳过一些可定不会匹配的情况，将模式串往后多滑动几位 算法原理分析坏字符规则 graph TD ...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA40 回溯算法","uid":"cab4c9495dd444030efce39574aea74e","slug":"DSA/C39 回溯算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:28:02.190Z","comments":true,"path":"api/articles/DSA/C39 回溯算法.json","keywords":null,"cover":[],"text":"回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想引入回溯算法的应用 深度优先搜索 经典数学问题 数独 八皇后 0-1背包 图的着色 旅行商问题 全排列 如何理解回溯算法笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA40 初识动态规划","uid":"7315897fe4af98b9a72088541e465f37","slug":"DSA/C40 初识动态规划","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:28:16.832Z","comments":true,"path":"api/articles/DSA/C40 初识动态规划.json","keywords":null,"cover":null,"text":"初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？引入 双十一满200减50，选出来的商品价格总和最大程度接近满减条件，极大限度薅羊毛 动态规划学习路线动态规划比较适合用来求解最优问题，比如求最大值、最小值等 初识动态规划 两个经典动态规划问题模型 为什么动态规划 动态规划解...","link":"","photos":[],"count_time":{"symbolsCount":220,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA38 分治算法","uid":"28170d54ceec31fbbfec4bc7706417d1","slug":"DSA/C38 分治算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:48.625Z","comments":true,"path":"api/articles/DSA/C38 分治算法.json","keywords":null,"cover":[],"text":"分治算法：谈一谈大规模计算框架MapReduce中的分治思想引入Google大数据处理三驾马车 MapReduce GFS Bigtable 如何理解分治算法核心：分而治之 将原问题划分成n个规模较小，并且结构与原问题相似的子问题 递归地解决这些子问题 然后合并其结果 分治算法的...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA4 Complexity Analysis2","uid":"fc19127153caeb9baa595a1d01d3f0d7","slug":"DSA/C4 复杂度分析(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:18:54.464Z","comments":true,"path":"api/articles/DSA/C4 复杂度分析(下).json","keywords":null,"cover":null,"text":"复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度// n表示数组array的长度 int find(int[] array, int n, int x) &#123; int i = 0; int pos = -1; for (; i &lt; n; ++i) &#123;...","link":"","photos":[],"count_time":{"symbolsCount":906,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA36 AC自动机","uid":"06d10bcf0dacb0e855883f8036c8872c","slug":"DSA/C36 AC自动机","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:16.033Z","comments":true,"path":"api/articles/DSA/C36 AC自动机.json","keywords":null,"cover":[],"text":"AC自动机：如何用多模式串匹配实现敏感词过滤功能？引入敏感词过滤功能是如何实现的？ 字符串匹配算法 通过维护一个敏感词的字典，当用户输入一段文字内容之后，通过字符串匹配算法查找用户输入的文字，包含敏感词则用“*”替换掉 访问量巨大的网站来说，如何实现一个高性能的敏感词过滤系统？ ...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA35 Trie Tree","uid":"6ac917baf75da522e92f8103dc9fe5ea","slug":"DSA/C35 Trie树","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:00.561Z","comments":true,"path":"api/articles/DSA/C35 Trie树.json","keywords":null,"cover":[],"text":"Trie树：如何实现搜索引擎的搜索关键词提示功能？搜索引擎的搜索关键词提示功能 什么是Trie树？ 字典树，树形结构 专门处理字符串匹配的数据结构 解决在一组字符串集合中快速查找某个字符串的问题 先看看Trie树长什么样 本质：利用字符串之间公共前缀，将重复前缀合并在一起 6个字...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA7 Linked List2","uid":"4d2b8ed889fbd369f571fec1667609a5","slug":"DSA/C7 链表(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:19:36.392Z","comments":true,"path":"api/articles/DSA/C7 链表(下).json","keywords":null,"cover":[],"text":"链表（下）：如何轻松写出正确的链表代码？几个技巧 理解指针或引用的含义 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量 警惕指针丢失和内存泄漏 情况 代码 p-&gt;next =...","link":"","photos":[],"count_time":{"symbolsCount":310,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA5 Array","uid":"be65ef045a392dbdd6233f994cc17ed3","slug":"DSA/C5 数组","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:19:05.261Z","comments":true,"path":"api/articles/DSA/C5 数组.json","keywords":null,"cover":[],"text":"数组：为什么很多编程语言中数组都从0开始编号？如何实现随机访问？ 数组(array) 一种线性表数据结构。用一组连续的内存空间，来存储一组具有相同类型的数据 线性表与非线性表 线性表 数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向 非线性表 数据之间并不是简...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA9 Quene","uid":"d631f4f7e4cb3f5655d7dbbeb5a6587c","slug":"DSA/C9 队列","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:09.920Z","comments":true,"path":"api/articles/DSA/C9 队列.json","keywords":null,"cover":[],"text":"队列：队列在线程池等有限资源中的应用问题引入当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？ 如何理解“队列”？ 先进先出 入队enqueue() 出队dequeue() ...","link":"","photos":[],"count_time":{"symbolsCount":195,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA6 Linked List1","uid":"85ae2c10dc6f2d0c388a295260d12e29","slug":"DSA/C6  链表(上)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:19:23.070Z","comments":true,"path":"api/articles/DSA/C6  链表(上).json","keywords":null,"cover":[],"text":"链表（上）：如何实现LRU缓存淘汰算法？缓存淘汰概述缓存 提高数据读取性能的技术 大小有限，缓存被用满时，数据清理和保留 —&gt; 缓存淘汰策略 FIFO，先进先出策略 LFU，最少使用策略 LRU，最近最少使用策略 链表结构与数组的对比 数组 连续的内存空间存储，对内存的要求...","link":"","photos":[],"count_time":{"symbolsCount":837,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA8 Stack","uid":"a75362207a5dc66d40d312cda296e3d4","slug":"DSA/C8 栈","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:19:48.319Z","comments":true,"path":"api/articles/DSA/C8 栈.json","keywords":null,"cover":[],"text":"栈：如何实现浏览器的前进和后退功能如何理解“栈” 后进先出 “操作受限”的线性表 Why 栈？ 数组或链表暴露了太多操作接口，灵活自由但也比较不可控，容易出错 当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。 如何...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}],"categories":7,"tags":70,"word_count":"182k","post_count":74}