[{"id":"3581cdcf9114ba455b092a502e8d7f6f","title":"L1.1 线性空间","content":"线性空间\n\n\n\n\n\n\n\n\n\n空间与集合\n所谓空间是对立体世界的抽象\n线性空间满足了“可线性扩张”即线性变换定义的运算\n\n\n\n\n线性空间的概念数域的定义\n加减乘除运算封闭\n\n线性空间定义\n运算元素\n数域$F$中的数$k$\n非空集合$V$中的元素$\\alpha,\\beta$\n\n\n运算\n加法\n数乘\n\n\n运算性质\n加法\n数乘\n零元、负元\n\n\n\n\n常见线性空间\n\n\n\n\n\n\n\n\n例题1:\n\n$\\R_+$无法定义负元：因为没有负的元素\n\n线性空间的性质\n零元唯一\n任一向量对应负元唯一\n$0$和$-1$对向量的数乘运算\n$\\vec{0}$的作用\n\n线性表示、线性相关、线性无关\n线性表示\n用一组向量和实数表示某一个向量\n\n\n\n线性相关\n基向量中有冗余\n\n\n\n线性无关\n基向量无冗余，每个都个顶个\n\n证明\n反证法\n\n\n\n\n\n线性空间的基与维数定义\n所谓的“基”：基本元素\n\n\n\n\n$dim(V)=n$\n\n线性空间内禀的性质，不因基的选取而改变\n\n\n无穷维存在吗？\n\nEg:Fourier\nf(x)\\sim a_0+\\sum_{n=1}^{+\\infty}a_ncos(nx)+b_nsin(nx)\n\n\n基左标右\n\n\n\\beta = \\sum x_i \\alpha_i = [\\alpha_1,\\cdots,\\alpha_n][x_1,\\cdots,x_n]^T\n\n\n\n给定基求向量的坐标过渡矩阵\n基之间的变换关系$B\\stackrel{P}{\\longrightarrow}A$\n过渡矩阵满秩：变换不降维\n计算\n$\\xi = Ax=By$\n\n\n\n线性子空间\n\n\n\n\n\n\n\n\n引入\n集合论\n\n集合的关系\n包含、是否相交……\n\n\n集合运算\n交、并\n\n\n集合的度量\n集合元素有多少……\n\n\n\n可列可数\n\n可列\n集合中的元素和自然数一样多\n如偶数集、整数集\n\n\n不可列\n如$\\R$，$[0,1]$\n\n\n\n定义\n(V,F,+,\\cdot) \\\\\n(W,F,+,\\cdot) \\\\\n$$ { }\n\n### 零空间\n\n- 零空间\n  - 使得$A\\vec{x}=0$ ($\\vec{x}\\stackrel{A}{\\longrightarrow}\\vec{0}$)成立的全部的$\\vec{x}$构成的集合\n  - $dim(\\mathscr{N}(A)) = n - rank(A) = n -r$\n    - 表明了线性方程组包含的解的个数由“秩”决定\n\n### 值空间\n\n- 列空间(值空间)\n  - 使得$\\vec{y}=A\\vec{x}$成立的全部$\\vec{y}$构成的集合\n\n### 张成的子空间\n\n- 向量的线性组合\n\n### 基扩张定理\n\n- 含义\n  - 表明了在一个$n$维空间中，用一组$r(r\n\n- 两子空间的交与和仍然是线性空间，但是\"并\"则不一定是\n  - \n\n### 维数公式dim(W_1 \\cap W_2) + dim(W_1+W_2) = dim(W_1) + dim(W_2)\n\n\n\n\n> 证明\n>\n> 1. 取$W_1 \\cap W_2$的基分别扩张为$W_1$和$W_2$的基\n> 2. 两组基合并再进行扩张可以得到$W_1+W_2$\n> 3. 证明第一步中新增加的所有向量是线性无关的\n>\n> \n>\n\n\n\n\n\n\n\n\n\\sum_{i=1}^{r}x_i\\alpha_i +\\sum_{j=1}^{r_1-r}y_i\\beta_j+\\sum_{k=1}^{r_2-r}z_i\\gamma_i \\\\= \\alpha +\\beta +\\gamma \\\\= 0\n\n\\alpha + \\beta = - \\gamma \\\\ \\downarrow\\\\\\alpha + \\beta \\in W_1 \\\\\\&amp; \\\\ \\gamma \\in W_2 \\\\\n\\downarrow \\\\\n\\gamma \\in (W_1 \\cap W_2)\n\\\\\n\\downarrow\\\\let. \\gamma = \\sum_{i=1}^{r} x^{*}_{i}\\alpha_i\n\\\\\\downarrow\\\\\n\\alpha + \\beta + \\gamma = 0 \\to \\sum_{i=1}^{r} (x_i-x^{*}_{i})\\alpha_i + \\sum_{j=1}^{r_1-r} y_{j}\\beta_i = 0\n\\\\\\downarrow\\\\y_j = 0\n\n\n同理可得x_i = 0,z_k = 0\n$$\n空间的直和分解\n","slug":"AEM/L1.1 线性空间","date":"2021-10-09T14:56:33.000Z","categories_index":"AEM","tags_index":"Advanced Engineering Mathematics","author_index":"Rambo"},{"id":"bbed368f10c5499ea3c0dff1bf58a0fe","title":"C1 人工智能导论","content":"人工智能导论\nGoogle \nMobile First$\\to$AI First$\\to$AI Only\n\n\n\nDefinition\n智能\n先天本能\n后天学习\n\n\nHuman-Defined instinct\n\neg：河狸筑水坝if-then模式\n\nif 听到流水声\n  then 筑水坝\n\n\n\n\n缺陷\n\n难以考虑所有可能性\n费力\n\n\n\n\nLearning- based\n\nHistory\ngraph LR\n1956-1974\n\n-->1974-1980\n\n-->1980-1990\n-->1990-2006\n-->2006-now\n\nAchievement\nChess$\\to$Go\nSpeech Recoginition+Machine Translation\nSelf-Driving System\nMusic\nPoem\nMedical\nFinace\nEducation\nMilitary\n\nBloom Factors\nAlgorithm\nDeep learning、Reinforcement learning\n\n\nBig-supervision data\nImage net、Place net、Billions face pictures\n\n\nComputing\nGPU\n\n\n\nBased on Computer VisionTaskpixel $\\to$information\nHuman\neyes$\\to$capture\n\nbrain$\\to$process\n\n  graph LR\neyes --> v1 --> v2 --> ...\n\n逐层抽象的概念很重要\n\n\nComputer\nSingle neural cell$\\to$对单个细胞的抽象$\\to$MCP Model\n\n\n\n\nMulti-Layer connection$\\to$deep learning\n\n\n\nCNN$\\to$Weight Sharing$\\to$减少参数$\\to$深层的layer难以解释\n\n\n\n\nABCAlgorithm\nBig-Supervised data\nComputingGPUs\nSome Subjects\nimage classification\nobject detection\nsemantic segmentation\nimage captioning\nvisual question answering\n\nSome changes in minds\n✓ Utilize the black box to solve the non-linear problem\n✓ Divide and Conquer -&gt; End-to-end\n✓ Algorithm-focus -&gt; Data focus\n✓ hand crafted feature -&gt; learn feature  \n\nFuture\nX-data\nZero-shot\n……\n\n\nPlatform\n……\n\n","slug":"DeepLearning/C1 人工智能导论","date":"2021-10-01T09:16:36.000Z","categories_index":"DL","tags_index":"DL","author_index":"Rambo"},{"id":"5707c513f22fe968248397c6227b13ef","title":"C0 绪论","content":"绪论概述基础邀请码：EWZPN\n人工智能导论\n深度学习导论\n深度学习基础\n人工智能：机器像人一样\n线$\\to$点：向量$\\to$点\n讲授方式\n理论+实践\n\n实验1 :star:\n实验2\n实验3\n实验4\n\n\nWhy PyTorch？\n\n学术界顶会使用框架\n\n\n\n方法&amp;应用\n\n考核\n课程实验 50\n拓展\n\n\n研究报告+汇报PPT 30\n某一方向归纳现状、挑战、未来方向\n\n\n课堂表现 20\n课堂签到、参与程度\n\n\n\nAI-ML-DL\n\n","slug":"DeepLearning/C0 绪论","date":"2021-10-01T09:16:33.000Z","categories_index":"DL","tags_index":"DL","author_index":"Rambo"},{"id":"df5af6f71edb87ae26fa2c44cce1ef6b","title":"C1 Introduction&Convex Hulls","content":"IntroductionForewordHomework\n顶会外文文献选一篇文章，一周内，抓阄确定报告顺序\n主题\n图形、图像、机器人、计算几何、涉及到与图形相关的皆可\n\n\n建议\n教材上面的关键词\n\n\n\n\nCGAL开源工具下载安装，讲过的算法可以直接嵌入\n不要看代码先自己实现\n\n\n写读书报告\n课程教学了什么\n小论文报告体会\nCGAL应用的如何\n\n\n\nAbout Teacher13487316328\nysxiong@nudt.edu.cn\nCG vs CV\n\n\n\n\nInput\nOutput\n侧重\n\n\n\n\nCG\n对虚拟场景的描述通常为多边形数组而每个多边形由三个顶点组成，每个顶点包括三维坐标、贴图坐标、rgb 颜色等\n图像即二维像素数组\n拓扑结构\n\n\nCV\n图像或图像序列通常来自相机、摄像头或视频文件\n对于图像序列对应的真实世界的理解比如检测人脸、识别车牌\n信息提取\n\n\nDIP\n图像\n图像模糊、灰度化、增强对比度等\n图像本身信息变换\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhttps://www.zhihu.com/question/20672053/answer/15854031\nhttps://www.zhihu.com/question/20672053/answer/49951399\nhttps://blog.csdn.net/hanlin_tan/article/details/50447895\nWhat’s Computional Geometry？计算几何：几何图形的几何算法设计\nWhy？从底层开始$\\to$解决卡脖子问题\nSome Examples\nLook up the nearest public phone\n\n划分片区……$\\to$Voronoi diagram\n\n\nShort connection\n\n机器人行走避障$\\to$P2P之间有没有一条连通的路\nMotion Planning of robotics\n\n\noverlaying maps\n结合两幅地图的信息\n\n\n\nVarious application Domains\nRobotics\nCG\nCAD/CAM\nGIS\nInternet\nVR\nVirtual Surgery\n\nConvex HullsGood Solutions\n\n\n\n\n\n\n\n\nGood Solutions to algorithmic problems of a geometric nature based on:\n\nThorough understanding of the geometric properties of the problems\nA proper application of algorithmic techniques and data structures\n\nQuestion DescriptionA subset $S$ of the plane is called convex if and only if for any pair of points $p, q \\in S$ the line segment $\\overline{p q}$ is completely contained in $S$. The convex hull $\\mathrm{C} \\mathcal{H}(S)$ of a set $S$ is the smallest convex set that contains $S$. To be more precise, it is the intersection of all convex sets that contain $S$\n\n即：\n给定一个平面点集，求取能够包含该平面点集中所有的点且为”凸”的顶点的顺序排列\n\n输入：点集\n输出：构成凸多边形的有序顶点\n\n\nAlgorithm 0：Divide&amp;Conquer\n上包下包\n递归算法$\\to$递归出口问题\n\nAlgorithm 1：SlowConvexHull\n思路解析graph TD\n初始化点集集合为空集\n--> 选取一对点p和q\n--> 选取第三个点r\n--所有点r皆在pq直线的右侧或直线上-->  p和q属于目标点集 \n\n选取第三个点r--有任一点r在pq直线的左侧--> p和q不属于目标点集\n\n注意点\n技术细节\n\nif r lies to the left of the directed line from p to q的程序表示\n行列式$\\le0$\n\n\nStep5 can be performed in constant time\n涉及到floating point arithmetic$\\to$不准确性$\\to$数据输入时有理化\n\n\n特点\n\nSlow\nnot robust\ndegenerate cases are awkward\n\n蛮力算法：$O(n^3)$\n\n\n\n问题出现在哪里\n\n穷举，任意两点都要计算\n\n\n\nAlgorithm 2：incremental algorithm\n思路解析graph TD\n点集中所有点按照x轴坐标升序排列为点序列\n--> 将p_1和p_2加入到目标点集中\n--> 依次加入后面的点\n--make_a_right_turn--> 将该点加入到目标点集中\n\n--> 下半部分\n\n依次加入后面的点\n--do_not_make_a_right_turn--> 删除掉最后三个点中中间那个点\n\n--> 下半部分\n--> 删除上下重复的两个点\n\n注意点\n技术细节\n有可能出现在凸包上的点上才进行\n$[xmin,xmax,ymin,ymax]$\n对所有点按照x坐标进行排序\n\n\nincremental的来源\n按照x坐标进行向前增量，构成左拐的点剔除掉\n\n\ndelete the middle\np_i在当前看肯定在凸包上，要回看last three points\n\n\n主要开销\n排序\n最坏$O(n^2)$\n最好$O(n)$\n最坏情况下的最好时间开销$O(nlogn)$\n\n\n\n\n\n\n特点\nuse the lexicographic order\nLeft/right turn\nfloating point arithmetric$\\to$Compute a closed polygonnal chain$\\to$有理运算来避免浮点运算的误差\n\n\n\n时间复杂度的证明\n\n\n\n\n\n\n\n\nTheorem 1.1\nThe convex hull of a set of n points in the plane can be computed in $O(nlogn)$ time\nProof：\n归纳法\n\nDegeneracies and robustnessgraph LR\nignore_everything\n--> degenerate_cases\n--> actual_implementation\n\n粗-->细-->robust\n\n课程补充资料\n\n\n\n\n\n\n\n\nhttp://www.cs.uu.nl/geobook/\nhttps://ocw.mit.edu/courses/mechanical-engineering/2-158j-computational-geometry-spring-2003/lecture-notes/\n","slug":"ComputionalGeometry/C0 绪论","date":"2021-10-01T09:14:33.000Z","categories_index":"Computional Geometry","tags_index":"Computional Geometry","author_index":"Rambo"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Example GalleryBasic ConceptsAnimationsPlotting with ManimSpecial Camera SettingsAdvanced Projectshttps://docs.manim.community/en/stable/examples.html\n","slug":"manim/C4 Example Gallery","date":"2021-10-01T09:01:29.632Z","categories_index":"","tags_index":"","author_index":"Rambo"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"想到需要begging for love，就觉得自己pathetic。不自觉的伤感，无法保持积极向上的心态，持续的受挫。I’m really good at meeting wrong person.\n在这个快节奏的时代，认真了解一个人变得奢侈，被了解也是一件几乎不可能的事情。\n爱-被爱\n","slug":"Life/硕士入学","date":"2021-10-01T09:01:29.601Z","categories_index":"","tags_index":"","author_index":"Rambo"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"","slug":"CPP/C16 学习C++的后续方法","date":"2021-10-01T09:01:28.961Z","categories_index":"","tags_index":"","author_index":"Rambo"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"近乎自动地管理内存用于复制对象的句柄引用计数句柄可以让您决定何时共享数据的句柄可控句柄的一个改进","slug":"CPP/C14 近乎自动地管理内存","date":"2021-10-01T09:01:28.945Z","categories_index":"","tags_index":"","author_index":"Rambo"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"再探字符图形设计实现","slug":"CPP/C15 再探字符图形","date":"2021-10-01T09:01:28.945Z","categories_index":"","tags_index":"","author_index":"Rambo"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n","slug":"hello-world","date":"2021-10-01T08:36:50.265Z","categories_index":"","tags_index":"","author_index":"Rambo"},{"id":"a0222f48ea50656458184947f3dd6fed","title":"C7 链接","content":"链接引入\n\n\n\n项目\n含义\n\n\n\n\n链接的定义\n将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载(复制)到内存并执行\n\n\n执行时间\ncompile time/load time/run time\n\n\n作用\n使得separate compilation成为可能将模块分解为更小、更好管理的模块\n\n\n学习的必要性\n帮助构造大型程序帮助避免危险的编程错误帮助理解语言的作用域规则如何实现帮助理解其他重要的系统概念能够利用共享库\n\n\n\n\n编译器驱动程序main.c\nint sum(int *a,int n);\n\nint array[2] = &#123;1,2&#125;;\n\nint main()\n&#123;\n  int val = sum(array,2);\n  return val;\n&#125;\nsum.c\nint sum(int *a,int n)\n&#123;\n  int i,s = 0;\n  for(i = 0;i&lt;n;i++)\n  &#123;\n    s += a[i];\n  &#125;\n  return s;\n&#125;\ngcc -Og -o prog main.c sum.c\n\n静态链接graph TD\n可重定位目标文件和命令行参数\n--static.linker--> 完全链接的且可加载和运行的可执行目标文件\n\n不同的代码和数据节组成.每一节都是一个连续的字节序列\n--符号解析.重定位--> 输出\n\n\n\n\n\n任务\n英文\n作用\n\n\n\n\n符号解析\nsymbol resolution\n将每个符号引用正好和一个符号定义关联起来目标文件定义和引用符号每个符号对应于一个函数、一个全局变量或一个静态变量\n\n\n重定位\nrelocation\n编译器和汇编器生成从地址0开始的代码和数据节链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置\n\n\n\n\n对于链接器的一些基本事实\n\n目标文件纯粹是字节块的集合\n程序代码\n程序数据\n引导链接器和加载器的数据结构\n\n\n链接器将字节块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置\n链接器对目标机器了解甚少\n\n目标文件三种形式\n\n\n\n\n类型\n包含\n形式\n\n\n\n\n可重定位目标文件\n二进制代码和数据\n可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件\n\n\n可执行目标文件\n二进制代码和数据\n可以被直接复制到内存并执行\n\n\n共享目标文件\n特殊的可重定位目标文件\n可以在加载或者运行时被动态地加载进内存并链接\n\n\n\n\n\nobject module：字节序列\nobject file：一个以文件形式存放在磁盘中的目标模块\n\n各个系统目标文件格式\n\n\n\n\n系统\n目标文件格式\n\n\n\n\n贝尔实验室第一个Unix系统\na.out\n\n\nWindows\nPE(Portable Executable)\n\n\nMac-OS-X\nMach-O\n\n\n现代x86-64 Linux和Unix\nELF(Executable and Linkable Format)\n\n\n\n\n可重定位目标文件一个典型的ELF可重定位目标文件的格式\n\n符号和符号表每个可重定位目标模块m都有一个符号表，包含m定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号\n\n\n\n\n符号类型\n\n\n\n\n\n\n由模块m定义并能够被其他模块引用的全局符号\n\n\n\n\n由其他模块定义并被模块m引用的全局符号\n称为外部符号，对应于在其他模块中定义的非静态C函数和全局变量\n\n\n\n只被模块m定义和引用的局部符号\n对应于带static属性的C函数和全局变量\n\n\n\n\n","slug":"CSAPP/C7-链接","date":"2021-09-06T12:10:30.000Z","categories_index":"CSAPP","tags_index":"CSAPP","author_index":"Rambo"},{"id":"ef5fe063a7d3aa88da43f1d6119bbac2","title":"C6 存储器层次结构","content":"存储器层次结构引入存储技术局部性存储器层次结构高速缓存存储器编写高速缓存友好的代码综合：高速缓存对程序性能的影响","slug":"CSAPP/C6-存储器层次结构","date":"2021-09-05T07:45:30.000Z","categories_index":"CSAPP","tags_index":"CSAPP","author_index":"Rambo"},{"id":"43e79f6e161596f1d8a3c8c2b15157f9","title":"C5 优化程序性能","content":"优化程序性能引入写程序最主要的目标：在所有可能的情况下都正确工作\n编写程序需要做到\n\n选择适当的算法和数据结构\n编写出编译器能够有效优化以转换成高效可执行代码的源代码\n即使是最好的编译器也收到optimization blocker的阻碍，即严重依赖于执行环境的方面\n\n\n将一个任务分成多个部分\n\n程序优化\n\n消除不必要的工作\n消除不必要的函数调用、条件测试、内存引用\n\n\n利用处理器提供的指令级并行能力，同时执行多条指令\n\nprofiler的作用\n\n测量程序各个部分性能的工具\n帮助找到代码中低效率的地方，并且确定程序中应该着重优化的部分\n\n修改source code vs 用汇编语言编写\n\n修改source code：可移植性强\n汇编语言：性能好\n\n优化编译器的能力和局限性optimization blocker\n\n特殊情况\n不同指针指向内存中的同一个位置\n……\n\n\n函数调用\n\n表示程序性能Cycles Per Element：每元素周期数，帮助我们在更细节的级别上理解迭代程序的循环性能\n\n程序示例消除循环的低效率减少过程调用消除不必要的内存引用理解现代处理器Intro\n之前的优化都不依赖于目标机器的任何特性，只是降低过程调用的开销，消除一些critical “optimization blockers”\n需进一步提高性能，则考虑利用处理器微体系结构的优化，即处理器用来执行指令的底层系统设计\n\n现代处理器的指令级并行instruction-level parallelism\n即：多条指令可以并行地执行，同时又呈现出一种简单的顺序执行指令的表象\n\n复杂硬件➡️程序性能最大化➡️处理器实际操作与通过观察机器级程序所察觉到的大相径庭\n代码级：顺序执行指令\n实际处理器：同时对多条指令求值\n\n\n\n两种下界描述了程序的最大性能\n\nlatency bound➡️一系列操作必须按照严格顺序执行时\nthroughput bound➡️处理器功能单元原始计算能力\n\nOverall Operation\n\n\n\n处理器类型\n硬件\n指令并行度\n\n\n\n\nin-order pipeline\n简单\n低\n\n\nout-of-order processors\n复杂\n高\n\n\n\n\n\n\n\n\n名词\n英文\n含义\n\n\n\n\n超标量\nsuperscalar\n可以在每个时钟周期执行多个操作\n\n\n乱序\nout-of-order\n指令执行的顺序 不一定要与它们在机器级程序中的顺序一致\n\n\n指令控制单元\nICU,Instruction Control Unit\n从内存中读出指令序列并根据指令序列生成一组针对程序数据的基本操作\n\n\n执行单元\nEU,Execution Unit\n执行操作\n\n\n\n\n\nBranch Predictiongraph TD\n处理器开始取出位于它预测的分支会跳到的地方的指令\n--> 对指令译码 \n--> BranchPrediction\n--yes?--> 执行操作\n\n\nBranchPrediction\n--no?--> 将状态重新设置到分支点状态 --> 开始取出和执行另一个方向上的指令\n\nInstruction Decodinggraph TD\n实际的程序指令\n\n--InstructionDecoding--> 一组基本操作/微操作\n\nFunction Unit for Intel Core i7 Haswell\nRetirement Unit记录正在进行的处理，并确保它遵守机器级程序的顺序语义\ngraph TD\n指令译码时信息被放置在一个先进先出的队列\n--> 信息一致保持在队列中\n--> 指令操作完成 --> 指令retired\n\n信息一致保持在队列中\n--> 引起指令的分支点被确认为预测正确 --> 指令retired \n--> 对程序寄存器的更新都可以被实际执行了\n\n信息一致保持在队列中\n--> 引起指令的某个分支点被确认为预测错误\n--> 指令flushed --> 丢弃所有计算结果 --> 预测错误就不会改变程序的状态\n\n并行化实现方法\n通过执行单元之间的operation result的信息交换，某条指令分支预测皆正确，则提前实现对程序寄存器的更新，加速指令到另一条指令的结构的传送，实现指令并行化。\n\nRegister Renaming\n本质：数据转发\n作用\n值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件再读出来\n使得第二个操作能够在第一个操作完成后尽快开始\n\n\n\ngraph TD\n更新寄存器r的指令译码时产生标记t\n--> 条目r,t被加入到一张表中\n--> 该表维护着每个程序寄存器r与会更新该寄存器的操作标记t之间的关联\n--> 以寄存器r作为操作数的指令译码时\n--> 发送到执行单元的操作会包含t作为操作数源的值\n--某个执行单元完成第一个操作时-->产生结果v,t指明标记为t的操作产生值v\n--> 所有等待t作为源的操作都能使用v作为源值\n\nFunctional Unit Performance\n\n\n\nperformance\n含义\n\n\n\n\nlatency\n完成运算所需要的总时间\n\n\nissue time\n两个连续的同类型的运算之间需要的最小时钟周期数\n\n\ncapacity\n能够执行该运算的功能单元的数量\n\n\n\n\n\n\n\n\n\nbound\n含义\n\n\n\n\nlatency bound\n给出了任何必须按照严格顺序完成合并运算的函数所需要的最小CPE值\n\n\nthroughput bound\n给出了CPE的最小界限\n\n\n\n\n\nAn Abstract Model of Processor Operationdata-flow：一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的\ncritical-path：执行一组机器指令所需时钟周期数的一个下界\nFrom Machine-Level Code to Data-Flow Graphsdata-flow：\n\n非正式\n用其形象描述程序中数据相关如何主宰程序的性能\n\n\n\n对于形成循环的代码片段，我们可以将访问到的寄存器分成四类\n\n\n\n\n寄存器类别\n特点\n\n\n\n\nRead-only.\n只用作源值，可以作为数据，也可以用来计算内存地址但是在循环中不会被修改\n\n\nWrite-only.\n作为数据传送操作的目的\n\n\nLocal.\n在循环内部被修改和使用，迭代与迭代之间不相关\n\n\nLoop.\n既作为源值，又作为目的，一次迭代中产生的值会在另一次迭代中用到\n\n\n\n\n将combine4的操作抽象成数据流图\n\n\nOther Performance Factorsdata-flow表示中的critical path提供的只是程序需要周期数的下界，还有其他一些因素会限制性能\n\n可用的功能单元数量\n任何一步中功能单元之间能够传递数据值的数量\n\n循环展开","slug":"CSAPP/C5-优化程序性能","date":"2021-09-01T03:34:30.000Z","categories_index":"CSAPP","tags_index":"CSAPP","author_index":"Rambo"},{"id":"a36fe725225b00ec2046a714dc5f7085","title":"hexo1 博客搭建(MacOS BigSur11.5)","content":"https://blog.csdn.net/jingbin_/article/details/79536467\n依赖安装","slug":"hexo/保姆级hexo博客搭建教程","date":"2021-08-31T15:42:53.000Z","categories_index":"Hexo","tags_index":"Hexo","author_index":"Rambo"},{"id":"41c9988c9d49b8561ffc5122ee9897a3","title":"B1 翻译勘误","content":"\n\n\n\nPage CN\nPage EN\nEnglish\nChinese Original\nChinese Recommend\n\n\n\n\n300\n421\nicode\n指令代码\n指令编号/编码\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"CSAPP/B1 翻译勘误","date":"2021-08-31T12:56:53.000Z","categories_index":"CSAPP","tags_index":"CSAPP","author_index":"Rambo"},{"id":"6995ec6ebd5c76b2ee7554a070e80b76","title":"学习方法随想","content":"学习方法随想在学习过程中，其实有很多自己的经验。但是很多碎片化的经验并不能够帮助自己更好的了解自身和提升效率。于是在2021-08-29 09:51:53阅读【CSAPP 第4章 处理器体系架构】的一个早晨，我决定把自己的学习方法记录下来，期待能够得到一个系统化的学习思路。\n技术型文章阅读在阅读CSAPP这种大部头书籍的过程中很容易走神，我自己的经验是：\n而这种书经常的论述模式有几种\n\n时间线\n计算机发展历史\n……\n\n\n概念性描述\nISA的定义\n……\n\n\n过程描述\n对于整数加法运算整个过程的描述\n\n……\n\n\n内容概述\n本章内容包含……\n\n……\n\n\n\n而对于这几种论述模式，对我而言高效的阅读方法可以是\n\n\n\n\n论述模式\n阅读方法\n\n\n\n\n时间线\n边阅读边做笔记，用typora的mermaid中流程图式的图来表示会更加直观\n\n\n概念性描述\n边阅读边做笔记，用typora的表格来将名词和定义描述分割开来同样的方法可以是【无序列表加冒号】，但看起来不太直观，表格vs有序列表\n\n\n过程描述\n先阅读，后做笔记。搞清楚过程描述的逻辑所在，然后在精简化的做笔记\n\n\n内容概述\n边阅读边做笔记，用typora的有序列表\n\n\n\n\n附录表格vs有序列表\n\n\n\n协议\n端口号\n\n\n\n\nHTTP\nTCP80\n\n\nMail\nTCP25\n\n\nFTP\nTCP2\n\n\n\n\n\nHTTP：TCP80\nMail：TCP25\nFTP：TCP2\n\n","slug":"StudyMethod/学习方法随想","date":"2021-08-29T01:51:53.000Z","categories_index":"Study Method","tags_index":"Study Method","author_index":"Rambo"},{"id":"54eea516d81b966dd64e8dfcff34d389","title":"C4 处理器体系结构","content":"处理器体系结构引入微处理器架构简述\n现代微处理器复杂\n到目前为止，我们看到的计算机系统只限于机器语言程序级\n\n\ngraph LR\n处理器 --执行--> 指令.简单操作  --编码--> 一个或多个字节序列组成的二进制格式\n\n指令集体系结构(ISA)：一个处理器支持的指令和指令的字节级编码\n\nflowchart TD\n编译器编写者 o--概念抽象层--o 处理器设计者\n\n允许哪些指令及其如何编码 o--概念抽象层--o 建造出执行这些指令的处理器\n\n本章内容\n处理器硬件的设计\n硬件系统执行某种ISA指令的方式\n计算机制造商们面临的技术挑战\n\n为什么了解处理器设计？\n处理器设计有趣且重要\n学习事物如何工作有内在价值\n\n\n帮助理解整个计算机系统如何工作\n有助于设计包含处理器的硬件系统\n例如嵌入式开发\n\n\n工作为处理器设计\n\n本章整体逻辑\ngraph TD\n定义一个简单指令集作为处理器实现的运行示例 \n--> 提供一些数字硬件设计的背景\n--> 给出一个基于顺序操作功能正确但并不实用的处理器\n--> pipelined-processor\n--> 设计工具来研究和测试处理器设计\n\nY84-64比x86-64功能少但逻辑简单\n--> 基本构件块及如何连接和操作/HCL简介和应用\n--> 时钟慢且性能低\n--> 将每条指令的执行分解成五步/每个步骤由独立硬件部分或阶段处理\n--> assembler/simulator\n\nY86-64 ISA定义ISA包括\n\n状态单元 different components of its state\n指令集 the set of instructions\n编码 codings\n编程规范 programming conventions\n异常事件处理 the handling of exceptional events\n\nProgrammer-visible state\n\n\n\n\n名词\n含义\n\n\n\n\nProgrammer-visible state\neach instruction in a Y86-64 program can read and modify some part of the processor state\n\n\n“Programmer”\n1.someone writing programs in assembly code2.a compiler generating machine-level code\n\n\nprogram registers\nEach of these stores a 64-bit word\n\n\nsingle-bit condition codes\nstoring information about the effect of the most recent arithmetic or logical instruction\n\n\nprogram counter\nholds the address of the instruction currently being executed\n\n\nmemory\na large array of bytes, holding both program and data\n\n\nstatus code Stat\nindicating the overall state of program execution\n\n\n\n\nInstructions指令这一节讲述了Y86-64 ISA中各个指令的简单描述，即指令集中各条指令的具体作用和编码表示\n\n指令集的功能码fn\n\n程序寄存器标识符ID\n\n注意：\n\n指令集的一个重要性质就是字节编码必须有唯一的解释\n这个性质保证处理器可以无二义性执行目标代码程序\n\nExamplermmovq %rsp,0x123456789abcd(%rdx)\n# register -&gt; memory\n# rmmovq -&gt; 40\n# %rsp -&gt; rA -&gt; 4\n# %rdx -&gt; rB -&gt; 2\n# 0x123456789abcd -&gt; 00 01 23 45 67 89 ab cd\n# -&gt; cd ab 89 67 45 23 01 00 因为Y86-64采用了小端法编码\n故指令的编码为\n4042cdab896745230100\n\n\n\n\n\n\n\n\n\nCISC vs RISC\nRISC更像是一把简单的小刀，通过附魔(流水线结构)增强性能\nCISC更像是一把大的瑞士军刀，本身具有很多的功能\n\n\nARM(Acorn RISC Machine)广泛应用于嵌入式系统中\n两者思想精华结合最好\n\nExceptions\nProgramstest.c\nlong sum(long *start,long count)\n&#123;\n  long sum = 0;\n  while(count)&#123;\n    sum += *start;\n    start++;\n    count--;\n  &#125;\n  return sum;\n&#125;\n\n用Y86-64汇编代码编写的一个完整的程序文件的例子\n\nYAS的汇编器对4-7进行汇编的结果如下图\n\ninstruction set simulator — YIS目的：模拟Y86-64机器代码程序的执行，而不用模拟任何具体处理器实现的行为\n用YIS运行例子的目标代码，产生如下输出：\n\nLogic Design and the Hardware Control Language HCLIntro硬件设计中\n\ngraph LR\n电子电路 --计算--> 对位进行运算的函数\n电子电路 --计算--> 在各种存储器单元中存储位\n\n数字系统 --> 计算对位进行操作的函数的组合逻辑\n\n数字系统 --> 存储位的存储器单元\n\n数字系统 --> 控制存储器单元更新的时钟信号\n\n\n\n\n\n\n\n\n\n\n现代逻辑设计\n\n> graph LR\nHCL直接翻译成Verilog的工具 --> HDL描述 --> 实际工作的微处理器\n\n基本硬件单元的Verilog代码--> HDL描述--> 实际工作的微处理器\n\n\nLogic Gates\nCombinational Circuits and HCL Boolean Expressions\ngraph LR\nGate1 --> computational.block --> Combinational.circuits\nGate2 --> computational.block\n... --> computational.block\nGateN --> computational.block\n\n构建网的限制\n每个逻辑门必须连接到下述之一\n主输入\n某个存储器单元的输出\n某个逻辑门的输出\n\n\n两个或多个逻辑门的输出不能连接在一起\n否则可能信号矛盾\n\n\n网必须是无环的\n回路会导致网络计算的函数有歧义\n\n\n\nMultiplexor,MUX\nbool out = (s &amp;&amp; a) || (!s &amp;&amp; b);\nWord-Level Combinational Circuits and HCL Integer Expressions将逻辑门组合成大的网，构造出能计算更加复杂函数的组合电路；设计能对数据word进行操作的电路\n\n多路复用函数：用case expression描述\n[\nselect1 : expr1;\nselect2 : expr2;\n. . .\nselectk : exprk; \n]\n\nword Out4 = [\n  !s1 &amp;&amp; !s0 : A; #00\n  !s1        : B; #01\n  !s0        : C; #10\n  1\t\t\t\t\t : D; #11\n];\nALU\nSet Membership将一个信号与许多可能匹配的信号做比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码\nMemory and Clocking组合电路从本质上来说不存储信息，只是简单响应输入信号，产生等于输入的某个函数的输出。\n时序电路\n定义：有状态并且在这个状态上进行计算的系统\n操作：引入按位存储信息的设备\n\n存储器设备\n\n\n\n设备\n作用\n\n\n\n\nClocked registers\n存储单个位或字\n\n\nRandom access memories (or simply memories)\n存储多个字用地址来选择该读或写哪个字\n\n\n\n\n寄存器\n\n\n\n类型\n所属范畴\n特点\n\n\n\n\nhardware registers\nhardware\n寄存器直接将它的输入和输出连接到电路的其他部分\n\n\nprogram registers\nmachine-level programming\n寄存器代表的是CPU中为数不多的可寻址的字地址是register IDs这些字通常都存在register file中\n\n\n\n\n操作\n\nregister file\n\n作用\n\n读取2个程序寄存器的地址src及其value，在时钟控制下更新地址为dstW的寄存器的值valW\n\nSequential Y86-64 Implementations起源：每个时钟周期上，SEQ执行处理一条完整指令所需步骤，但是周期很长，故时钟周期频率会很低。而我们想要实现一个高效、流水线化的处理器\nOrganizing Processing into Stages本节目的\n将指令的诸多操作组织成序列框架，从而充分利用硬件\n可行性：每条指令的整个流程比较相似\n必要性(硬件角度需降低复杂度)\n硬件数量尽可能少\n硬件映射到一个二维集成电路芯片的表面\n\n\n实现方法\n指令的诸多操作组织成序列框架\n不同指令共享尽量多的硬件\n\n\n\n\n\n阶段划分\n\n\n\n阶段\n作用\n涉及变量\n\n\n\n\n取指fetch\n从内存读取指令字节，地址为 program counter的值\nicode指令代码ifun指令功能rA寄存器操作数指示符rBvalC四字节常数字\n\n\n译码decode\n从寄存器文件读入最多两个操作数\nvalA/valB\n\n\n执行execute\nALU执行指明的操作、计算内存引用的有效地址、增加或减少栈指针\nvalE\n\n\n访存memory\n将数据写入内存，或者从内存读出数据\nvalM\n\n\n写回write back\n最多可以写两个结果到register file\n\n\n\n更新PC PC update\n将PC设置成下一条指令的地址\n\n\n\n\n指令序列阶段划分\nOpq/rrmovq/irmovq\n对于图4-17中第3行subq指令执行的tracking\n\n\nrmmovq/mrmovq\npushq/popq\n控制转移指令处理jXX Dest/call Dest/ret\nSEQ Hardware Structure\n\nSEQ Timinga single clock transition triggering a flow through combinational logic to execute an entire instruction.\nSEQ的实现(斜黑体为需要对其时序进行明确控制的硬件单元)\n\n组合逻辑\n存储器设备\nClocked register\nProgram Counter\nCondition Code register\n\n\nRandom Access Memory\nInstruction Memory\nRegister File\nData Memory\n\n\n\n\n\ngraph LR\nPC -->每个时钟周期装载新的指令地址\n\nCC --> 执行整数运算指令时装载\n\nDataMemory --> 执行rmmovq/pushq/call时才会写\n\nRegisterFile --> 两个写端口允许每个时钟周期更新两个程序寄存器\n\n\n组织计算的原则\n从不回读 No reading back\n定义：处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态\n\n\n\n\n\nSEQ Stage Implementations设计实现所需要的控制逻辑块的HCL描述\n\nFetch Stage\nDecode and Write-Back Stages\nExecute Stage\nMemory Stage\nPC Update Stage\nSEQ小结\ngraph LR\n将执行不同指令所需的步骤组织成一个统一的流程\n\n--> 用很少量的各种硬件单元以及一个时钟来控制计算的顺序\n\n 缺点 --> 控制逻辑必须在单元间路由信号 --> 太慢 \n 缺点 --> 根据指令类型和分支条件产生适当控制信号 -->太慢\n\n 改进 --> Pipelining\n\nGeneral Principles of PipeliningIntroduction流水线化\n自动洗车/Buffet\n\n允许多个顾客同时经过系统，而不是要等一个用户完成了所有过程才让下一个开始\n必须以相同速度通过这个系统\n\n特点\n\n提高了吞吐量throughput\n增加延迟latency\n\nComputational Pipelines\n\n\nA Detailed Look at Pipeline Operation\nLimitations of Pipelining\n不一致的划分 Nonuniform Partitioning\n流水线过深，收益反而下降 Diminishing Returns of Deep Pipelining\n\n\n\nPipelining a System with Feedback相关类型\n\nData Dependency\nControl Dependency \n\n\n\n\nPipelined Y86-64 Implementations……\n","slug":"CSAPP/C4-处理器体系结构","date":"2021-08-29T01:38:53.000Z","categories_index":"CSAPP","tags_index":"CSAPP","author_index":"Rambo"},{"id":"56f4d97bcf32df033b2c7f1482475692","title":"C3 程序的机器级表示","content":"程序的机器级表示引入\n\n\n\n代码类型\n定义\n\n\n\n\n机器代码\n用字节序列编码低级的操作 包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信\n\n\n汇编代码\n机器代码的文本表示 给出程序中的每一条指令\n\n\n高级语言编程\n机器屏蔽程序的细节，即机器级的实现 抽象级别高，效率高，更可靠 可以在不同机器上编译和执行\n\n\n汇编代码编程\n指定程序用来执行计算的低级指令 与特定机器密切相关\n\n\n\n\nWhy Machine code？\n\n理解编译器的优化能力，分析代码中隐含的低效率\n高级语言提供的抽象层隐藏我们想要了解的程序的run-time behavior\n例如了解不同的线程是如何共享程序数据或保持数据私有的，以及准确知道如何在哪里访问共享数据，都很重要\n\n\n程序遭受攻击时很多涉及程序存储run-time control information\n\n本章\n\n详细学习一种特别的汇编语言\n了解如何将C程序编译成这种形式的机器代码\n\n源代码-汇编代码的关系通常不易理解\n\n逆向工程reverse engineering：通过研究系统和逆向工作，来试图了解系统的创建过程\n\n展开过程\n快速浏览C语言.汇编代码.机器代码之间的关系\n介绍x86-64的细节\n了解如何实现C语言中的控制结构\n过程的实现\n考虑在机器级如何实现数据结构\n讨论内存访问越界的问题\n系统容易遭受缓冲区溢出攻击的问题\nGDB调试器检查机器级程序运行时行为的技巧\n包含浮点数据和操作的代码的机器程序表示\n历史观点程序编码gcc -Og -o p p1.c p2.c\n#GCC C编译器\n#-Og 告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级\n#instructs the compiler to apply a level of optimization \n#that yields machine code that follows the overall structure \n#of the original C code\n#高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码间关系难以理解\n编译器\n汇编器\n链接器\nC预处理器扩展源代码\n插入所有用#include命令指定的文件\n扩展所有用#define声明指定的宏\n生成两个源文件的汇编代码.s\n二进制目标代码文件.o\n可执行代码\n机器级代码机器级编程的两种抽象\n\n\n\n\n抽象\n作用\n\n\n\n\nISA,Instruction Set Architecture\n定义机器级程序的格式和行为，定义了处理器状态、指令的格式，以及每条指令对状态的影响\n\n\nVirtual Addresses\n提供的内存模型看上去是一个非常大的字节数组\n\n\n\n\n机器代码中的处理器\n\n\n\n\n处理器\n状态\n\n\n\n\n程序计数器PC\n给出将要执行的下一条指令在内存中的地址\n\n\n整数寄存器文件\n存储地址或整数数据 有的寄存器用来记录某些重要程序状态，其他用来保存临时数据\n\n\n条件码寄存器\n保存最近执行的算术或逻辑指令的状态信息 用来实现控制或数据流中条件变化\n\n\n一组向量寄存器\n存放一个或多个整数或浮点数值\n\n\n\n\n代码示例示例1mstore.c\nlong mult2(long,long);\n\nvoid multstore(long x,long y,long *dest)&#123;\n    long t &#x3D; mult2(x,y);\n    *dest &#x3D; t;\n&#125;\ngcc -Og -c mstore.c\nmstore.s\n  .section  __TEXT,__text,regular,pure_instructions\n  .build_version macos, 10, 15, 4 sdk_version 10, 15, 4\n  .globl  _multstore              ## -- Begin function multstore\n  .p2align  4, 0x90\n_multstore:                             ## @multstore\n  .cfi_startproc\n## %bb.0:\n  pushq %rbp\n  .cfi_def_cfa_offset 16\n  .cfi_offset %rbp, -16\n  movq  %rsp, %rbp\n  .cfi_def_cfa_register %rbp\n  pushq %rbx\n  pushq %rax\n  .cfi_offset %rbx, -24\n  movq  %rdx, %rbx\n  callq _mult2\n  movq  %rax, (%rbx)\n  addq  $8, %rsp\n  popq  %rbx\n  popq  %rbp\n  retq\n  .cfi_endproc\n                                        ## -- End function\n\n.subsections_via_symbols\n其中\n\n\n\n\n指令\n操作\n\n\n\n\npushq %rbx\n将寄存器%rbx的内容压入程序栈中\n\n\n……\n\n\n\n\ngcc -Og -c mstore.c\n#生成mstore.o\nmstore.o\n\n要想查看需要使用反汇编器disassembler\nobjdump -d mstore.o\n\n\n左边：按照前面给出的字节顺序排列的14个十六进制字节值，分成若干组，每组有1～5个字节\n右边：等价的汇编语言\n\n示例2main.c\n#include&lt;stdio.h>\nvoid multstore(long,long,long *);\n\nint main()&#123;\n    long d;\n    multstore(2,3,&amp;d);\n    printf(\"2 * 3 --> %ld\\n\",d);\n    return 0;\n&#125;\n\nlong  mult2(long a,long b)&#123;\n    long s = a * b;\n    return s;\n&#125;\ngcc -Og -o prog main.c mstore.c\n./prog\n\nobjdump -d prog\n\n与mstore.c反汇编产生的代码区别\n\n左边列出的地址不同\n链接器将这段代码的地址移到了一段不同的地址范围中\n\n\n链接器填上了callq指令调用函数mult2需要使用的地址\n链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置\n\n\n\n关于格式的注解gcc -Og -S -masm&#x3D;intel mstore.c\n#Intel格式的代码\n\n\n\n\n\n\n\n\n\n把C程序和汇编代码结合起来\n\nC编译器在把程序中表达的计算转换到机器代码方面表现出色，但是仍然有一些机器特性是C程序访问不到的\n\n在C程序中插入汇编代码\n\n编写完整函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和用C语言书写的代码合并起来\n使用GCC的内联汇编特性，用asm伪指令可以在C程序中包含简短的汇编代码\n\n\n\n数据格式\nEg:数据传送指令\n\n\n\n\n指令\n含义\n\n\n\n\nmovb\n传送字节\n\n\nmovw\n传送字\n\n\nmovl\n传送双字\n\n\nmovq\n传送四字\n\n\n\n\n访问信息\n\n\n\n注\n\n0-7、7-15……分别为不同机器扩展后对应的名称\n指令可以对寄存器的字节低位中存放的不同大小的数据进行操作\n字节级操作\\to最低字节\n16位操作\\to最低2个字节\n32位操作\\to最低4个字节\n64位操作\\to整个寄存器\n\n\n最特别的栈指针%rsp\n指明运行时栈的结束位置\n\n\n\n操作数指示符\n\n\n\n操作数的类型\n表示\nATT格式的汇编代码\n\n\n\n\n立即数immediate\n常数值\n$后面跟一个用标准C表示的整数 eg：$-577、$0x1F\n\n\n寄存器register\n某个寄存器的内容\nR[r_a]用寄存器标识符索引\n\n\n内存引用\n根据计算出来的地址访问某个内存位置\nM_b[Addr]表示对存储在内存中从地址Addr开始的b个字节值的引用\n\n\n\n\n\n寻址模式\n\n\n\n\n\n\n数据传送指令将数据从一个位置复制到另一个位置的指令\n\n注：\n\n传送指令两个操作数不能都指向内存位置\n要从一个内存到另一个内存则\n两条指令\n\n\n\n\n\n例子\n\n\n\n\n\n\n\n\n\n\n理解数据传送如何改变目的寄存器 \n\nmovabsq #把寄存器%rax初始化为位模式0011223344556677\n$-1 #源操作数为-1\n扩展将较小的源值复制到较大的目的时使用\n\n\n\n\n扩展方式\n指令\n含义\n\n\n\n\nZero-extending\nMOVZ\n把目的中剩余的字节填充为0\n\n\nSigned-extending\nMOVS\n把源操作的最高位进行复制\n\n\n\n\n\n\n数据传送示例exchange.c\nlong exchange(long *xp,long y)\n&#123;\n  long x = *xp;\n  *xp = y;\n  return x;\n&#125;\nexchange.s\n# xp为指针变量,*xp为指针指向内存地址中的内容\n# 一开始xp和y分别存储在寄存器 %rdi和%rsi中\nexchange:\n\tmovq (%rdi),%rax  # x &#x3D; *xp\n\tmovq %rsi,(%rdi)  # *xp &#x3D; y\n\tret \t\t\t\t\t\t\t# return x\n注：\n\nC语言中所谓的指针其实就是地址\n间接引用指针：将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器\n\n压入和弹出栈数据\n算术和逻辑操作\n\n控制条件码除了整数寄存器，CPU还维护着一组单个位的条件码Condition Code寄存器，描述了最近的算术或逻辑操作的属性\n常用条件码\n\n\n\n\n条件码\n标志\n作用\n\n\n\n\nCF\n进位标志\n最近的操作使得最高位产生了进位；可用来检查无符号操作的溢出\n\n\nZF\n零标志\n最近的操作得出的结果为0\n\n\nSF\n符号标志\n最近的操作得到的结果为负数\n\n\nOF\n溢出标志\n最近的操作导致一个补码溢出—正溢出或负溢出\n\n\n\n\n两类只设置条件码而不改变任何其他寄存器\n\n访问条件码条件码通常不会直接读取，常用的三种使用方法\n\n根据条件码的某种组合，将一个字节设置为0或者1\n条件跳转到程序的某个其他的部分\n有条件地传送数据\n\n\n跳转指令跳转指令的编码用条件控制来实现条件分支用条件传送来实现条件分支","slug":"CSAPP/C3-程序的机器级表示","date":"2021-08-26T04:15:53.000Z","categories_index":"CSAPP","tags_index":"CSAPP","author_index":"Rambo"},{"id":"60ed0f7899e93e3dd0dff8a77b279977","title":"C2 信息的表示和处理","content":"信息的表示和处理引入二值信号\n\n容易被表示、存储和传输\n\n位的组合加解释(group bits together and apply some interpretation)\n\n能够表示任何有限集合的元素\n\n三种重要数字表示\n\nunsigned：基于传统的二进制表示法，表示大于或者等于0的数字\nTwo’s-complement：表示有符号整数的最常见方式\nFloating-point：表示实数的科学技术法的以2位基数的版本\n\noverflow\n\n原因\n计算机表示法用有限数量的位来对一个数字编码\nComputer representations use a limited number of bits to encode a number\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\n\n\n如何阅读本章\n\n反复阅读原理描述和示例与讨论\n\n信息存储\n\n\n\n名词\n定义\n\n\n\n\n字节byte\n8位的块blocks of 8 bitsthe smallest addressable unit of memory.\n\n\n虚拟内存virtual memory\n机器级程序将内存视为一个非常大的字节数组\n\n\n地址address\n内存的每个字节都由一个唯一的数字来标识\n\n\n虚拟地址空间virtual address space\n所有可能地址的集合\n\n\n\n\n接下来：\ngraph TD\n存储器空间 --编译运行-->更可管理的单元\n--存放-->不同的program.object\n\n十六进制表示法\n字数据大小字长word size：指明指针数据的标称大小\n\n对于字长为$\\omega$位的机器而言，虚拟地址的范围为$0-2^{\\omega}-1$\n\n32位程序vs64位程序\ngcc -m32 prog.c\ngcc -m64 prog.c\n#区别在于程序如何编译，而非其运行的机器类型\n\n寻址和字节顺序跨越多字节的程序对象，需建立两个规则\n\n这个对象的地址是什么\n内存中如何排列这些字节\n\n排列表示一个对象的字节的两种规则\n\n\n\n\n规则\n特点\n应用\n\n\n\n\n小端法 little endian\n最低有效字节在最前面\n大多数Intel兼容机\n\n\n大端法 big endian\n最高有效字节在最前面\nIBM和Oracle大多数机器\n\n\n\n\n举例：变量x的类型为int，位于地址0x100处，十六进制值为0x01234567\n\n字节顺序matters的几种情况\n\n不同类型机器之间通过网络传送二进制数据\n小端法机器产生的数据被发送到大端法机器或者反过来时，接受程序会发现，字里的字节成了反序的\n为避免这类问题，网络应用程序代码编写必须遵守已经建立的关于字节顺序的恶规则\n\n\n阅读表示整数数据的字节序列时\n通常发生在检查机器级程序时\n反汇编器(disassembler)：一种确定可执行程序文件所表示的指令序列的工具\n\n\n编写规避正常的类型系统的程序时\n\n4004d3: 01 05 43 0b 20 00 add %eax,0x200b43(%rip)\n#十六进制字节串01 05 43 0b 20 00是一条指令的字节级表示\n#这条指令把一个字长的数据加到一个值上\n#该值的存储地址由0x200b43加上当前程序计数器的值得到\n#当前程序计数器的值即为下一条将要执行指令的地址\n#取出这个序列最后4个字节 43 0b 20 00 相反的顺序写出得 00 20 0b 43\n#去掉开头的0，得到值 0x200b43\n\n练习题\n\n表示字符串C语言中字符串被编码为一个以null(值为0)字符结尾的字符数组，每个字符都由某个标准编码表示，最常见的是ASCII字符码\ngraph TD\n'12345' --show_bytes--> 31.32.33.34.35.00\n\n十进制数字x的ASCII码$\\to$0x3x\n\n\n\n\n\n\n\n\n\n文字编码的Unicode标准\n\nUnicode字库包括将近100000个字符\n委员会拒绝为Klingon编写语言标准:smile:\nUTF-8表示将每个字符编码为一个字节序列\n\n表示代码int sum(int x,int y)\n&#123;\n  return x + y;\n&#125;\n\n\n指令编码不同，不同机器类型使用不同且不兼容的指令和编码方式\n二进制代码不兼容，很少能在不同机器和操作系统组合之间移植\n\n布尔代数简介\n位向量\n\n运算\n应用：表示有限集合\n$a = [01101001] \\sim A=\\{0,3,5,6\\}$\n\n\n\nC语言中的位级运算\n\n应用：掩码运算\n掩码0xFF：最低的8位为1$\\to$提取最低有效字节\nx = 0x89ABCDEF$\\to$0x000000EF\n\n\n\nC语言中的逻辑运算\n逻辑运算认为所有非零的参数都表示TRUE\nC语言中的移位运算\n\n逻辑右移：左端补k个0\n算术右移：左端补k个最高有效位的值\n\n整数表示\n描述用位来编码整数的两种不同的方式\n一种只能表示非负数\n另一种能够表示负数、零、正数\n\n\n研究扩展或收缩一个已编码整数以适应不同长度表示的效果\n\n\n整型数据类型\n几种编码\n\\vec{x} = [x_{w-1},x_{w-2},\\cdots,x_0]\n\n\n\n编码类型\n数学表达\n表示\n备注\n\n\n\n\n无符号编码\n$B2U_{w}$\n$B2U_w(\\vec{x})=\\sum_{i=0}^{w-1}x_i2^i$\n具有唯一性\n\n\n补码编码\n$B2T_w$\n$B2T_w(\\vec{x})=-x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}x_i2^i$\n具有唯一性\n\n\n反码\n$B2O_w$\n$B2O_w(\\vec{x}) = -x_{w-1}(2^{w-1}-1)+\\sum_{i=0}^{w-2}x_i2^i$\n\n\n\n原码\n$B2S_w$\n$B2S_w(\\vec{x}) = (-1)^{x_{w-1}}·(\\sum_{i=0}^{w-2}x_i2^i)$\n\n\n\n补码转换为无符号数\n$T2U_w$\n$T2U_w(\\vec{x})=\\left\\{ \\begin{aligned} x + 2^w,x&lt;0 \\\\ x,x\\ge0 \\end{aligned} \\right.$\n\n\n\n无符号数转换为补码\n$U2T_w$\n$U2T_w(u)=-u_{w-1}2^w+u$\n$\\vec{u}=U2B_w(u)$\n\n\n\n\nC语言中的有符号数和无符号数显式强制转换\nint tx,ty;\nunsigned ux,uy;\n\ntx = (int) ux;\nuy = (unsigned) ty;\n隐式转换\nint tx,ty;\nunsigned ux,uy;\n\ntx = ux;\nuy = ty;\n扩展一个数字的位表示从一个较小数据类型转换到一个较大的类型\n\n无符号数的zero extension\n补码数的sign extension\n\n截断数字不用额外的位来扩展一个数值，而是减少表示一个数字的位数\n\n截断unsigned\n截断补码数值\n\n关于有符号数和无符号数的建议\n强制转换导致了某些非直观的行为$\\to$程序错误\n不使用无符号数\njava只支持有符号整数\n\n\n\n\n\n整数运算问题\n两个正数相加得到了负数\n$x&lt;y$和$x-y&lt;0$产生不同的结果\n\n无符号加法补码加法浮点数小结","slug":"CSAPP/C2-信息的表示和处理","date":"2021-08-26T04:14:27.000Z","categories_index":"CSAPP","tags_index":"CSAPP","author_index":"Rambo"},{"id":"af14c5521b037875d1206060f4590b98","title":"B1 多文件编译","content":"Ubuntu下g++编译多个*.h和*.cpp文件文件介绍\n\n\n\n文件\n内容\n\n\n\n\nmain.cpp\n主函数\n\n\nmedian.cpp\n用于返回一个序列的中位数\n\n\nmedian.h\nmedian函数声明\n\n\ngrade.cpp\n若干个重载的grade函数函数体\n\n\ngrade.h\ngrade函数声明\n\n\nStudent_info.cpp\n用于返回学生整体信息的函数\n\n\nStudent_info.h\nStudent_info函数声明\n\n\n\n\n文件树生成（Ubuntu18.04）sudo apt install tree\ntree\n\n编译步骤g++ -c *.cpp  # -c Compile and assemble, but do not link.\ng++ *.o -o test # -o  Place the output into &lt;file>.\n./test # run the test 2-binary\n\n\n\n参考链接https://www.jianshu.com/p/e5c6a255076b\nhttp://blog.sina.com.cn/s/blog_6f73b54b0100u92d.html\nhttps://blog.csdn.net/u014797226/article/details/89287931\n","slug":"CPP/B1 多文件编译","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"ddabc27d0a61a83349413c6612afe50d","title":"B2 C++函数调用图生成","content":"C++函数调用图生成(Ubuntu18.04)https://github.com/jmarkowski/codevizsudo apt-get install graphviz\n\ngit clone https://github.com/jmarkowski/codeviz.git\ncd codeviz\nsudo python3 setup.py install\ncd ~/公众号/AcceleratedCpp/Code4\ncodeviz\nxdg-open codeviz.png\n\n\nhttps://github.com/petersenna/codevizgit clone https://github.com/petersenna/codeviz codeviz2\ncd codeviz2\n未完\n参考链接:star: https://github.com/jmarkowski/codeviz\n:star: https://github.com/petersenna/codeviz\nhttps://www.cnblogs.com/lanxuezaipiao/p/3450201.html\nhttps://topic.alibabacloud.com/a/use-graphviz--codeviz-to-generate-a-c---function-call-graph-called-graph_1_31_10069526.html\nhttps://topic.alibabacloud.com/a/use-graphviz--codeviz-to-generate-a-c---function-call-graph-called-graph_1_31_10069526.html\n","slug":"CPP/B2 C++编译函数调用图生成","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"fceb7de2def1c17dcd8f404b9c66b25c","title":"B3 C++菜鸟教程","content":"代码组成结构在 C++ 中，分别使用.h 和.cpp 来定义一个类。\n.h 中存放类的声明，函数原型（放在类的声明中）。\n.cpp 存放函数体。\n也就是说，一个存放声明(declaration)，一个存放定义（definition)。\n如果我们在一个头文件里声明了一个函数，当我们需要定义这个函数（这个定义是唯一的，也就是只能定义一次），或者需要使用这个函数时，我们在 cpp 中需要 include 这个头文件。\n同样地，如果我们在一个头文件里声明了一个类，当我们需要定义类里的成员函数，或者我们需要使用这个类时，我们在 cpp 中需要 include 这个头文件。\n对于类的设计者来说，头文件就像他们和类的使用者的一个合同，编译器会强化这一合同，它会要求你在使用这些类里的函数或结构时必须要声明。\n头文件的include&lt;&gt; 先去系统目录中找头文件，如果没有在到当前目录下找。所以像标准的头文件 stdio.h、stdlib.h 等用这个方法。 \n“ “ 首先在当前目录下寻找，如果找不到，再到系统目录中寻找。 这个用于 include 自定义的头文件，让系统优先使用当前目录中定义的。\n避免使用using namespace std真正的开发过程中， 尽量避免使用 using namespace std; 等直接引入整个命名空间，否则会因为命名空间污染导致很多不必要的问题， 比如自己写的某个函数，名称正好和 std 中的一样， 编译器会不知道使用哪一个， 引起编译报错， 建议使用:\nstd::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;\n等直接由命名空间组合起来的全称。\nC++存储类\nauto\n\n```cppauto f=3.14;      //doubleauto s(“hello”);  //const charauto z = new auto(9); // intauto x1 = 5, x2 = 5.0, x3=’r’;//错误，必须是初始化为同一类型\n- register\n\n  - &#96;&#96;&#96;cpp\n    &#123;\n       register int  miles;\n    &#125;\n\n\n\nstatic\n\nextern\n\nmutable\n\nthread_local (C++11)\n\n\nC++ 函数\n\n\n\n函数类型\n特点\n\n\n\n\n主函数main()\n都有的函数\n\n\n函数声明\n告诉编译器函数的名称、返回类型和参数\n\n\n函数定义\n提供了函数的实际主体\n\n\n\n\n函数声明int max(int num1, int num2);\n函数定义// 函数返回两个数中较大的那个数\n \nint max(int num1, int num2) \n&#123;\n   // 局部变量声明\n   int result;\n \n   if (num1 > num2)\n      result = num1;\n   else\n      result = num2;\n \n   return result; \n&#125;\n调用函数#include &lt;iostream>\nusing namespace std;\n \n// 函数声明\nint max(int num1, int num2);\n \nint main ()\n&#123;\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n   int ret;\n \n   // 调用函数来获取最大值\n   ret = max(a, b);\n \n   cout &lt;&lt; \"Max value is : \" &lt;&lt; ret &lt;&lt; endl;\n \n   return 0;\n&#125;\n \n// 函数返回两个数中较大的那个数\nint max(int num1, int num2) \n&#123;\n   // 局部变量声明\n   int result;\n \n   if (num1 > num2)\n      result = num1;\n   else\n      result = num2;\n \n   return result; \n&#125;\n函数参数\n\n\n\n调用类型\n描述\n\n\n\n\n传值调用\n该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。\n\n\n指针调用\n该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。\n\n\n引用调用\n该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。\n\n\n\n\n传值调用#include &lt;iostream>\nusing namespace std;\n \n// 函数声明\nvoid swap(int x, int y);\n\n// 函数定义\nvoid swap(int x, int y)\n&#123;\n   int temp;\n \n   temp = x; /* 保存 x 的值 */\n   x = y;    /* 把 y 赋值给 x */\n   y = temp; /* 把 x 赋值给 y */\n  \n   return;\n&#125;\n \nint main ()\n&#123;\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n \n   cout &lt;&lt; \"交换前，a 的值：\" &lt;&lt; a &lt;&lt; endl;\n   cout &lt;&lt; \"交换前，b 的值：\" &lt;&lt; b &lt;&lt; endl;\n \n   // 调用函数来交换值\n   swap(a, b);\n \n   cout &lt;&lt; \"交换后，a 的值：\" &lt;&lt; a &lt;&lt; endl;\n   cout &lt;&lt; \"交换后，b 的值：\" &lt;&lt; b &lt;&lt; endl;\n \n   return 0;\n&#125;\n指针调用#include &lt;iostream>\nusing namespace std;\n\n// 函数声明\nvoid swap(int *x, int *y);\n\n// 函数定义\nvoid swap(int *x, int *y)\n&#123;\n   int temp;\n   temp = *x;    /* 保存地址 x 的值 */\n   *x = *y;        /* 把 y 赋值给 x */\n   *y = temp;    /* 把 x 赋值给 y */\n  \n   return;\n&#125;\n\nint main ()\n&#123;\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n \n   cout &lt;&lt; \"交换前，a 的值：\" &lt;&lt; a &lt;&lt; endl;\n   cout &lt;&lt; \"交换前，b 的值：\" &lt;&lt; b &lt;&lt; endl;\n\n   /* 调用函数来交换值\n    * &amp;a 表示指向 a 的指针，即变量 a 的地址 \n    * &amp;b 表示指向 b 的指针，即变量 b 的地址 \n    */\n   swap(&amp;a, &amp;b);\n\n   cout &lt;&lt; \"交换后，a 的值：\" &lt;&lt; a &lt;&lt; endl;\n   cout &lt;&lt; \"交换后，b 的值：\" &lt;&lt; b &lt;&lt; endl;\n \n   return 0;\n&#125;\n引用调用#include &lt;iostream>\nusing namespace std;\n \n// 函数声明\nvoid swap(int &amp;x, int &amp;y);\n\n// 函数定义\nvoid swap(int &amp;x, int &amp;y)\n&#123;\n   int temp;\n   temp = x; /* 保存地址 x 的值 */\n   x = y;    /* 把 y 赋值给 x */\n   y = temp; /* 把 x 赋值给 y  */\n  \n   return;\n&#125;\n \nint main ()\n&#123;\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n \n   cout &lt;&lt; \"交换前，a 的值：\" &lt;&lt; a &lt;&lt; endl;\n   cout &lt;&lt; \"交换前，b 的值：\" &lt;&lt; b &lt;&lt; endl;\n \n   /* 调用函数来交换值 */\n   swap(a, b);\n \n   cout &lt;&lt; \"交换后，a 的值：\" &lt;&lt; a &lt;&lt; endl;\n   cout &lt;&lt; \"交换后，b 的值：\" &lt;&lt; b &lt;&lt; endl;\n \n   return 0;\n&#125;\nLambda 函数与表达式[capture](parameters)->return-type&#123;body&#125;\n[](int x, int y)&#123; return x &lt; y ; &#125;\n数组\n\n\n\n操作\n代码\n\n\n\n\n声明数组\ndouble balance[10];\n\n\n初始化数组\ndouble balance[5] = &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;;\n\n\n访问数组元素\ndouble salary = balance[9];\n\n\n\n\n\n\n\n\n概念\n描述\n\n\n\n\n多维数组\nC++ 支持多维数组。多维数组最简单的形式是二维数组。\n\n\n指向数组的指针\n您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。\n\n\n传递数组给函数\n您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。\n\n\n从函数返回数组\nC++ 允许从函数返回数组。\n\n\n\n\n#include &lt;iostream>\nusing namespace std;\n \nint main ()\n&#123;\n   // 带有 5 个元素的双精度浮点型数组\n   double runoobAarray[5] = &#123;1000.0, 2.0, 3.4, 17.0, 50.0&#125;;\n   double *p;\n \n   p = runoobAarray;\n \n   // 输出数组中每个元素的值\n   cout &lt;&lt; \"使用指针的数组值 \" &lt;&lt; endl; \n   for ( int i = 0; i &lt; 5; i++ )\n   &#123;\n       cout &lt;&lt; \"*(p + \" &lt;&lt; i &lt;&lt; \") : \";\n       cout &lt;&lt; *(p + i) &lt;&lt; endl;\n   &#125;\n \n   cout &lt;&lt; \"使用 runoobAarray 作为地址的数组值 \" &lt;&lt; endl;\n   for ( int i = 0; i &lt; 5; i++ )\n   &#123;\n       cout &lt;&lt; \"*(runoobAarray + \" &lt;&lt; i &lt;&lt; \") : \";\n       cout &lt;&lt; *(runoobAarray + i) &lt;&lt; endl;\n   &#125;\n \n   return 0;\n&#125;\n指针","slug":"CPP/C++菜鸟教程","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"cad1a665aa5f56e359146a1c745e5ca7","title":"C0 开始","content":"开始程序源码//Hello world\n#include&lt;iostream>\nint main()\n&#123;\n  std::cout &lt;&lt; \"Hello,World\" &lt;&lt; std::endl;\n  return 0;\n&#125;\n各部分含义\n\n\n\n命令\n含义\n\n\n\n\n//\n注释\n\n\n#include&lt;iostream&gt;\n包含标准头文件并使用相关库提供的功能(like宏包)\n\n\nint main\n请求C++实现运行程序时，调用主函数响应要求返回整数类型的值作为结果，告知编译器是否成功运行\n\n\n&#123;&#125;\n花括号告诉编译器将它们之间的内容当作一单元处理花括号表明在它们之间所有语句隶属于同一个函数\n\n\n&lt;&lt;\n标准库的输出运算符\n\n\nstd::\n表明这个名称是一个名为std名称空间的一部分标准头文件iostream定义了名称cout和endl\n\n\n名称空间\n相关名称的集合\n\n\nstd::cout\n标准输出流\n\n\nreturn 0;\n在其出现的位置终止函数的执行，并将一个值返回给调用这个函数的程序返回值类型必须与函数声明的返回类型一致\n\n\n;\n丢掉返回值，只对副作用感兴趣\n\n\n\n\n进一步深入表达式\n使得编译器对某些事物进行运算\n结果\n产生的值为std::cout\n\n\n副作用\n将Helloworld写到标准输出流并结束输出行\n\n\n\n\n包含操作数和运算符\n操作数\nstd::cout\n&quot;Hello,World!&quot;\nstd::endl\n控制器：如果将一个控制器写入到流中，就可以控制这个流\n\n\n\n\n运算符\n&lt;&lt;\n\n\n\n\n\n作用域\n只有在这一部分中的这个名称是有意义的\n此处涉及到两种作用域\n名称空间\n相关名词的集合\n\n\n花括号\n\n\n限定名称std::cout\n::作用域运算符\n\n\n\n小结\n\n\n\n名词\n定义\n\n\n\n\n程序结构\nC++程序通常具有自由风格只是在防止相邻符号混在一起时，才使用空白符\n\n\n类型\n定义了数据结构以及对这些数据结构的操作\n\n\n名称空间\n把相关名词聚集在一起的技术\n\n\n字符串字面量\n“”之间的\n\n\n定义和头文件\nC++程序使用的每一个名称都必须具有一个相应的定义标准库在头文件中定义它的名称\n\n\n住函数\n必须且只能定义一个main函数，返回一个int类型的值\n\n\n\n\n练习题问题\n\n\n","slug":"CPP/C0 开始","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"86a055ce60f57b41bde29b259c469871","title":"C00 前言","content":"前言全新的C++编程方法\n高级数据结构开始$\\to$数据结构所依赖的基础进行解释$\\to$地道C++\n集中注意力解决问题，而非专门探究语言与库的特征\n\n初学者和熟练程序员均可获益\n从开始就使用标准库\n掌握高效使用各种语言的细节知识后，才对细节深入探讨\n\n抽象\n能够忽略细节的能力是成熟技术所具有的特征之一\n抽象：可供选择的忽略（将注意力集中在与手头上的任务相关的概念，忽略其他微小方面）\n哪些问题重视，哪些问题忽略\n\n\n在使用C++之前也不必一定要了解C++如何工作的细节\n\n本书覆盖范围\n本书基本涵盖工作中所需的所有工具\n介绍标准C++而忽略其他专门知识的延伸\n\n对熟练的C和C++程序员的提醒\n一开始就使用C++标准库高级抽象\n\n本书结构\nC0-C7 注意力集中在使用标准库抽象的程序上\nC8-末尾 定义属于自己的抽象\n\nC++的库是什么？\n","slug":"CPP/C00 前言","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"d469c0aa6900bf80ac5103ca8bfe40c5","title":"CPP1 字符串的使用","content":"字符串的使用输入#include&lt;iostream>\n#include&lt;string>\n\nint main()\n&#123;\n  //请某人输入其姓名\n  std::cout &lt;&lt; \"Plz Enter ur name:\" ;\n\n  //读姓名\n  std::string name; //定义变量name\n  std::cin >> name;//将姓名读进name\n\n  //输出对该人的问候语\n  std::cout &lt;&lt; \"Hello,\" &lt;&lt; name &lt;&lt; \"!\" &lt;&lt; '\\n';\n  return 0;\n&#125;\n\n\n\n\n名词\n定义\n\n\n\n\n变量\n具有名称的对象为了读入输入必须找个地方存放他，这样的地方就叫变量\n\n\n对象\n计算机中一段具有类型的内存空间\n\n\n接口\n可实现的操作的集合\n\n\n\n\n使用一个变量 std::string name\n\n告诉系统环境它应该有一个什么样的名称\n我们希望它所具有的类型\n提供名称和类型的请求会让系统环境更加方便地为程序产生高效的机器代码\n这个请求同时也会让编译器检测到拼写错误的变量名称\n\n局部变量name\n\n定义存活在花括号括起的程序运行期内\n一旦程序运行到”}”，变量name被销毁，同时这个变量所占用的全部内存也会被系统回收而用于其他用途\n\n输入操作std::cin&gt;&gt;name;\ngraph TD\n从标准输入读进一个词\n--> 将构成这个词的字符存储在`name`变量中\n从标准输入读进一个词 --> 产生一个出现在计算机输出装置上的提示\n--> 输入/输出库将它的输出保存在buffer --为减少对应每个输出请求的写操作的系统开销-->库使用缓冲区来累积待写的字符\n\n--只在有必要的时候-->将缓冲区的内容写到输出装置中从而刷新缓冲区\n\n\n\n\n\n\n\n\n\n\n刷新buffer的三种事件\n\n缓冲区已满 -&gt; 自动刷新\n请求库从标准输入流中读数据 -&gt; 不用等到buffer满就可以刷新\n明确要求刷新\n\n新的输出std::cout &lt;&lt; &quot;Hello,&quot; &lt;&lt; name &lt;&lt; &quot;!&quot; &lt;&lt; &#39;\\n&#39;;\n\n明确命令库刷新缓冲区\n\n\n\n\n\n\n\n\n\n\n编写大量时间运行的程序\n\n养成适当时刻刷新缓冲区的好习惯\n否则有些程序输出长时间滞留在缓冲区中\n\n将姓名装框#include&lt;iostream>\n#include&lt;string>\n\nint int main() &#123;\n  std::cout &lt;&lt; \"Please Enter your name:\";\n  std::string name;\n  std::cin >> name;\n\n  const std::string greeting = \"Hello,\" + name + \"!\";\n\n  const std::string spaces(greeting.size(),'');\n  const std::string second = \"*\" + spaces + \"*\";\n\n  const std::string first(second.size(),'*');\n\n  std::cout &lt;&lt; std::endl;\n  std::cout &lt;&lt; first &lt;&lt; std::endl;\n  std::cout &lt;&lt; second &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"*\" &lt;&lt; greeting &lt;&lt; \"*\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; second &lt;&lt; std::endl;\n  std::cout &lt;&lt; first &lt;&lt; std::endl;\n\n  return 0;\n&#125;\ngreeting变量的定义中包含3个新的概念\n\n定一个一个变量时，可以赋给它一个值\n如果变量具有不同的类型，系统环境将初始值的类型转换成变量的类型\n\n\n可以用“+”将一个字符串和一个字符串字面量连接起来\nConst可以作为变量定义的一部分\n保证在变量的生存期内我们不会改变它的值\n⚠️：如果说一个变量是常量，必须在定义它的时候对其进行初始化\n\n\n\nconst std::string spaces(greeting.size(),&#39;&#39;);\n\ngreeting.size()调用成员函数的例子\n名为greeting的对象有一个被称为size的实际为函数的成员\n字符字面量 -&gt; ‘’\n字符串字面量 -&gt; “”\n\n\n\n","slug":"CPP/C1 字符串的使用","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"f33231007a38d63e975cc1fea425a1a6","title":"CPP10 管理内存与低级数据结构","content":"管理内存与低级数据结构由于使用标准库无法解决全部问题，因此非常多的C++程序经常使用“低级”技巧\n本章\n\n数组和指针\nnew和delete表达式动态地对内存进行分配\n\n指针与数组\n\n\n\n名词\n定义\n\n\n\n\n数组\n容器的一种，与向量类似，但没有向量功能那么强大\n\n\n指针\n随机存取的迭代器，可用于存取数组中的元素\n\n\n\n\n指针\n\n\n\n代码\n含义\n运算符\n\n\n\n\n&amp;x\n对象x的地址\n&amp;为求址运算符\n\n\n*p\n对象本身，其中p是一个对象的地址\n*为间接引用运算符\n\n\n\n\nint main()\n&#123;\n  int x = 5;\n  \n  int* p = &amp;x; //&amp;x为x的地址，\n  cout &lt;&lt; \"x=\" &lt;&lt; x &lt;&lt; endl;\n  \n  *p = 6;//*p为对象本身\n  cout &lt;&lt; \"x=\" &lt;&lt; x &lt;&lt; endl;\n  return 0;\n&#125;\n指向函数的指针template&lt;class In,class Pred>\nIn find_if(In begin,In end,Pred f)\n&#123;\n  while(begin != end &amp;&amp; !f(*begin))\n    ++begin;\n  return begin;\n&#125;\n数组\n容器的一种，但是核心语言的一部分而非标准库的内容\n数组元素个数必须在编译时确定，不能像其他容器一样动态增加或减少\n不是类，故没有成员函数和成员变量\n没有size_type,而有size_t\n\n\n\ndouble corrds[3]\n  \n//更好的定义\nconst size_t NDim = 3;\ndouble coords[NDim];\n指针算法vector&lt;double> v;\ncopy&lt;coords,coords+NDim,back_inserter(v));\n索引数组初始化字符串字面量回顾字符串字面量本质上是一个字符字面量数组\nconst char hello[] = &#123;'H','E','L','L','O','\\0'&#125;\n初始化字符串指针数组string letter_grade(double grade)\n&#123;\n  //分数成绩的界限\n  static const double numbers[] = &#123;\n    97,94,90,87,84,80,77,74,70,60,0\n  &#125;;\n  \n  //字母成绩表示\n  static const char* const letters[]= &#123;\n    \"A+\",\"A\",\"A-\",\"B+\",\"B\",\"B-\",\"C+\",\"C\",\"C-\",\"D\",\"F\"\n  &#125;;\n  \n  //根据数组的大小计算成绩的个数\n  //和单个元素的大小\n  static const size_t ngrades = sizeof(numbers)/sizeof(*numbers);\n  \n  //根据分数成绩得到相应的字母成绩\n  for(size_t i = 0; i &lt; ngrades; ++i)&#123;\n    if (grade >= numbers[i])\n      return letters[i];\n  &#125;\n  return \"?\\?\\?\";\n&#125;\n\nstatic保证了编译器在使用数组之前只需要进行一次初始化\n\nmain函数的参数#include&lt;iostream>\n\nusing namespace std;\n\nint main(int argc, char** argv)\n&#123;\n  if (argc > 1)&#123;\n    cout &lt;&lt; argv[1];\n    for (int i = 2; i != argc; ++i)\n      cout &lt;&lt; \" \" &lt;&lt; argv[i];\n  &#125;\n  cout &lt;&lt; endl;\n  return 0;\n&#125;\ng++ say.cpp -o say\n./say hello world\n\n文件读写#include&lt;iostream>\n#include&lt;fstream>\n\nusing namespace std;\n\nint main(int argc,char **argv)\n&#123;\n    int fail_count = 0;\n\n    for (int i = 0; i &lt; argc; i++)\n    &#123;\n        ifstream in(argv[i]);\n\n        if (in)\n        &#123;\n           string s;\n           while(getline(in,s))\n           cout &lt;&lt; s &lt;&lt; endl;\n        &#125;else&#123;\n            cerr &lt;&lt; \"cannot open file\" &lt;&lt; argv[i] &lt;&lt; endl;\n            ++fail_count;\n        &#125;\n        \n    &#125;\n    return fail_count;\n&#125;\n","slug":"CPP/C10 管理内存与低级数据结构","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"6f7b722034727aa8d501a289bcdc43b2","title":"CPP11 定义抽象数据类型","content":"定义抽象数据类型\n创建一个类似于向量的类以加深我们对如何设计和实现一个类的理解\n先写一些简单的成员函数，再回来看看如何控制进行复制、赋值以及删除操作\n\nVec类开始设计类时，通常需要首先确定要在类中提供什么样的接口$\\to$研究类的使用者将用我们所写的类编写什么样的程序，比如说：\n//构造一个vector\nvector&lt;Student_info> vs; //一个空的vector\nvector&lt;double> v(100); //一个有100个元素的vector\n\n//获得vector使用的类型的名称\nvector&lt;Student_info>::const_iterator b,e;\nvector&lt;Student_info>::size_type i = 0;\n\n//使用size函数与索引值查看vector中的元素\nfor (i = 0; i != vs.size(); ++i)\n    cout &lt;&lt; vs[i].name();\n\n//返回指向第一个元素的迭代器与指向最后一个元素后面那个元素的迭代器\nb = vs.begin();\ne = vs.end();\n包含的几个操作\n\n构造一个空vector\n构造一个有固定元素的vector\n获得vector使用的类型的名称\nsize函数与索引值查看vector中元素\n迭代器操作\n\n最终Vec类\n首先定义一个模板类\n然后根据提供的参数用这个模板类生成一系列不同的类\n\n定义一个模板类\n\n列出了类定义中将要用到的全部类型的参数\nVec为一个具有一个类型参数T的模板类\n模版定义分为public和private两部分\npublic接口\ntypedef\n构造与析构\n构造\n复制构造\n类的作者可以控制对象被创建、复制以及被销毁时程序的行为\n\n\n析构\n\n\n大小与索引\n索引运算符重载\n\n\n赋值运算符\n动态Vec类型对象\n向Vecs类中加入一个push_bach函数，为Vec类的对象分配新的内存\n\n\n灵活内存管理\n\n\nprivate实现\n元素\n内存分配工具\n\n\n\n\n\ntemplate &lt;class T> class Vec&#123;\n  public:\n  \t//接口\n  \n  \t/*typedef主要是？？*/\n  \ttypedef T* iterator;\n  \ttypedef const T* const_iterator;\n  \ttypedef size_t size_type;\n  \ttypedef T value_type;\n  \ttypedef std::ptrdiff_t difference_type;\n  \ttypedef T&amp; reference;\n  \ttypedef const T&amp; const_reference;\n  \t\n  \t//默认构造函数\n  \tVec()&#123;create();&#125; \n    //explicit用于修饰只有一个参数的类构造函数,\n  \t//它的作用是表明该构造函数是显式的, 而非隐式的\n  \texplicit Vec(std::size_t n, const T&amp; val = T()) &#123;create(n,val);&#125;\n   \t//复制构造函数\n  \t//从一个已存在的对象中\"复制\"每个数据元素到一个新对象中\n  \t//Vec(const Vec&amp; v);\n  \tVec(const Vec&amp; v) &#123;create(v.begin(),v.end());&#125;\n    //析构函数\n  \t~Vec() &#123;uncreate();&#125;\n\n  \t//大小与索引\n  \t//size_type size() const &#123;return limit - data;&#125;\n  \tsize_type size() const &#123;return avail - data;&#125;\n  \tT&amp; operator[](size_type i) &#123;return data[i];&#125;\n  \tconst T&amp; operator[](size_type i) const &#123;return data[i];&#125;\n  \n  \t//返回迭代器\n  \titerator begin() &#123;return data;&#125;\n  \tconst_iterator begin() const &#123;return data;&#125;\n  \t//iterator end() &#123;return limit;&#125;\n  \titerator end() &#123;return avail;&#125;\n  \t//const_iterator end() &#123;return limit;&#125;\n  \tconst_iterator end() &#123;return avail;&#125;\n  \n  \t//赋值运算符\n  \tVec&amp; operator=(const Vec&amp;);\n  \n  \t//动态内存管理\n  \tvoid push_back(const T&amp; val)&#123;\n      if(avail == limit)\n      \tgrow();\n      unchecked_append(val);\n    &#125;\n  \n  private:\n  \t//实现\n  \n  \t//T* data; //Vec中的首元素\n  \t//T* limit;//Vec中的末元素\n  \titerator data;\n  \titerator limit;\n  \titerator avail;\n  \n  \t//内存分配工具\n  \tallocator&lt;T> alloc; //控制内存分配的对象\n  \t//为底层数组分配空间并对它进行初始化\n  \tvoid create();\n  \tvoid create(size_type,const T&amp;);\n  \tvoid create(const_iterator,const_iterator);\n  \t//删除数组中的元素并释放其占用的内存\n  \tvoid uncreate();\n  \t//支持push_bach的函数\n  \tvoid grow();\n  \tvoid unchecked_append(const T&amp;);\n&#125;;\n实现用于内存分配的私有成员函数template &lt;class T> void Vec&lt;T>::create()\n&#123;\n  data = avail = limit = 0;\n&#125;\n\ntemplate &lt;class T> void Vec&lt;T>::create(size_type n,const T&amp; val)\n&#123;\n  data = alloc.allocate(n);\n  limit = avail = data + n;\n  uninitialized_fill(data,limit,val);\n&#125;\n\ntemplate &lt;class T> void Vec&lt;T>::create(const_iterator i, const_iterator j)\n&#123;\n  data = alloc.allocate(j - i);\n  limit = avail = uninitialized_copy(i,j,data);\n&#125;\nuncreate\ntemplate &lt;class T> void Vec&lt;T>::uncreate()\n&#123;\n  if(data)&#123;\n    iterator it = avail;\n    while(it != data)\n      alloc.destroy(--it);\n    \n    alloc.deallocate(data,limit-data);\n  &#125;\n  data = limit = avail = 0;\n&#125;\ngrow\ntemplate &lt;class T> void Vec&lt;T>::grow()\n&#123;\n  size_type new_size = max(2*(limit - data),ptrdiff_t(1));\n  \n  iterator new_data = alloc.allocate(new_size);\n  iterator new_avail = uninitialized_copy(data,avail,new_data);\n  \n  uncreate();\n  \n  data = new_data;\n  avail = new_avail;\n  limit = data + new_size;\n&#125;\nunchecked_append\ntemplate &lt;class T> void Vec&lt;T>::unchecked_append(const T&amp; val)\n&#123;\n  alloc.construct(avail++,val);\n&#125;\n复制控制类的作者可以控制对象被创建、复制以及被销毁时程序的行为\n赋值运算符自我赋值template &lt;class T>\nVec&lt;T>&amp; Vec&lt;T>::operator=(const Vec&amp; rhs)\n&#123;\n  //判断是否进行自我赋值\n  if(&amp;rhs != this)&#123;\n    //删除运算符左侧的数组\n    uncreate();\n    \n    //从右侧复制元素到左侧\n    create(rhs.begin(),rhs.end());\n  &#125;\n  return *this;\n&#125;\n涉及到两个新概念\n\n在除了类的头文件以外的地方定义一个模板成员函数的语法\nthis\n只在成员函数内部才有效，代表指向函数操作的对象的指针\n\n\n\n灵活的内存管理不希望使用new和delete管理内存，因为这样写出的Vec类使用起来受到许多限制，不如标准向量类使用范围那么广泛。\n","slug":"CPP/C11 定义抽象数据类型","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"32d2985524fbdfade0b6b9e9b6071676","title":"CPP12 使类对象获得数值功能","content":"使类对象获得数值功能\n定义了自己的类之后，就可以控制对类进行的扩展，使其对象可以想数值一样工作\nBox3 = Box1 + Box2\n\n\n类的编写者可以设法让各个对象之间彼此保持独立\n上一章我们在写Vec类时已经完成大部分工作\n本章大部分讨论如何为Str类设计一个友好的接口\n\n一个简单的string类str.h\nclass str&#123;\npublic:\n    typedef Vec&lt;char>::size_type size_type;\n\n    //默认构造函数,创建一个空str\n    Str()&#123;&#125;\n\n    //生成一个str对象，包含c的n个副本\n    Str(size_type n,char c):data(n,c)&#123;&#125;\n\n    //生成一个str对象并使用一个空字符结尾的字符数组来初始化\n    Str(const char* cp)&#123;\n        std::copy(cp,cp+std::strlen(cp),std::back_inserter(data));\n    &#125;\n\n    //生成一个str对象并使用迭代器b和e之间的内容对它进行初始化\n    template&lt;class In>Str (In b,In e)&#123;\n        std::copy(b,e,std::back_inserter(data));\n    &#125;\nprivate:\n    Vec&lt;char> data;\n&#125;\n\n定义了一组构造函数并隐式地定义了复制、赋值和析构函数\n使得Str类型对象使用起来如同一个值一样：复制Str类型对象时，源对象与其复制出来的对象彼此独立\n\n\n\n自动转换Str t = \"hello\";\n//调用一个参数类型为const Str&amp;的复制构造函数类初始化t\n\ns = \"hello\";\n//表达式语句，将一个新的值赋给s\n在写出s = &quot;hello&quot;这样的表达式时，编译器实际上调用Str(const char*)构造函数为这个字符串字面量构造出一个没有名称、局部的、临时的Str类型对象，然后再调用编译器自动生成的复制运算符函数将这一临时值赋给s\nstr操作cin >> s;\ncout &lt;&lt; s;\ns[i];\ns1 + s2;\n索引运算符函数class Str&#123;\npublic:\n\t//构造函数\n\tchar&amp; operator[](size_type i) &#123;return data[i];&#125;\n\tconst char&amp; operator[](size_type i) const &#123;return data[i];&#125;\n\nprivate:\n\tVec&lt;char> data;\n&#125;;\n输出运算符函数\n函数声明\n\nstd::istream&amp; operator>>(std::istream&amp;,Str&amp;);\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp;,const Str&amp;);\n\n函数定义：使用一个迭代器遍历Str类中的每个元素，每次输出一个单个的字符\n\nostream&amp; operator&lt;&lt;(ostream&amp; os,const Str&amp; s)\n&#123;\n  for(Str::size_type i = 0; i != s.size(); ++i)\n    os &lt;&lt; s[i];\n  return os;\n&#125;\n\nStr类增加一个size函数\n\nclass Str&#123;\npublic:\n  size_type size() const &#123;return data.size();&#125;\n  //其他同前\n&#125;;\n输入运算符函数\n函数定义\n\nistream&amp; operator>>(istream&amp; is,Str&amp; s)\n&#123;\n  //抹去存在的值(s)\n  s.data.clear();\n  //按序读字符并忽略前面的空格字符\n  char c;\n  while(is.get(c) &amp;&amp; isspace(c));\n  \n  //如果读到非空格字符，重复以上操作直到遇到一个空格字符为止\n  if(is)&#123;\n    do s.data.push_back(c);\n    while (is.get(c) &amp;&amp;i !issapce(c));\n    \n    if(is)\n      is.unget();\n  &#125;\n  return is;\n&#125;\n\n输入运算符函数声明为Str类的一个友元函数\n可以访问Str类的私有数据成员\n\n\n\nclass Str&#123;\n  friend std::istream&amp; operator>>(std::istream&amp;,Str&amp;);\n  //其余同前\n&#125;;\n其他二元运算符+=\nclass Str&#123;\n  friend std::istream&amp; operator>>(std::istream&amp;,Str&amp;);\npublic:\n  Str&amp; operator+=(const Str&amp; s)&#123;\n    std::copy(s.data.begin(),s.data.end(),std::back_inserter(data));\n    return *this;\n  &#125;\n  \n  typedef Vec&lt;char>::size_type size_type;\n  Str() &#123;&#125;\n  Str(size_type n,char c):data(n,c) &#123;&#125;\n  Str(const char* cp)&#123;\n    std::copy(cp,cp+std::strlen(cp),std::back_inserter(data));\n  &#125;\n  template&lt;class In> Str(In b,In e)&#123;\n    std::copy(b,e,std::back_inserter(data));\n  &#125;\n  char&amp; operator[](size_type i)&#123;return data[i];&#125;\n  const char&amp; operator[](size_type i)const &#123;return data[i];&#125;\n  size_type size() const &#123;return data.size();&#125;\n  \nprivate:\n  Vec&lt;char> data;\n&#125;\n用+=实现+\nStr operator+ (const Str&amp; s,const Str&amp; t)\n&#123;\n  Str r = s;\n  r += t;\n  return r;\n&#125;\n","slug":"CPP/C12使类对象获得数值功能","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"f1fd64304e69297c15b134a3ddae98c2","title":"CPP13 继承与动态绑定的使用","content":"继承与动态绑定的使用继承成绩问题中，研究生学分成绩的记录与本科生的学分成绩记录基本一致，唯一差别在于研究生学分成绩记录添加了一个与论文相关的属性。对于这种关系来说，最自然的解决办法就是使用继承(inheritance)\n定义两个类\n\n一个类集成一些核心的公共操作\n另一个类增加了与研究生学分成绩有关的操作\n\ncore_class.h\nclass Core&#123;\npublic:\n  \t//构造函数\n    Core();\n    Core(std::istream&amp;)\n      \n    //成员函数\n    std::string name() const;\n    std::istream&amp; read(std::istream&amp;);\n    double grade() const;\nprivate:\n    std::istream&amp; read_common(std::istream&amp;);\n    std::string n;\n    double midterm,final;\n    std::vector&lt;double> homework;\n&#125;;\ngrad_class.h\n\n新定义名为Grad的新类型\n与Core的关系\n派生\n继承\n基类\nCore的每个成员(除构造函数、赋值运算符函数和析构函数外)都是Grad的成员\nGrad可以加入自己的成员\nthesis\n构造函数\n\n\nGrad可以重定义基类中的成员\ngrade\nread\n\n\nGrad不可以删除任何基类成员\n\n\n\n//此处的public关键字表明Grad类从Core类派生出来\n//Grad将Core的公有接口继承过来用于作为Grad公有接口的一部分\nclass Grad:public Core&#123; \npublic:\n  \t//构造函数\n    Grad();\n    Grad(std::istream&amp;);\n  \n  \t//成员函数\n    double grade() const;\n    std::istream&amp; read(std::istream&amp;);\nprivate:\n    double thesis;\n&#125;\n回顾保护类型问题：\n\nCore类中的全部4个成员数据以及read_common成员函数都不能被Grad类中的成员函数所访问\n只有这个类本身与它的友元可以对该类的私有成员进行访问\n要实现Grad类中的grade函数与read函数，必须能够访问Core类中的私有成员\n\n解决方案：使用protection关键字重新编写Core类\ncore_class_protected.h\n\nprotected关键字\n为Grad这样的派生类赋予了访问基类中保护成员的权力\n同时又能够使这些成员不被类的其他使用者所访问\n\n\n\nclass Core&#123;\npublic:\n    Core();\n    Core(std::istream&amp;)\n    std::string name() const;\n    std::istream&amp; read(std::istream&amp;);\n    double grade() const;\n\nprotected:\n    std::istream&amp; read_common(std::istream&amp;);\n    double midterm,final;\n    std::vector&lt;double> homework;\n\nprivate:\n    std::string n;\n    /*\n    std::istream&amp; read_common(std::istream&amp;);\n    double midterm,final;\n    std::vector&lt;double> homework;\n    */\n&#125;;\n操作函数问题：为了完成我们的类，还需要编写4个构造函数和6个操作函数\n\n构造函数\nCore类默认构造函数\nCore类带istream类型参数的构造函数\nGrad类默认构造函数\nGrad类带istream类型参数的构造函数\n\n\n操作函数\nCore类中的name与read_common函数\nCore类中的read与grade函数\nGrad类中的read与grade函数\n\n\n\n解决：\nCore类中的操作函数core_class_func.cpp\nstring Core::name() const &#123;return n;&#125;\n\n//Core类的操作函数\n\n//Core::name\nstring Core::name() const &#123;return n;&#125;\n\n//Core::grade\ndouble Core::grade() const\n&#123;\n    return::grade(midterm,final,homework);\n&#125;\n\n//Core::read_common\nistream&amp; Core::read_common(istream&amp; in)\n&#123;\n    //读出学生的姓名与考试成绩并储存起来\n    in >> n >> midterm >> final;\n    return in;\n&#125;\n\n//Core::read\nistream&amp; Core::read(istream&amp; in)\n&#123;\n    read_common(in);\n    read_hw(in,homework);\n    return in;\n&#125;\nGrad类中的操作函数grad_class_func.cpp\n//Grad类的操作函数\n\n//Grad::read\nistream&amp; Grad::read(istream&amp; in)\n&#123;\n    Core::read_common(in);\n    in >> thesis;\n    read_hw(in,Core::homework);\n    return in;\n&#125;\n\n//Grad::grade\ndouble Grad::grade() const\n&#123;\n    return min(Core::grade(),thesis);\n&#125;\n构造函数派生类对象在构造时经过的步骤\n\ngraph TD\n为整个对象分配内存空间.包括基类与派生类中定义的数据\n--> 调用基类的构造函数以便初始化对象中的基类部分数据\n--> 使用构造初始化器对对象的派生类部分数据进行初始化\n--> 如果有的话执行派生类构造函数的函数体\n\n如何选择调用基类中的哪一个构造函数\n\ngraph TD\n初始化\n-->使用构造初始化器指定想要调用的基类构造函数\n--> 在派生类的构造初始化器中使用它的基类名\n-->在基类名后附上一个参数列表\n-->参数用于构造对象中基类部分的初始值\n-->同时编译器根据参数的个数与类型选择调用基类中的哪一个构造函数\n\n初始化-->初始化时没有指定调用基类中的哪一个构造函数\n--> 编译器调用基类默认构造函数以构造对象的基类部分\n\n//Core构造函数\n\nclass Core&#123;\npublic:\n    //Core类的默认构造函数\n    Core():midterm(0),final(0)&#123;&#125;\n    //使用一个istream类型变量构造一个core对象\n    Core(std::istream&amp; is)&#123;read(is);&#125;\n&#125;;\n\n//Grad构造函数\n\nclass Grad:public Core&#123;\npublic:\n    //两个构造函数均隐式地调用Core::Core()函数，以初始化对象中的基类部分\n    Grad():thesis(0)&#123;&#125;\n    Grad(std::istream&amp; is) &#123;read(is);&#125;\n&#125;;\n多态与虚函数虚函数我们希望系统根据实际传递给函数的参数类型来运行正确版本的 grade函数，而参数类型只有到运行时才是已知的。\nclass Core&#123;\npublic:\n  virtual double grade() const;\n&#125;;\n\ngrade是一个虚函数\n\n调用compare_grades函数，程序执行时由参数c1和c2的实际类型决定调用哪个grade函数\n\n参数为Grad类型对象，调用Grad::grade函数\n\n```cppbool compare_grades(const Grad&amp; c1,const Grad&amp; c2){  return c1.grade() &lt; c2.grade();}\n- 参数为&#96;Core&#96;类型对象，调用&#96;Core::grade&#96;函数\n\n  - &#96;&#96;&#96;cpp\n    bool compare_grades(const Core&amp; c1,const Core&amp; c2)\n    &#123;\n      return c1.grade() &lt; c2.grade();\n    &#125;\n\n\n\n\n\n\n动态绑定\n\n\n\n绑定类型\n特点\n参数类型\n\n\n\n\n动态绑定\n指在运行时才决定调用什么函数，而不是编译时候就决定下来\n指针或引用\n\n\n静态绑定\n以一个对象的名义调用一个虚拟函数，即在编译时就被绑定好\n对象\n\n\n\n\nCore c;\nGrad g;\nCore* p;\nCore&amp; r = g;\n\nc.grade(); //对Core::grade()函数进行静态绑定\ng.grade(); //对Grad::grade()函数进行静态绑定\np -> grade(); //根据p所指对象的类型进行动态绑定\nr.grade(); //根据r所引用对象的类型进行动态绑定\n多态性多态\n\n在要求一个指向基类对象的指针或引用的地方，我们可以用一个指向派生类的指针或引用来代替\n\n指用一个类型表示几种类型的能力\n\nC++通过虚函数的动态绑定特性以支持多态性\n\n简单回顾将read函数也声明为一个虚拟函数，改动后的类如下：\ncore2.h\nclass Core&#123;\npublic:\n    Core():midterm(0),final(0)&#123;&#125;\n    Core(std::istream&amp; is)&#123;read(is);&#125;\n\n    std::string name() const;\n\n    virtual std::istream&amp; read(std::istream&amp;);\n    virtual double grade() const;\nprotected:\n    //可以被全部派生类的成员访问\n    std::istream&amp; read_common(std::istream&amp;);\n    double midterm,final;\n    std::vector&lt;double>homework;\nprivate:\n    //只能被Core类的成员访问\n    std::string n;\n&#125;;\ngrad2.h\nclass Grad:public Core&#123;\npublic:\n    Grad():thesis(0) &#123;&#125;\n    Grad(std::istream&amp; is) &#123;read(is);&#125;\n\n    double grade() const;\n    std::istream&amp; read(std::istream&amp;);\nprivate:\n    double thesis;\n&#125;;\n\nbool compare(const Core&amp;,const Core&amp;);\n使用继承解决问题处理Core类的程序\nint main()\n&#123;\n    vector&lt;Core> students;\n    Core record;\n    string::size_type maxlen = 0;\n\n    //读入并存储数据\n    while (record.read(cin))\n    &#123;\n        maxlen = max(maxlen,record.name().size());\n        students.push_back(record);\n    &#125;\n\n    //将学生记录按字母排序\n    sort(students.begin(),students.end(),compare);\n\n    //输出学生姓名与成绩\n    for(vector&lt;Core>::size_type i = 0; i != students.size(); ++i)&#123;\n        cout &lt;&lt; students[i].name() &lt;&lt; string(maxlen + 1 - students[i].name().size(),' ');\n\n        try\n        &#123;\n            double final_grade = students[i].grade();\n            streamsize prec = cout.precision();\n            cout &lt;&lt; setprecision(3)  &lt;&lt; final_grade &lt;&lt; setprecision(prec) &lt;&lt; endl;\n        &#125;\n        catch(domain_error e)\n        &#123;\n            cout &lt;&lt; e.what() &lt;&lt; endl;\n        &#125;      \n    &#125;\n    return 0;\n&#125;\n处理Grad类的程序\nint main()\n&#123;\n    vector&lt;Grad> students;\n    Grad record;\n    string::size_type maxlen = 0;\n\n    //读入并存储数据\n    while (record.read(cin))\n    &#123;\n        maxlen = max(maxlen,record.name().size());\n        students.push_back(record);\n    &#125;\n\n    //将学生记录按字母排序\n    sort(students.begin(),students.end(),compare);\n\n    //输出学生姓名与成绩\n    for(vector&lt;Grad>::size_type i = 0; i != students.size(); ++i)&#123;\n        cout &lt;&lt; students[i].name() &lt;&lt; string(maxlen + 1 - students[i].name().size(),' ');\n\n        try\n        &#123;\n            double final_grade = students[i].grade();\n            streamsize prec = cout.precision();\n            cout &lt;&lt; setprecision(3)  &lt;&lt; final_grade &lt;&lt; setprecision(prec) &lt;&lt; endl;\n        &#125;\n        catch(domain_error e)\n        &#123;\n            cout &lt;&lt; e.what() &lt;&lt; endl;\n        &#125;      \n    &#125;\n    return 0;\n&#125;\n一个简单的句柄类使用句柄类微妙之处","slug":"CPP/C13 继承与动态绑定的使用","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"0a24b61512170bdfb39d64a4b932bf18","title":"CPP2 循环与计数","content":"循环与计数本章中进一步增加程序的灵活性，允许我们无需重新编写程序就可以直接改变框架的长度\n问题上一节中的输出\n\n存在如下缺陷\n\n每行输出都要与程序的某一部分（以及一个变量）相对应\n即使大堆输出格式的一个简单修改，都要求我们重新编写程序\n\n故\n\n构造一个更为灵活的输出形式$\\to$​无需将每一行都存储在一个局部变量中\n\n整体框架#include&lt;iostream>\n#include&lt;string>\n\nusing std::cin;\nusing std::cout;\n\nint main()\n&#123;\n  cout&lt;&lt;\"Please Enter your first name:\";\n\n  string name;\n  cin >> name;\n\n  const string greeting = \"Hello,\" + name + \"!\";\n\n  const int pad = 1;\n\n  const int rows = pad * 2 + 3;\n  const string::size_type cols = greeting.size() + pad * 2 + 2;\n  cout &lt;&lt; endl;\n\n  for(int r = 0; r != rows; ++r)\n  &#123;\n    string::size_type c = 0;\n    while (c! = cols)\n    &#123;\n      if (r == pad + 1 &amp;&amp; c == pad + 1) &#123;\n        cout &lt;&lt; greeting;\n        c += greeting.size();\n      &#125;\n      else\n      &#123;\n        if (r == 0 || r == rows - 1 || c ==0 || c == cols - 1)\n        &#123;\n          cout &lt;&lt; \"*\";\n        else\n          cout &lt;&lt; \" \";\n        ++c;\n        &#125;\n      &#125;\n    &#125;\n    cout &lt;&lt; endl;\n  &#125;\n  return 0;\n&#125;\n输出数目未知的行输出一行完整的程序框架计数小结","slug":"CPP/C2 循环与计数","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"3555062c5fedfb27efa69ce78e83937d","title":"CPP3 使用批量数据","content":"使用批量数据\n通常需要在程序中处理多个相似数据段\n编写程序读取学生的考试和家庭作业成绩并计算出总成绩\n\n计算学生成绩\n学生课程总成绩为加权平均\n第一次尝试的程序如下\n\n#include&lt;iomanip>\n#include&lt;ios>\n#include&lt;iostream>\n#include&lt;string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::setprecision;\nusing std::string;\nusing std::streamsize;\n\nint main()\n&#123;\n  //请求输入并读入学生的姓名\n  cout &lt;&lt; \"Please Enter your name:\";\n  string name;\n  cin >> name;\n  cout &lt;&lt; \"Hello,\" &lt;&lt; name &lt;&lt; \"!\" &lt;&lt; endl;\n\n  //请求输入并读入其中和期末成绩\n  cout &lt;&lt;  \"Please Enter your midterm and final exam grades:\";\n  double midterm,final;\n  cin >> midterm >> final;\n\n  //请求输入家庭作业成绩\n  cout &lt;&lt; \"Enter all your homework grades,\" \"Followed by end-of-file:\";\n\n  //到目前为止，读到的家庭作业成绩的个数及总和\n  int count = 0;\n  double sum = 0;\n\n  //将家庭作业成绩读到变量x中\n  double x;\n\n  while (cin>>x) &#123;\n    ++count;\n    sum += x;\n  &#125;\n  streamsize prec = cout.precision();\n  cout &lt;&lt; \"Your final grade is\" &lt;&lt; setprecision(3)\n  &lt;&lt; 0.2 * midterm + 0.4 *final + 0.4 *sum /count &lt;&lt; setprecision(prec) &lt;&lt; endl;\n  return 0;\n&#125;\n\n\n\n\n库\n类型\n作用\n\n\n\n\n&lt;ios&gt;\n类型streamsize\n输入/输出库用这个类型来表示长度\n\n\n&lt;iomanip&gt;\n控制器setprecision\n允许我们指明输出所包含的有效位数\n\n\n\n\n用中值代替平均值#include&lt;algorithm>\n#include&lt;iomanip>\n#include&lt;ios>\n#include&lt;iostream>\n#include&lt;string>\n#include&lt;vector>\n\nusing namespace std;\nint main()\n&#123;\n  //请求输入并读入学生姓名\n  cout &lt;&lt; \"Please Enter Your Name:\";\n  string name;\n  cin >> name;\n  cout &lt;&lt; \"Hello,\" &lt;&lt; name &lt;&lt; \"!\" &lt;&lt; endl;\n\n  //请求输入并读入其中和期末成绩\n  cout &lt;&lt; \"Please Enter Your midterm and final exam grades:\";\n  double midterm,final;\n  cin >> midterm >> final;\n\n  //请求输入家庭作业成绩\n  cout &lt;&lt; \"Enter all your homework grades,\" \"Followed by end-of-file:\";\n\n  vector&lt;double> homework;\n  double x;\n\n  //不变式：homework包含所有的家庭作业成绩\n  while (cin>>x)\n    homework.push_back(x);\n\n //检查homework是否为空\n typedef vector&lt;double>::size_type vec_sz;\n vec_sz size = homework.size();\n if (size == 0) &#123;\n   cout &lt;&lt; endl &lt;&lt; \"You must enter your grades.\" \"Please tyr again.\" &lt;&lt; endl;\n   return 1;\n &#125;\n\n //对成绩进行排序\n sort(homework.begin(),homework.end());\n\n //计算家庭作业成绩的中值\n vec_sz mid = size/2;\n double median;\n median = size % 2 == 0?(homework[mid]+homework[mid-1])/2:homework[mid];\n\n //计算并输出总成绩\n streamsize prec = cout.precision();\n cout &lt;&lt; \"Your final grade is\" &lt;&lt; setprecision(3)\n &lt;&lt; 0.2 * midterm + 0.4 *final + 0.4 *median &lt;&lt; setprecision(prec) &lt;&lt; endl;\n return 0;\n&#125;\n\n\n\n\n代码\n含义\n\n\n\n\nvector&lt;double&gt; homework\n定义homework为一个向量且该向量保存double类型的值\n\n\nhomework.push_back(x);\npush_back成员函数操作为添加一个新元素到向量的末尾\n\n\ntypedef vector&lt;double&gt;::size_type vec_sz\nvector类型定义了一个名为vector&lt;double&gt;::size_type的类型和一个名为size的函数\n\n\ntypedef\n所定义的名称是特定类型的一个替代名而不是这种类型的一个变量\n\n\nreturn 1\n大部分系统环境都将所有的非0值看作是失败\n\n\nsort\n该函数定义在头文件&lt;algorithm&gt;中仅仅调换了原容器中的元素值的相对顺序，而不是创建一个新的容器用于存储排序后的结果\n\n\n%\n取模运算符返回余数\n\n\n?:\n条件运算符if-then-else\n\n\n\n\n将数据集合存储到向量中\n存储大量数值，每次读取一个数值，而且在读数值的时候并不会预先知道数值的个数\n读取了所有的数值之后对它们进行排序\n高效获取中间的一个或两个数值\n\n更加深入的观察homework为空的情况下为什么要退出程序graph TD\n没有读到元素 --> homework.size=0 --> mid=0 --> 执行到homeworkmid会查看homework的第一个元素\n--> 但是homework中并没有元素存在 -->Error!\n\n\nsize_type是无符号整数类型不能存储负数值，故不用检查homework.size()&lt;0是否成立，因为不等式总是产生false值\n普通整数-无符号整数转化普通整数和无符号整数在表达式中结合在一起时，普通整数就要被转换为无符号整数\n使用标准库时，性能不会太差小结\n\n\n\n代码\n含义\n\n\n\n\ntypedef type name;\n将name定义为type的替代名\n\n\nv.push_back(e)\n给向量添加一个初始值为e的元素\n\n\nwhile(cin&gt;&gt;x)\n将一个适当类型的值读到x中并检查流的状态\n\n\ns.precision(n)\n为以后的输出将流s的精度设置为n\n\n\nsetprecision(n)\n返回一个值，在输出流s上写入时，该值具有调用s.precision(n)的效果\n\n\n\n\n","slug":"CPP/C3 使用批量数据","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"bc5e708322b6829557ee8bb706942cbe","title":"CPP4 组织程序与数据","content":"组织程序和数据库工具特征\n\n能够解决某些特定类型的问题\n独立于其他大多数工具\n都有一个名称\n\n我们自己编写的程序具备特性中的第一个，不具备另外两个。\n\n对于小程序→不是坏事\n更困难的问题→除非将解决方案分割成相互独立的具有名称的各个部分，否则会变得无法控制\n\nC++提供两种基本方法以便让我们组织大型程序\n\n函数\n数据结构\n类\n\n整体代码main.cpp\n#include&lt;algorithm>\n#include&lt;iomanip>\n#include&lt;ios>\n#include&lt;iostream>\n#include&lt;stdexcept>\n#include&lt;string>\n#include&lt;vector>\n#include\"grade.h\"\n#include\"Student_info.h\"\n\nusing std::cin;\nusing std::cout;\nusing std::domain_error;\nusing std::endl;\nusing std::max;\nusing std::setprecision;\nusing std::sort;\nusing std::streamsize;\nusing std::string;\nusing std::vector;\n\nint main()\n&#123;\n  vector&lt;Student_info> students;\n  Student_info record;\n  string::size_type maxlen = 0;\n\n  //读入并存储所有学生的数据\n  while (read(cin,record)) &#123;\n    maxlen = max(maxlen,record.name.size());\n    students.push_back(record);\n  &#125;\n\n  //按字母顺序排列学生记录\n  sort(students.begin(),students.end(),compare);\n\n  //输出姓名和成绩\n  for (vector&lt;Student_info>::size_type i=0; i != students.size(); ++i ) &#123;\n    //输出姓名，将姓名填充至maxlen+1个字符的长度\n    cout &lt;&lt; students[i].name &lt;&lt; string(maxlen+1 - students[i].name.size(),' ')；\n    //计算并输出成绩\n    try&#123;\n      double final_grade = grade(students[i]);\n      streamsize prec = cout.precision();\n      cout &lt;&lt; setprecision(3) &lt;&lt; final_grade &lt;&lt; setprecision(prec);\n    &#125; catch (domain_error e)&#123;\n      cout &lt;&lt; e.what();\n    &#125;\n    cout &lt;&lt; endl;\n  &#125;\n  return 0;\n&#125;\n知识点\n函数调用\n函数参数\n\n\n错误提示\n引用\n重载\ntry &amp; catch\n\n组织计算编写一个函数用于计算某个学生总成绩（用函数来明确代替重复的计算）\n\n减轻程序工作量\n必要时更为方便地改变运算过程\n函数具有名称，对计算命名则能以更抽象的方式去思考它，从而更加细致思考它的用途\n\ndouble grade(double midterm,double final, double homework)\n&#123;\n    return 0.2*midterm + 0.4 * final + 0.4 * homework;\n&#125;\n函数参数为midterm、final、homework，作为函数中的局部变量被使用，则\n\n调用函数→参数创建 :star:参数定义并不代表会马上创建，只是函数被调用时才会创建\n函数返回→参数销毁\n\n查找中值double median(vector&lt;double> vec)\n&#123;\n    typedef vector&lt;double>::size_type vec_sz;\n    \n    vec_sz size = vec.size();\n    if(size == 0)\n        throw domain_error(\"median of an empty vector\");\n    sort(vec.begin(),vec.end());\n    \n    vec_sz mid = size/2;\n    return size $ 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];\n&#125;\n\n向量命名为vec而非homework，中值计算的普适性\n去掉变量median，因为计算中值后可马上返回\nsize和mid作为median函数的局部变量\n从其他地方这两个变量不可访问（而且不相关）→函数调用创建，函数返回销毁→不冲突带来的安全性\n\n\n空向量的更为通用的错误提示\n向量为空→抛出异常→抛出异常的地方终止执行并转移到程序的另一部分→向这部分提供异常对象→异常对象中含有调用程序，可以用来处理异常的信息\ndomain_error→头文件stdexcept中定义的一种类型→向我们报告函数参数的取值是函数所不能接受的\n\n\n\n重新指定计算成绩的策略double grade(double midterm, double final, const vector&lt;double>&amp; hw)\n&#123;\n    if(hw.size() == 0)\n        throw domain_error(\"student has done no  homework\");\n    return grade(midterm,final,median(hw));\n&#125;\n\n\n\n\n代码\n含义\n\n\n\n\nconst vector&lt;double&gt;&amp; hw\n对参数类型为double的向量常量的引用双精度向量常量引用定义一个引用的引用与定义原来对象的引用的效果是一致的\n\n\nvector&lt;double&gt;&amp; hw2 = chw;\n错误：不能定义一个非常量引用指向一个常量对象或常量引用\n\n\ngrade函数名重复\n重载：能够使几个函数具有同样的函数名的概念系统环境能够根据参数的类来辨别我们所指的是哪一个函数\n\n\n\n\n读家庭作业成绩如何将家庭作业读进一个向量如何将家庭作业成绩读进一个向量中呢？要求一次返回两个值\n\n它读到的家庭作业成绩\n指示输入尝试是否成功\n\n如何解决从函数中返回多于一个的值呢？:question:\n\n给函数一个参数，这个参数是对一个对象的引用，而函数的其中一个结果值会放置在这个参数里面\n\nistream&amp; read_hw(istream&amp; in, vector&lt;double>&amp; hw)&#123;\n    //这一部分代码有待补充\n    return in;\n&#125;\nvector&lt;double&gt;&amp; hw\n一个不包含const的引用参数通常表示我们可以修改作为函数参数的对象的值\n尝试1double x;\nwhile(cin >> x)\n    hw.push_back(x);\n不好的原因\n\nhw并非由我们定义，而是由调用程序定义\n我们不知道里面是不是已经有了某些数据，可以调用hw.clear()\n\n\n不十分明确应在何时停止\n\n尝试2-完整的read_hw函数istream&amp; read_hw(istream&amp; in, vector&lt;double>&amp; hw)\n&#123;\n    if(in)&#123;\n        //清除原先内容\n        hw.clear();\n        \n        //读家庭作业成绩\n        double x;\n        while(in > x)\n            hw.push_back(x);\n        \n        //清除流以使输入动作对下一个学生有效\n        in.clear();\n    &#125;\n    return in;\n&#125;\n三种函数参数\n\n\n\n函数\n调用参数\n意义\n\n\n\n\nmedian\nvector&lt;double&gt;\n对这个函数的调用会导致此参数的复制效率不高但正确\n\n\ngrade\nconst vector&lt;double&gt;&amp;\n&amp;让系统环境无需复制对应参数→节省开销const确保程序不会改变参数值→安全性\n\n\nread_hw\nvector&lt;double&gt;&amp;\n&amp;让系统环境无需复制对应参数→节省开销之所以要避免复制操作是因为函数要改变参数的值\n\n\n\n\n使用函数计算学生成绩//include指令和对库工具的using声明\n//median\n//grade(double , double , double)\n//grade(double , double , const vector&lt;double>&amp;)\n//read_hw(istream&amp; , vector&lt;double>&amp;)\nint main()\n&#123;\n    //请求并输入学生姓名\n    //请求并输入期中和期末考试成绩\n    //请求用户输入家庭作业成绩\n    cout;\n    vector&lt;double> homework;\n    \n    //读入家庭作业成绩\n    read_hw (cin, homework);\n    \n    //如果可以，计算生成总成绩\n    try&#123;\n        double final_grade = grade(midterm,final,homework);\n        streamsize prec = cout.precision();\n        cout&lt;&lt; \"Your final grade is\" &lt;&lt; setprecision(3) &lt;&lt; final_grade &lt;&lt; setprecision(prec)&lt;&lt; endl;\n    &#125;\n    catch(domain_error)&#123;\n        cout &lt;&lt; endl; &lt;&lt; \"You must enter your grades.\"\n            \"Please try again.\" &lt;&lt; endl;\n        return 1;\n    &#125;\n    return 0;\n&#125;\ntry&amp;catch\ngraph TD\n尝试执行在花括号中紧跟在try关键字之后的语句 --语句的任何地方发生了一个domain_error --> 停止执行这些语句\n-->转去执行另外一系列catch子句\n\n尝试执行在花括号中紧跟在try关键字之后的语句 --语句正常结束 --> 程序跳过全部catch子句从而执行下一条语句\n\n\n组织数据我们的要求\n\n不只报告一个学生的成绩\n假设有一个包含有许多学生的姓名以及成绩的文件\n\n将一个学生的所有数据放置在一起struct Student_info&#123;\n    string name;\n    double midterm,final;\n    vector&lt;double>homework\n&#125;; //分号不可省\n用vector&lt;Student_info&gt;来保存任意数目的学生的信息\n处理学生记录步骤\ngraph TD\n将数据读到一个Student_info类型的对象中 --> 为一个Student_info类型的对象生成总成绩 --> 找到一种方法以对一个Student_info类型的向量进行排序\n\n\nread\nistream&amp; read(istream&amp; is, Student_info&amp; s)\n&#123;\n    //读入并存储学生的姓名以及期中、期末考试成绩\n    is >> s.name >> s.midterm >> s.final; \n    // 将数值读到对象s的成员name、midterm、final中\n    read_hw(is,s.homework);\n    // 调用read_hw读取家庭作业成绩\n    return is;\n&#125;\ngrade\n//const引用在调用时不会产生额外开销\ndouble grade(const Student_info&amp; s)\n&#123;\n    return grade(s.midterm,s.final,s.homework);\n&#125;\ncompare\nbool compare(const Student_info&amp; x, const Student_info&amp; y)\n&#123;\n    return x.name &lt; y.name\n&#125;\n这个函数将比较Student_info对象的工作交给类string去完成\nstring类提供一个&lt;运算符以比较字符串，按照普通的字典排序法比较字符串\n定义compare之后可以将compare函数作为第三个参数传递给库函数sort从而对向量进行排序\nsort(students.begin(),students.end(),compare);\n生成报表int main()\n&#123;\n    vector&lt;Student_info>Students;\n    Student_info record;\n    string::size_type maxlen = 0;\n\n    while (read(cin,record)) &#123;\n      maxlen = max(maxlen,record.name.size());\n      students.push_back(record);\n    &#125;\n\n    sort(students.begin(),students.end(),compare);\n\n    for (vector&lt;Student_info>::size_type i=0; i != students.size();++i) &#123;\n      cout &lt;&lt; students[i].name &lt;&lt; string(maxlen+1 - students[i].name.size(),'');\n\n    try&#123;\n      double final_grade = grade(students[i]);\n      streamsize prec = cout.precision();\n      cout &lt;&lt; setprecision(3) &lt;&lt; final_grade &lt;&lt; setprecision(prec);\n    &#125;catch(domain_error e)&#123;\n      cout &lt;&lt; e.what ();\n    &#125;\n      cout &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;\n将各部分代码连接到一起\n目前为止，定义了非常多的抽象（函数和数据结构）\n之前使用抽象的方法为：将他们的全部定义都放在同一个文件中并编译这个文件\n越来越复杂\n为降低复杂度而分块编译\n将程序放进不同的文件中并独立编译这些文件中的每一个\n\n\n\n\n\n思路\n\ngraph TD\n要让median函数对其他用户也可用median.cpp --> 编写自己的头文件median.h\n--> 主文件中使用#include/median.h\n\nmedian.cpp\n#include&lt;algorithm>\n#include&lt;stdexcept>\n#include&lt;vector>\n\nusing std::domain_error;\nusing std::sort;\nusing std::vector;\n\ndouble median(vector&lt;double> vec)\n&#123;\n    typedef vector&lt;double>::size_type vec_sz;\n\n    vec_sz size = vec.size();\n    if(size == 0)\n        throw domain_error(\"median of an empty vector\");\n    sort(vec.begin(),vec.end());\n\n    vec_sz mid = size/2;\n    return size $ 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];\n&#125;\nmedian.h\n#ifndef GUARD_median_h\n#define GUARD_median_h\n\n#include&lt;vector>\ndouble median(std::vector&lt;double>);\n\n#endif\n\n\n\n\n代码\n含义\n\n\n\n\n#include &quot;median.h&quot; 置于main.cpp中\n要求编译器将与此名称对应的头文件中的所有内容都复制到程序中\n\n\ndouble median(std::vector&lt;double&gt;);\n为median编写一个声明\n\n\n#include&lt;vector&gt;\n将声明本身所用到的所有名称都包含进去\n\n\n使用std::vertor而非using std::vector\n避免所有包含头文件的程序都使用了using std::vector的声明，而实际中不一定需要\n\n\n#ifndef\n检查GUARD_median_h是否被定义应该刚好位于文件的第一行，就算是注释也不能跑到它前头\n\n\nGUARD_median_h\n预处理程序变量的名称\n\n\n\n\n:star:\n\n自己的头文件称作头文件\n系统环境提供的头文件称作标准头，而非标准头文件\n\n将计算成绩的程序分块\n将Student_info结构和相关的函数组装起来\n\nStudent_info.h\n#ifndef GUARD_Student_info\n#define GUARD_Student_info\n\n#include&lt;iostream>\n#include&lt;string>\n##include&lt;vector>\n\nstruct Student_info&#123;\n  std::string name;\n  double midterm,final;\n  std::vector&lt;double> homework;\n&#125;;\n\nbool compare(const Student_info&amp;, const Student_info&amp;);\nstd::istream&amp; read(std::istream&amp;, Student_info&amp;);\nstd::istream&amp; read_hw(std::istream&amp;, std::vector&lt;double>&amp;);\n\n#endif\n\n声明了与Student_info结构密切相关的compare、read和read_hw函数\n函数在如下的源文件中定义\n\n\n\nStudent_info.cpp\n#include\"Student_info.h\"\n\nusing std::istream;\nusing std::vector;\n\nbool compare(const Student_info&amp; x, const Student_info&amp; y)\n&#123;\n  return x.name &lt; y.name ;\n&#125;\n\nistream&amp; read(istream&amp; is, Student_info&amp; s)\n&#123;\n    //读入并存储学生的姓名以及期中、期末考试成绩\n    is >> s.name >> s.midterm >> s.final;\n    // 将数值读到对象s的成员name、midterm、final中\n    read_hw(is,s.homework);\n    // 调用read_hw读取家庭作业成绩\n    return is;\n&#125;\n\nistream&amp; read_hw(istream&amp; in, vector&lt;double>&amp; hw)\n&#123;\n    if(in)&#123;\n        //清除原先内容\n        hw.clear();\n\n        //读家庭作业成绩\n        double x;\n        while(in > x)\n            hw.push_back(x);\n\n        //清除流以使输入动作对下一个学生有效\n        in.clear();\n    &#125;\n    return in;\n&#125;\n\n有必要在源文件中包含相应的头文件\n便于检查：C++语言要求函数的声明和定义在返回值类型、参数的个数以及类型这几个方面严格匹配\n\n\n\ngrade.h\n\n编写头文件来声明不同的grade重载函数\n将这些重载函数的声明放在一起会让这些可供选择的函数更易查找\n三个函数密切相关，因此我们将在同一个文件中定义它们\n\n\n\n#ifndef GUARD_grade_h\n#define GUARD_grade_h\n\n#include&lt;vector>\n#include\"Student_info.h\"\ndouble grade(double,double,double);\ndouble grade(double,double,const std::vector&lt;double>&amp;);\ndouble grade(const Studein &amp;);\n\n#endif\ngrade.cpp\n#include&lt;stdexcept>\n#include&lt;vector>\n#include \"grade.h\"\n#include \"median.h\"\n#include \"Student_info.h\"\n\nusing std::domain_error;\nusing std::vector;\n\ndouble grade(double midterm,double final, double homework)\n&#123;\n    return 0.2*midterm + 0.4 * final + 0.4 * homework;\n&#125;\n\ndouble grade(double midterm, double final, const vector&lt;double>&amp; hw)\n&#123;\n    if(hw.size() == 0)\n        throw domain_error(\"student has done no  homework\");\n    return grade(midterm,final,median(hw));\n&#125;\n\n//const引用在调用时不会产生额外开销\ndouble grade(const Student_info&amp; s)\n&#123;\n    return grade(s.midterm,s.final,s.homework);\n&#125;\n","slug":"CPP/C4 组织程序和数据","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"fb94724ad6a11796aa7671876e21935b","title":"CPP4 组织程序和数据 代码纯享","content":"组织程序和数据C++多文件理解https://zhuanlan.zhihu.com/p/348798266\nC++程序一般分三类文件：\n\n头文件( .h )放置各种声明，用于被cpp文件包含\n模块文件（.cpp）放置一些函数定义，也称为功能模块\n主程序文件（.cpp）包含main()的文件，程序入口，调用模块文件实现的方法\n\nmain.cpp:star:C++工程文件的组织​\ngraph TD\n包含头文件.既有标准头也有自定义头文件 --> 提一下在源文件中使用到的声明 \n--> 进入主函数 -->以Student_info为元素构建向量对象students --> 以Student_info类构建对象record\n--> 调用read函数循环读入并存储学生数据 -->调用sort函数排列学生记录  -->输出姓名和成绩\n\n#include&lt;algorithm>\n#include&lt;iomanip>\n#include&lt;ios>\n#include&lt;iostream>\n#include&lt;stdexcept>\n#include&lt;string>\n#include&lt;vector>\n#include\"grade.h\"\n#include\"Student_info.h\"\n\nusing std::cin;\nusing std::cout;\nusing std::domain_error;\nusing std::endl;\nusing std::max;\nusing std::setprecision;\nusing std::sort;\nusing std::streamsize;\nusing std::string;\nusing std::vector;\n\nint main()\n&#123;\n  vector&lt;Student_info> students;\n  Student_info record;\n  string::size_type maxlen = 0;\n\n  //读入并存储所有学生的数据\n  while (read(cin,record)) &#123;\n    maxlen = max(maxlen,record.name.size());\n    students.push_back(record);\n  &#125;\n\n  //按字母顺序排列学生记录\n  sort(students.begin(),students.end(),compare);\n\n  //输出姓名和成绩\n  for (vector&lt;Student_info>::size_type i=0; i != students.size(); ++i ) &#123;\n    //输出姓名，将姓名填充至maxlen+1个字符的长度\n    cout &lt;&lt; students[i].name &lt;&lt; string(maxlen+1 - students[i].name.size(),' ')；\n    //计算并输出成绩\n    try&#123;\n      double final_grade = grade(students[i]);\n      streamsize prec = cout.precision();\n      cout &lt;&lt; setprecision(3) &lt;&lt; final_grade &lt;&lt; setprecision(prec);\n    &#125; catch (domain_error e)&#123;\n      cout &lt;&lt; e.what();\n    &#125;\n    cout &lt;&lt; endl;\n  &#125;\n  return 0;\n&#125;\nStudent_info.h:star:宏定义判断\n:star:结构体\n:star:函数原型声明​\n\n\n\n\n代码\n含义\n\n\n\n\n#ifndef GUARD_Student_info\n检查GUARD_Student_info是否被定义应该刚好位于文件的第一行，就算是注释也不能跑到它前头\n\n\nGUARD_Student_info\n预处理程序变量的名称\n\n\n#include\n包含头文件\n\n\nstruct Student_info{  std::string name;  double midterm,final;  std::vector homework;};\n定义了Student_info的结构体包含了name、midterm、final、homework几个字段\n\n\nbool compare(const Student_info&amp;, const Student_info&amp;);\ncompare函数调用了两个Student_info的常量引用\n\n\nstd::istream&amp; read(std::istream&amp;, Student_info&amp;);\n1.read函数以 istream和Student_info的引用为参数2.声明了read函数\n\n\nstd::istream&amp; read_hw(std::istream&amp;, std::vector&lt;double&gt;&amp;);\n1.read_hw函数以 istream和vector的引用为参数2.声明了read_hw函数\n\n\n\n\n#ifndef GUARD_Student_info\n#define GUARD_Student_info\n\n#include&lt;iostream>\n#include&lt;string>\n#include&lt;vector>\n\nstruct Student_info&#123;\n  std::string name;\n  double midterm,final;\n  std::vector&lt;double> homework;\n&#125;;\n\nbool compare(const Student_info&amp;, const Student_info&amp;);\nstd::istream&amp; read(std::istream&amp;, Student_info&amp;);\nstd::istream&amp; read_hw(std::istream&amp;, std::vector&lt;double>&amp;);\n\n#endif\nStudent_info.cpp\n\n\n\n代码\n含义\n\n\n\n\n#include&quot;Student_info.h&quot;\n包含头文件\n\n\nbool compare(const Student_info&amp; x, const Student_info&amp; y){  return x.name &lt; y.name ;}\n定义比较bool类型\n\n\nistream&amp; read(istream&amp; is, Student_info&amp; s){    //读入并存储学生的姓名以及期中、期末考试成绩    is &gt;&gt; s.name &gt;&gt; s.midterm &gt;&gt; s.final;    // 将数值读到对象s的成员name、midterm、final中    read_hw(is,s.homework);    // 调用read_hw读取家庭作业成绩    return is;}\n定义read函数\n\n\nistream&amp; read_hw(istream&amp; in, vector&amp; hw){    if(in){        //清除原先内容        hw.clear();        //读家庭作业成绩        double x;        while(in &gt; x)            hw.push_back(x);        //清除流以使输入动作对下一个学生有效        in.clear();    }    return in;\n定义read_hw函数\n\n\n\n\n#include\"Student_info.h\"\n\nusing std::istream;\nusing std::vector;\n\nbool compare(const Student_info&amp; x, const Student_info&amp; y)\n&#123;\n  return x.name &lt; y.name ;\n&#125;\n\nistream&amp; read(istream&amp; is, Student_info&amp; s)\n&#123;\n    //读入并存储学生的姓名以及期中、期末考试成绩\n    is >> s.name >> s.midterm >> s.final;\n    // 将数值读到对象s的成员name、midterm、final中\n    read_hw(is,s.homework);\n    // 调用read_hw读取家庭作业成绩\n    return is;\n&#125;\n\nistream&amp; read_hw(istream&amp; in, vector&lt;double>&amp; hw)\n&#123;\n    if(in)&#123;\n        //清除原先内容\n        hw.clear();\n\n        //读家庭作业成绩\n        double x;\n        while(in > x)\n            hw.push_back(x);\n\n        //清除流以使输入动作对下一个学生有效\n        in.clear();\n    &#125;\n    return in;\n&#125;\nmedian.h#ifndef GUARD_median_h\n#define GUARD_median_h\n\n#include&lt;vector>\ndouble median(std::vector&lt;double>);\n#endif\nmedian.cpp#include&lt;algorithm>\n#include&lt;stdexcept>\n#include&lt;vector>\n\nusing std::domain_error;\nusing std::sort;\nusing std::vector;\n\ndouble median(vector&lt;double> vec)\n&#123;\n    typedef vector&lt;double>::size_type vec_sz;\n\n    vec_sz size = vec.size();\n    if(size == 0)\n        throw domain_error(\"median of an empty vector\");\n    sort(vec.begin(),vec.end());\n\n    vec_sz mid = size/2;\n    return size $ 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];\n&#125;\ngrade.h:star:函数重载​\n#ifndef GUARD_grade_h\n#define GUARD_grade_h\n\n#include&lt;vector>\n#include\"Student_info.h\"\n\ndouble grade(double,double,double);\ndouble grade(double,double,const std::vector&lt;double>&amp;);\ndouble grade(const Student_info &amp;);\n\n#endif\ngrade.cpp#include&lt;stdexcept>\n#include&lt;vector>\n#include \"grade.h\"\n#include \"median.h\"\n#include \"Student_info.h\"\n\nusing std::domain_error;\nusing std::vector;\n\ndouble grade(double midterm,double final, double homework)\n&#123;\n    return 0.2*midterm + 0.4 * final + 0.4 * homework;\n&#125;\n\ndouble grade(double midterm, double final, const vector&lt;double>&amp; hw)\n&#123;\n    if(hw.size() == 0)\n        throw domain_error(\"student has done no  homework\");\n    return grade(midterm,final,median(hw));\n&#125;\n\n//const引用在调用时不会产生额外开销\ndouble grade(const Student_info&amp; s)\n&#123;\n    return grade(s.midterm,s.final,s.homework);\n&#125;\n","slug":"CPP/C4 组织程序和数据_精简版","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"8634375c41badd07a389bc135cc9590c","title":"CPP5 使用顺序容器和分析字符串","content":"使用顺序容器和分析字符串本章\n\n更深入了解库的使用方法\n标准库\n提供有用的数据结构和函数\n反映一个具有一致性的体系结构\n一旦了解了一种容器的行为特性，就可以非常轻松地掌握全部库容器的使用方法\n\n\n\n\n\n将学生进行分类要求：算出学生成绩之外，区分学生能否通过课程\n实现思路：\n\nStudent_info记录的向量\n抽取不能通过的学生记录存储在另一个向量\n原先向量删除不能通过的学生数据\n\n代码实现1：保存两个副本\n//判断学生是否不及格\nbool fgrade(const Student_info&amp; s)\n&#123;\n    return grade(s) &lt; 60;\n&#125;\n// 学生s的grade小于60则返回 True，否则返回False\n//第一次尝试将及格和不及格的学生记录分开\nvector&lt;Student_info> extract_fails(vector&lt;Student_info>&amp; students)\n&#123;\n    vector&lt;Student_info> pass,fail;\n    for (vector&lt;Student_info>)::size_type i = 0; i != students.size() ; ++i)\n    if (fgrade(students[i]))\n      fail.push_back(students[i]);\n    else\n      pass.push_back(students[i]);\n    students = pass;\n    return fail;\n&#125;\n//整体思路：定义两个向量，循环判断是否不及格，不及格则压入fail，否则压入pass\n代码实现2：就地删除元素\n上述extract_fails函数缺陷\n\n要求有足够内存保存每个学生记录的两个副本\n原因在于不断增加pass和fail长度的同时，原来记录依然存在\n\n\n\n解决办法\n\n使用一个对我们算法更加合适的数据结构 :ballot_box_with_check:本节\n使用一个更加聪明的算法以避免在原先设计中额外开销\n\n//第二次尝试：函数正确，但是可能会相当慢\nvector&lt;Student_info> extract_fails(vector&lt;Student_info>&amp; students)\n&#123;\n    vector&lt;Student_info>  fail;\n    vector&lt;Student_info>::size_type i = 0;\n\n    while (i != students.size()) &#123;\n      if (fgrade(students[i]))&#123;\n        fail.push_back(students[i]);\n        students.erase(students.begin() + i);\n      &#125;else\n      ++i;\n    &#125;\n    return fail;\n&#125;\n小结：\n\n两个版本的extract_fails函数顺序访问容器中的元素\n依次查看每一个学生记录，先对当前记录作出处理，然后继续查看下一条记录\n\n\n顺序存取和随机存取\n如果我们函数仅需要顺序访问，则没有必要使用那些提供了随机访问能力的索引\n\n\n\n迭代器extract_fails实际使用的容器操作\n\n使用索引i来从Student_info结构中取值\n\n如果用迭代器来代替索引，能让库应用知识\n\n一个迭代器(iterator)为一个值，能够\n识别一个容器以及容器中的一个元素\n允许我们检查存储在这个元素中的值\n提供操作以移动在容器中的元素\n采用对应于容器所能够有效处理的方式对可用的操作进行约束\n\n\n\n迭代器vs索引\n// 索引\nfor(vector&lt;Student_info>::size_type i = 0; i != students.size();++i)\n    cout &lt;&lt; students[i].name &lt;&lt; endl;\n\n// 迭代器\nfor(vector&lt;Student_info>::const_iterator iter = students.begin(); iter != students.end(); ++iter)&#123;\n    cout &lt;&lt; (*iter).name &lt;&lt;endl;\n&#125;\n迭代器的类型\n\n\n\n容器迭代器类型\n含义\n\n\n\n\ncontainer-type::const_iterator\n仅需要读操作\n\n\ncontainer-type::iterator\n想用一个迭代器修改存储在容器中的值\n\n\n\n\n迭代器的操作cout &lt;&lt; (*iter).name\n通过调用间接引用运算符*访问迭代器指向元素\n故上述为将当前元素的name成员写到标准输出中\n一些语法知识(*iter).name 等价于 iter -&gt; name\n用迭代器代替索引//版本3：用迭代器代替索引；效率可能仍然很低\nvector&lt;Student_info> extract_fails(vector&lt;Student_info>&amp; students)\n&#123;\n  vector&lt;Student_info> fail;\n  vector&lt;Student_info>::iterator iter = students.begin();\n  while (iter != students.end()) &#123;\n    if (fgrade(*iter)) &#123;\n      fail.push_back(*iter);\n      iter = students.erase(iter);\n    &#125;else\n    ++iter;\n  &#125;\n  return fail;\n&#125;\n:star:使用了iterator而非const_iterator\n\n因为调用erase时想用它来对students进行修改\n\n:star:将erase的返回值付给iter\n\n会让iter指向被删除元素后面那个元素\n\nlist类型使用一个数据结构重新实现我们的程序，这个数据结构能让我们高效地从容器内删除元素\n//版本4：用list代替vector\nlist&lt;Student_info>extract_fails(list&lt;Student_info>&amp; students)\n&#123;\n  list&lt;Student_info> fail;\n  list&lt;Student_info>::iterator iter = students.begin();\n  while (iter != students.end()) &#123;\n    if (fgrade(*iter)) &#123;\n      fail.push_back(*iter);\n      iter = students.erase(iter);\n    &#125;else\n    ++iter;\n  &#125;\n  return fail;\n&#125;\n\n\n\n\n操作\nvector\nlist\n\n\n\n\n删除元素\n全部指向被删除的元素及之后的元素迭代器都会失效\n不会使得指向其他元素的迭代器失效\n\n\n添加元素\n给新元素分配空间的动作可能导致整个vector的重新分配\n不会使得指向其他元素的迭代器失效\n\n\n访问\n高效随机访问\n不支持完全随机的访问\n\n\n排序\n可以使用全局的sort函数\nlist有自己的成员函数sort\n\n\n实现\n数组\n双向链表\n\n\n适用场景\n小规模输入\n大规模输入\n\n\n特点\n快速随机访问容器只是(主要是)从尾部增长和缩小，性能好支持索引\n任何位置快速插入和删除元素要从容器中删除许多元素，list速度更快\n\n\n\n\n分割字符串。大部分时候，我们将字符串当做单独的实体处理；但有时还是需要查看字符串的特定字符\n事实上，我们可以将字符串看成一种特殊的容器\n\n仅包含字符\n支持某些容器操作 like 索引\n\n要求：将一个字符串每个单词划分开来\nsplit函数实现：\nvector&lt;string> split(const string&amp; s) //常量引用 -> 复制单词 -> 不会修改原先的字符串\n&#123;\n  vector&lt;string> ret; // 用于保存来自输入字符串的单词\n  typedef string::size_type string_size; // 定义索引i\n  string_size i = 0; //初始化索引i -> 索引i 用于找出每一个单词的开头\n\n  while (i != s.size()) &#123; //最外层while -> 确保一旦处理完了输入的最后一个单词则会马上停止\n    while (i != s.size() &amp;&amp; isspace(s[i])) // 找出s中的第一个非空白字符\n      ++i;\n    string_size j = i; \n    while (j != s.size() &amp;&amp; !isspace(s[j])) // 单词的后索引j\n      ++j;\n    if (i != j) &#123;\n      ret.push_back(s.substr(i,j,-i)); // substr用于创建一个包含了原始字符串副本的新字符串\n      i = j;\n    &#125;\n  &#125; //最外层while -> 确保一旦处理完了输入的最后一个单词则会马上停止\n  return ret;\n&#125;\n\n这个代码需要头文件cctype，定义了isspace\n\n测试split函数测试程序\nint main()\n&#123;\n  string s;\n  while (getline(cin,s)) &#123; //getline 函数读取输入流cin的数据并存储到字符串引用中\n    vector&lt;string> v= split(s);\n\n    for(vector&lt;string>::size_type i=0; i != v.size(); ++i)\n      cout &lt;&lt; v[i] &lt;&lt; endl;\n  &#125;\n  return 0;\n&#125;\n连接字符串字符串装框要求：建立一个数据结构以表示整个被框起的的字符串\n思路：\n\ngraph TD\n找出向量中最长的字符串长度width --> 为文本装框frame\n\nwidth.cpp\nstring::size_type width(const vector&lt;string>&amp; v)\n&#123;\n  string::size_type maxlen = 0;\n  for(vector&lt;string>::size_type i = 0; i != v.size(); ++i)\n    maxlen = max(maxlen, v[i].size());\n  return maxlen;\n&#125;\nframe.cpp\nvector&lt;string&gt; frame(const vector&lt;string&gt;&amp; v) &#x2F;&#x2F;常量引用 -&gt; 复制单词 -&gt; 不会修改原先的字符串\n  vector&lt;string&gt; ret;\n  string::size_type maxlen &#x3D; width(v);\n  string border (maxlen + 4, &#39;*&#39;); &#x2F;&#x2F;将border定义为一个长度确定的字符串\n\n  &#x2F;&#x2F;输出顶部的边框\n  ret.push_back(border);\n\n  &#x2F;&#x2F;输出内部的行，每一行都用一个星号和一个空格来框起\n  for(vector&lt;string&gt;::size_type i &#x3D; 0; i !&#x3D; v.size(); ++i)&#123;\n    ret.push_back(&quot;*&quot; + v[i] + string(maxlen - v[i].size(), &#39;&#39;) + &quot;*&quot; );\n  &#125;\n\n  &#x2F;&#x2F;输出底部的边框\n  ret.push_back(border);\n return ret;\n&#125;\n纵向连接要求：按行将图案自然组织起来\n思路：用一个vector&lt;string&gt;类型的向量来表示一幅图案，向量中每一个元素都是图案的一行\n向量连接操作的实现：\nvector&lt;string> vcat(const vector&lt;string>&amp; top, const vector&lt;string>&amp; bottom)\n&#123;\n  // 复制顶部图案\n  vector&lt;string> ret = top;\n  // 复制整个底部图案\n  for（vector&lt;string>::const_iterator it = bottom.begin(); it != bottom.end(); ++it）\n    ret.push_back(*it);\n    return ret\n&#125;\n上述for循环中可用如下代替\nret.insert(ret.end(),bottom.begin(),bottom.end());\n横向连接vector&lt;string>\nhcat(const vector&lt;string>&amp; left, const vector&lt;string>&amp; right)\n&#123;\n  vector&lt;string> ret;\n\n  //对width(left)加1，在两幅图案之间留一个空格\n  string::size_type widthl = width(left) + 1;\n\n  // 建立用于遍历left和right的索引\n  vector&lt;string>::size_type i = 0, j = 0;\n\n  //循环操作直到查看完了两幅图案的全部行\n  while (i != left.size() || j != right.size()) &#123;\n    // 构造新字符串来保存字符，字符来自两幅输入图案\n    string s;\n\n    //如果左侧图案还有待复制的行，则复制一行\n    if(i != left.size())\n      s = left[i++];\n\n  //填充至适当的长度\n  s += string(widthl - s.size(), '');\n\n  //如果右侧图案还有待复制的行，则复制一行\n  if ( j != right.size())\n    s += right[j++];\n\n//将s添加到我们正在创建的图案中\n  ret.push_back(s);\n  &#125;\n  return ret;\n&#125;\n小结\n\n\n\n容器及其操作\n含义\n\n\n\n\ncontainer&lt;T&gt;::iterator\n容器的迭代器的类型名\n\n\ncontainer&lt;T&gt;::const_iterator\n容器的迭代器的类型名\n\n\ncontainer&lt;T&gt;::size_type\n保存容器可能存在的最大实例的长度\n\n\nc.begin() c.end()\n指向容器第一个元素和紧跟在最后一个元素之后的那个位置的迭代器\n\n\nc.rbegin() c.rend()\n逆序访问，最后一个元素和第一个元素之前的那个位置的迭代器\n\n\ncontainer&lt;T&gt;c;\n定义一个容器c\n\n\ncontainer&lt;T&gt;c(c2);\n给定c2，则c是c2的一个副本；否则c为空\n\n\ncontainer&lt;T&gt;c(n);\n定义一个有n个元素的容器c，c根据T的类型而被数值初始化\n\n\ncontainer&lt;T&gt;c(n,t);\n定义一个有n个元素的容器c，c的元素是t的副本\n\n\ncontainer&lt;T&gt;c (b,e);\n创建一个容器，容器保存了位于区间[b,e)中的迭代器所指示元素的一个副本\n\n\nc=c2;\n用容器c2的一个副本来替换容器c的内容\n\n\nc.size()\n返回c的元素个数\n\n\nc.empty()\n指示c是否没有元素\n\n\nc.insert(d,b,e)\n复制位于区间[b,e)中的迭代器所指示的元素，并且将它们插入到c中位于d之前的位置中\n\n\nc.erase(it)\n从容器中删除由it指示的元素\n\n\nc.erase(b,e)\n从容器中删除由[b,e)指示的元素\n\n\nc.push_back(t)\n在c的末尾添加一个元素，这个元素的值为t\n\n\nc[n]\n从容器c中取出位于位置n的字符\n\n\n\n\n\n\n\n\n迭代器操作\n含义\n\n\n\n\n*it\n间接引用迭代器it以获取存储在容器中位于it所指示的未知的值\n\n\nit -&gt; x\n与(*it).x等价\n\n\n\n\n\n\n\n\nvector内存分配\n含义\n\n\n\n\nv.reserve(n)\n保留空间以保存n个元素，但不对这些元素进行初始化\n\n\nv.resize(n)\n给v个新长度，这个长度等于n\n\n\n\n\n\n\n\n\ncctype头文件提供的函数\n含义\n\n\n\n\nisspace(c)\n空白字符\n\n\nisalpha(c)\n字母字符\n\n\nisdigit(c)\n数字字符\n\n\nisalnum(c)\n字母或数字\n\n\nispunct(c)\n标点字符\n\n\nisupper(c)\n大写字母\n\n\nislower(c)\n小写字母\n\n\ntoupper(c)\n产生一个等于c的大写字母\n\n\ntolower(c)\n产生一个等于c的小写字母\n\n\n\n\n","slug":"CPP/C5 使用顺序容器和分析字符串","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"626917d17fb14af0007b94f4b30e0461","title":"CPP6 使用库算法","content":"使用库算法\n全部容器都提供了配套的迭代器类型\n库保证了全部提供同一个操作的迭代器都通过同样的接口以实现其功能\n\n本章\n\n库如何利用公用接口来提供一个标准算法集合\n通过使用这些算法能够避免重复编写同样的代码\n\n\n\n字符处理应用1：连接两幅字符图案//方案1\nfor (vector&lt;string>::const_iterator it = bottom.begin(); it != bottom.end(); ++it)\n    ret.push_back(*it);\n\n//方案2\nret.insert(ret.end(),bottom.begin(),bottom.end());\n\n//方案3\ncopy (bottom.begin(),bottom.end(),bach_inserter(ret));\n在此处，copy是一个泛型算法示例，而back_inserter则是一个迭代器适配器的示例\n泛型算法\n\n不属于任何特定类别容器的算法\n会从其参数类型获得关于如何访问它所使用数据的提示\n标准库的泛型算法通常在它们的参数间采用迭代器来处理基本容器的元素\n例如，copy采用了三个迭代器begin,end,out\n其作用为将区间[begin,end)中的全部元素复制到一连串从out开始的元素中，并且在必要的时候对out所属容器进行扩展\n\n\n\n\n\n即\ncopy(begin,end,out);\n与\nwhile (begin != end)\n    *out++ = *begin++\n//等价于 &#123;*out = *begin; ++out; ++begin&#125;\n不同之处在于\n\nwhile循环体修改了迭代器的值\ncopy不会对其进行修改\n\n迭代器适配器\n\n\n\n种类\n特点\n\n\n\n\n迭代器 iterator\n一种函数，会产生有着与其参数相关的属性的迭代器以做他用\n\n\n迭代器适配器 eg:back_inserter\n用一个容器作为它的参数并产生一个迭代器，在生成的迭代器被用作一个目的地的时候，会向容器末端添加数值\n\n\n\n\n应用2：实现split的另一种方法bool space(char c) \n&#123;\n  return isspace(c); //标准库提供的让我们检查一个字符是否是空格的函数，是一个重载的函数\n&#125;\nbool not_space(char c)\n&#123;\n  return !isspace(c);\n&#125;\nvector&lt;string> split(const string&amp; str)\n&#123;\n  typedef string::const_iterator iter; // 用typedef简化迭代器类型，从而能够使用iter代替string::const_iterator\n  vector&lt;string> ret;\n  iter i = str.begin();\n  while (i != str.end()) &#123;\n    i = find_if(i, str.end(),not_space); //find_if 前两个参数为一个序列的迭代器，第三个参数则是一个谓词\n      \n      //此处用于查找第一个非空白字符，这个字符是一个单词的开头\n\n    iter j = find_if(i,str.end(),space);\n\n      //此处用于查找第二个非空白字符，这个字符是一个单词的开头\n      \n    if( i != str, end())\n      ret.push_back(string(i,j));\n   i = j;\n  &#125;\n  return ret;\n&#125;\n应用3：回文要求：使用库轻松解决判断一个单词是不是一个回文\nbool is_palindrome(const string&amp; s)\n&#123;\n    return equal(s.begin(),s.end(),s.rbegin());\n&#125;\n应用4：查找URL要求：编写函数用来查找被称为“统一资源地址URL”的万维网地址，希望函数能够查找在它的输入中的全部URL。\n\n\n\n\n\n\n\n\n\nURL具有如下形式的字符序列\nprotocol-name://resource-name\nprotocol：仅包含字母\nresource-name：字母、数字以及某些标点符号\n代码实现\nvector&lt;string> find_urls(const string&amp; s)\n&#123;\n  vector&lt;string> ret; //用于保存查找到的URL\n  typedef string::const_iterator iter;\n  iter b = s.begin(), e = s.end();\n\n  while (b != e) &#123;\n    b = url_beg(b,e); //url_beg函数用于找出输入中的URL的开头\n\n    if (b != e) &#123;\n      iter after = url_end(b,e);//url_end函数用于找出输入中的URL的结尾\n\n      ret.push_back(string(b,after));\n\n      b  = after;\n    &#125;\n  &#125;\n  return ret;\n&#125;\n内嵌函数url_beg与url_end\nurl_end\n//url_end函数用于找出输入中的URL的结尾\nstring::const_iterator\nurl_end(string::const_iterator b, string::const_iterator e)\n&#123;\n  return find_if(b,e,not_url_char);\n&#125;\n\n//not_url_char函数\nbool not_url_char(char c)\n&#123;\n  static const string url_ch = \"~;/?:@=&amp;$-_+.!*()',\";\n\n  return !(   isalnum(c) || find(url_ch.begin(),url_ch.end(),c) != url_ch.end()  );\n    //find函数会查找由它的第三个参数所给定的特定值\n&#125;\n:star:新概念\n\nstatic：静态存储类别说明符\n被声明为static的局部变量具有全局寿命，即其生存期贯穿了整个函数调用过程\n\n\n\nurl_beg\n//url_beg函数用于找出输入中的URL的开头\nstring::const_iterator\nurl_beg(string::const_iterator b,string::const_iterator e)\n&#123;\n   //声明并初始化一个局部变量，保存分隔符的组成字符，这个分隔符用来识别潜在的URL\n  static const string sep = \"://\"; \n    \n  typedef string::const_iterator iter;\n\n  iter i = b;\n    \n   //调用search查找分隔符，第一对迭代器指示我们要查找的序列，第二对迭代器指示我们希望定位的序列\n  // search失败则返回第二个迭代器\n  while ((i = search(i,e,sep.begin(),sep.end())) != e) &#123;\n     \n      //检查这个分隔符是否填满整个输入行\n    if (i != b &amp;&amp; i + sep.size() != e) &#123;\n        \n      //beg标记协议名称的开头\n        //beg[-1]就是位置紧位于由beg所指示的字符之前的那一个字符\n        //isalpha检验了它的参数是否为一个字母\n      iter beg = i;\n      while(beg != b &amp;&amp; isalpha(beg[-1]))\n          --beg;\n        \n        \n    if(beg !=i &amp;&amp; !not_url_char(i[sep.size()]))\n      return beg;\n    &#125;\n    i += sep.size();\n  &#125;\n  return e;\n&#125;\n比较计算成绩的方案我们想知道，从平均上来说，那些漏交家庭作业的学生和那些做了全部家庭作业的学生的总成绩上是否会有所不同，提出以下两个方案\n\n使用平均值代替中值，将学生没有上交的作业成绩设定为0\n仅使用学生实际提交的作业成绩的中值\n\n要实现交了全部家庭作业学生的中值成绩和漏交了一次以上作业的学生中值成绩的比较。\n要编写程序处理下列问题\n\n读全部学生记录，将做了全部家庭作业的学生与其他的学生分隔开\n对每一组中的全部学生分别使用每一个的计算成绩的方案，报告每一组的中值成绩\n\n步骤1：处理学生记录要求：读入学生记录并对记录进行分类\n子函数1：did_all_hw用于检查是否做了全部作业\nbool did_all_hw(const student_info&amp; s)\n&#123;\n  //find函数如果找不到所要查找的值(第三个参数)，则会返回s.homework.end()(第二个参数)\n  return ( (find(s.homework.begin(),s.homework.end(),0))\n    == s.homework.end());\n&#125;\n主函数：classify用于读入记录并分类\nvector&lt;student_info> did,didnt;\nstudent_info student;\n\n//读全部的记录，根据是否做了全部的家庭作业而对它们进行分类\nwhile (read(cin,student)) &#123;\n  if(did_all_hw(student))&#123;\n    did.push_back(student);\n  else\n    didnt.push_back(student);\n  &#125;\n\n  //检查两个向量是否有包含数据\n  if(did.empty())&#123;\n    cout &lt;&lt; \"No student did all the homework!\" &lt;&lt; endl;\n    return 1;\n  &#125;\n  if(didnt.empty())&#123;\n    cout &lt;&lt; \"Every student did all the homework!\" &lt;&lt; endl;\n    return 1;\n  &#125;\n&#125;\n步骤2：分析成绩\ngraph TD\nwrite_analysis --> median_analysis --> transform -->back_inserter\nmedian_analysis --> median\nmedian_analysis --> 辅助函数grade_aux\n\nwrite_analysis.cpp要求：定义三个分析函数并将每一个分析函数当做一个参数传递给报告函数\n具体要求：write_analysis(cout,&quot;median&quot;,median_analysis,did,didnt);\n代码实现\n// ostream&amp; out 接收输出的流\n// const string&amp; name 一个表示分析名称的字符串\n// double analysis(const vector&lt;Student_info>&amp;) 用于分析的函数\n// const vector&lt;Student_info>&amp; did 所分析的向量1\n// const vector&lt;Student_info>&amp; didnt 所分析的向量2\nvoid write_analysis(ostream&amp; out, const string&amp; name,\n   double analysis(const vector&lt;Student_info>&amp;),\n   const vector&lt;Student_info>&amp; did,\n   const vector&lt;Student_info>&amp; didnt)\n&#123;\n  out &lt;&lt; name &lt;&lt; \":median(did) = \" &lt;&lt; analysis(did)\n  &lt;&lt; \":median(didnt)=\" &lt;&lt; analysis(didnt) &lt;&lt; endl;\n&#125;\n:star:新概念\n\nvoid\n我们说某个函数”返回”一个void时，实际上在说它不返回值\n\n\n\nmedian_analysis.cpp子函数1：median_analysis，输入保存学生记录的向量，输出根据普通计算成绩的方案以计算学生成绩并返回成绩中值\ndouble median_analysis(const vector&lt;Student_info>&amp; students)\n&#123;\n  vector&lt;double> grades;\n  transform(students.begin(),students.end(),back_inserter(grades),grade);\n  return median(grades);\n&#125;\n\n//transform将grade函数应用于students的每一个元素，并将每一个成绩添加到名为grades的向量中\n// 开头两个迭代器：指定待转换元素的区间\n// 第三个迭代器：一个目的地，保存函数的运行结果\n// 第四个参数：一个函数，将这个函数应用于输入序列的每个元素中以获得输出序列中的对应元素\n\n函数不太有效修正版本\n原因1：grade函数有几个重载版本，要找一个办法来告知编译器执行具体哪个版本的grade\n原因2：如果有学生没做作业，grade函数将抛出一个异常，且transform函数不会对异常做任何处理动作\n\n\n\nmedian_analysis_better.cpp 修正版本\ndouble median_analysis(const vector&lt;Student_info>&amp; students)\n&#123;\n  vector&lt;double> grades;\n  transform(students.begin(),students.end(),back_inserter(grades),grade_aux);\n  return median(grades);\n&#125;\n\n//grade_aux在grade内执行try语句并处理异常\n//先调用第一个`grade(s)`版本\n//如果发生异常，将捕获并调用`grade(s.midterm,s.final,0)`版本\ndouble grade_aux(const Student_info&amp; s)\n&#123;\n  try&#123;\n    return grade(s);\n  &#125;catch(domain_error)&#123;\n    return grade(s.midterm,s.final,0);\n  &#125;\n&#125;\naverage_analysis.cppdouble average_analysis(const vector&lt;Student_info>&amp; students)\n&#123;\n  vector&lt;double> grades;\n  transform(students.begin(),students.end(),back_inserter(grades),average_grade);\n  return median(grades);\n&#125;\n\ndouble average_grade(const Student_info&amp; s)\n&#123;\n  return grade(s.midterm,s.final,average(s.homework));\n&#125;\n\ndouble average(const vector&lt;double>&amp; v)\n&#123;\n  //accumulate在&lt;numeric>中声明，头两个参数指示了一个区间\n  //第三个参数给定值是求和结果的开始，使用0.0为了保证求和结果有小数\n  //函数所做工作是对区间中的值求和\n  return accumulate(v.begin(),v.end(),0.0) / v.size();\n&#125;\noptimistic_median_analysis.cppdouble optimistic_median(const Student_info&amp; s)\n&#123;\n  vector&lt;double> nonzero;\n  remove_copy(s.homework.begin(),s.homework.end(),back_inserter(nonzero),0);\n\n  if(nonzero.empty())\n  return grade(s.midterm,s.final,0);\n  else\n  return grade(s.midterm,s.final,median(nonzero));\n&#125;\n对学生进行分类并回顾我们的问题问题：记录中某一部分复制到单独向量并从现有向量删除这些记录\n上述问题在输入长度增加时，对这个问题的明显而简单的求解方法的性能难以断定\n解决方法：用一个链表来代替向量从而解决这个性能问题\n方案1：两次传递extract_fails1.cpp\nvector&lt;Student_info>\nextract_fails(vector&lt;Student_info>&amp; students)\n&#123;\n  vector&lt;Student_info> fail;\n  //remove_copy_if 请求删除每一个满足谓词pgrade的元素\n  remove_copy_if(students.begin(),students.end(),back_inserter(fail),pgrade);\n  students.erase(remove_if(students.begin(),students.end(),fgrade),students.end());\n  return fail;\n&#125;\n\n//pgrade\nbool pgrade(const Student_info&amp; s)\n&#123;\n  return !fgrade(s);\n&#125;\n方案2：一次传递extract_fails2.cpp\nvector&lt;Student_info>\nextract_fails(vector&lt;Student_info>&amp; students)\n&#123;\n  vector&lt;Student_info> ::iterator iter =\n    stable_partition(students.begin(),students.end(),pgrade);\n\nvector&lt;Student_info> fail(iter,students.end());\n\nstudents.erase(iter,students.end());\n\nreturn fail;\n&#125;\n算法、容器以及迭代器\n\n\n\n\n\n\n\n\n算法作用于容器的元素—并非作用于容器\n容器-算法\n迭代器-算法\n迭代器-容器\nsort,remove_if,partition函数都会讲基本容器中的元素移动到新的位置，但是并没有改变容器本身的特性\n小结\n\n\n\n代码\n名称\n作用\n\n\n\n\nstatic type variable\n类型修饰符\n用于局部声明，声明具有static存储类型的variable此变量值会在这个作用域的执行过程中保持不变\n\n\nvoid\n类型\n用它表示一个函数并没有产生返回值这样的函数可以通过一条return;语句退出\n\n\ninsert_iterators\n迭代器适配器\n让关联的容器动态增长\n\n\n\n\n","slug":"CPP/C6 使用库算法","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"c6bbdc5859805502fec5f66437416592","title":"CPP7 使用关联容器","content":"使用关联容器\n顺序容器：给容器元素选择适当顺序后，它们会按照我们所选择的顺序将元素保存起来\n关联容器：容器会自动将它们的元素安排在一个序列中\n\n支持高效查找的容器关联容器：自动将它们元素安排在一个序列中，利用这种排序方法让我们可以更快速地对特定元素进行定位—并不需要我们自己保持容器的顺序\n机制：键-值\n特点：自动排序，所以我们的程序不可以做任何动作改变元素的顺序\n示例1：计算单词数量要求：算出在输入中每一个不同的单词所出现的次数\ncounters.cpp\nint main()\n&#123;\n  string s;\n  //存储每个单词和一个关联的计数器\n  //一个从字符串到整数的映射表\n  //使用这样的映射表时，可以给它一个字符串作为键并获取关联的整数\n  map&lt;string,int>counters;\n\n  //读取输入，跟踪每个单词出现的次数\n  while(cin>>s)\n  //以刚刚独到的单词作为键从而访问counters\n  //counters[s]表示单词关联的整数，++表示计数加1\n    ++counters[s];\n\n  //输出单词以及相关的数目\n  for(map&lt;string,int>::const_iterator it = counters.begin(); it != counters.end(); ++it)&#123;\n\n    //映射表的每个元素都为一个数对，first成员包含键，second成员包含关联的值\n    cout &lt;&lt; it->first &lt;&lt;\"\\t\" &lt;&lt; it -> second &lt;&lt; endl;\n  &#125;\n  return 0;\n&#125;\n示例2：生成交叉引用表要求：编写一个程序，产生一个交叉引用表，指示每一个单词是在输入中哪个地方出现\n预备知识：\n\n读入一行而非一个单词，所以需用split将每一行单词分离开\nsplit函数作为xref函数的一个参数，即我们在一行中查找单词时所采用的方法\n数据结构：映射表 = &lt;输入中不同的单词,单词出现的全部行的行编号&gt;\n\n实现：\n\ngraph TD\n调用xref建立一个保存行编号的数据结构-->for语句记住间接引用一个映射表迭代器会产生一个pair类型的值\n\ncross.cpp\nint main()\n&#123;\n  //默认使用split来调用xref\n  map&lt;string,vector&lt;int>  > ret = xref(cin);\n\n  //输出结果\n  for (map&lt;string,vector&lt;int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)&#123;\n    //输出单词\n    cout &lt;&lt; it->first &lt;&lt; \"occurs on lines(s):\";\n\n    //后面跟随一个或多个行编号\n    vector&lt;int>::const_iterator line_it = it -> second.begin();\n    cout &lt;&lt; *line_it ; //输出第一个行编号\n\n    ++line_it;\n\n    //如果有则输出其余行编号\n    while(line_it != it -> second.end())&#123;\n      cout &lt;&lt; \",\" &lt;&lt; *line_it;\n      ++line_it;\n    &#125;\n    //换一个新行以便将每一个单词与下一个分隔开\n    cout &lt;&lt; endl;\n  &#125;\n  return 0;\n&#125;\nxref.cpp\nmap&lt;string,vector&lt;int>>\n  xref(istream&amp; in, vector&lt;string> find_words(const string&amp;) = split)\n    //xref(cin); 等价于xref(cin,split);\n    //xref(cin,find_urls);\n  &#123;\n    string line; //保存输入的每一行\n    int line_number = 0;//保存当前正在处理的行的行编号\n    map&lt;string,vector&lt;int> > ret; //注意是> >而非>>\n\n    //读下一行\n    while(getline(in,line))&#123;\n      ++line_number;\n\n    //将输入行分割成单词\n    vector&lt;string>words = find_words(line);\n      //记住出现在当前行的每一个单词\n      for(vector&lt;string>::const_iterator it = words.begin(); it != words.end(); ++it)\n        ret[*it].push_back(line_number);\n    &#125;\n    return ret;\n  &#125;\n示例3：生成语句要求：可以用一个映射表编写一个程序，这个程序描述了一种语句结构并且能生成符合这个描述的随机的语句\n例如：我们能将一个英语语句描述成一个名词与一个动词或者是一个名词或动词与一个对象的组合等。\n呈现规则typedef vector&lt;string> Rule;\ntypedef vector&lt;Rule> Rule_collection;\ntypedef map&lt;string,Rule_collection> Grammar;\n读入文法read_grammar.cpp\n//将输入流读数据并生成一个文法作为输出\nGrammar read_grammar(istream&amp; in)\n  Grammar ret;\n  string line;\n\n  //读输入\n  while(getline(in,line))&#123;\n    //将输入分割成单词\n    vector&lt;string> entry = split(line);\n    if(!entry.empty())\n    //用种类来存储相关联的规则\n    ret[entry[0]].push_back(\n      Rule(entry.begin()+1,entry.end()));\n    &#125;\n    return ret;\n  &#125;\n生成语句读进全部的输入之后，必须生成一个随机的语句\nmain1.cpp\nint main()\n&#123;\n  //生成语句\n    //读入文法，根据文法声生成一个语句\n  vector&lt;string> sentence = gen_sentence(read_grammar(cin));\n\n  //输出第一个单词，如果存在\n  vector&lt;string>::const_iterator it = sentence.begin();\n  if (!sentence.empty())&#123;\n    cout &lt;&lt; *it;\n    ++it;\n  &#125;\n\n  //输出其余的单词，每一个单词之前都有一个空格\n  while (it != sentence.end()) &#123;\n    cout &lt;&lt; \" \" &lt;&lt; *it;\n    ++it;\n  &#125;\n  cout &lt;&lt; endl;\n  return 0;\n&#125;\n\ngen_sentence.cpp\n//gen_sentence.cpp\nvector&lt;string> gen_sentence(const Grammar&amp; g)\n&#123;\n  vector&lt;string>ret;\n    //对gen_aux的调用是一个请求，请求使用文法g并依照&lt;sentence>规则生成一个语句\n  gen_aux(g, \"&lt;sentence>\",ret);\n  return ret;\n&#125;\ngen_aux.cpp\n//gen_aux.cpp\n//功能为：展开那个作为它的第二个参数而被传递过来的输入字符串\n//具体实现方式为：第一个参数为文法，在其中查找这个字符串，并将输出放到第三个参数中\nvoid gen_aux(const Grammar&amp; g, const string&amp; word, vector&lt;string>&amp; ret)\n&#123;\n    //如果word不是被括起的，压栈\n    //如果word被括起的，则找到一条相应规则，展开这条规则从而代替这个被括起的种类\n  if( !bracketed(word))&#123;\n    ret.push_back(word);\n  &#125;else &#123;\n    //为对应于word的规则定位\n    Grammar::const_iterator it = g.find(word);\n    if(it == g.end())\n      throw logic_error(\"empty rule\");\n   //获可能的规则集合\n   const Rule_collection&amp; c = it ->second;\n\n   //从规则集合中随机选择一条规则\n   const Rule&amp; r = c[nrand(c.size())];\n\n   //递归展开所选定的规则\n   for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)\n    gen_aux(g, *i,ret);\n  &#125;\n&#125;\n\n//brackted用于检查某个单词是否括起\nbool brackted(const string&amp; s)\n&#123;\n    return s.size() > 1 &amp;&amp; s[0] == '&lt;' &amp;&amp; s[s.size() - 1] == '>';\n&#125;\nnrand.cpp\nint nrand(int n)\n&#123;\n  if (n &lt;= 0 || n > RAND_MAX)\n  throw domain_error (\"Argument to nrand is out of range\");\n  const int bucket_size = RAND_MAX / n;\n  int r;\n  do r = rand() / bucket_size;\n  while (r >= n);\n    return r;\n&#125;\n\n为了避免一些缺陷，并不采用rand()%n的做法\n\n关于性能的一些说明关联数组很可能是根据Hash表实现的，Hash表可以非常快速，但是同时也带来一些缺点\n\n对于每一种键类型，用户必须提供一个散列函数，散列函数会从键的值计算出一个适当的哈希值\n散列表的性能对散列函数细节极度敏感\n通常找不到一个简单方法按一个有用的顺序检索散列表的元素\n\n按照散列函数来实现C++关联容器是困难的\n\n键类型只需要&lt;运算符或者等价的比较函数\n无论键的值是什么，访问一个关联容器中有特定键的元素所耗费的时间都是容器中元素总数的对数\n关联容器的元素总是根据键进行排序的\n\n","slug":"CPP/C7 使用关联容器","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"916993f3303db0d9f66253cbc5cc5316","title":"CPP8 编写泛型函数","content":"编写泛型函数本书第一部分：编写程序以便解决某些具体问题\n\n使用c++语言基本要素以及标准库提供的抽象\n\n从这一章开始：学习编写抽象的方法\n\nC8 讨论泛型函数\nC9-C12 演示如何实现抽象数据类型\n\n从C13开始：学习面向对象程序设计方法OOP\n什么是泛型函数表面上看，我们在编写函数时都要清楚函数的参数以及返回值的类型\n实际上，我们已经用过了那些在使用之前并不知道其参数以及返回类型的函数\n例如：\n\nfind函数在任何种类的容器中查找任何类型适当的值\n上述用法表明了：我们在使用find函数之前，并不知道它的参数或返回类型是什么\n\n语言支持泛型函数并非难事，但是当我们说find函数能接受“任何适当类型”的参数时，我们表达的意思是什么？如：\n我们想让希望使用find函数的人知道它对特定类型参数是否有效，该如何描述这个函数的行为？\n答案分为两部分\n\n位于语言内部：函数对一个未知类型的参数的使用方式会对这个参数的类型产生约束\neg：x+y requires x,y has the specific type for which x+y is defined\n\n\n位于语言外部：标准库对其函数参数的约束条件所采用的组织方式\neg：迭代器\nA type is an iterator if and only if it supports a particular collection of operations in a particular way\n迭代器概念并非C++所特有，但它是标准库组织的一个基本组成部分\n\n\n\n\n\n未知类型的中值\n\n\n\n名词\n定义\n\n\n\n\n模板函数\n实现泛型函数的语言特征\n\n\n模板\n允许我们为一个行为特性相似的函数族（类型族）编写一个单独的定义\n\n\n族中各个函数（或类型）间差别\n归因于它们的模板参数的类型不同\n\n\n模板背后的关键概念\n不同类型的对象仍然可以享有共同的行为特性\n\n\n模板参数\n允许我们按照共同的行为特性编写程序\n\n\n\n\nmedian_template.cpp\ntemplate &lt;class T>\nT median(vector&lt;T> v)\n&#123;\n    typedef typename vector&lt;T>::size_type vec_sz;\n    vec_sz size = v.size();\n    if(size == 0)\n        throw domain_error(\"median of an empty vector\");\n\n        sort(v.begin(),v.end());\n        vec_sz mid = size/2;\n        return size % 2 == 0? (v[mid]+v[mid-1]) /2 : v[mid];\n&#125;\n\n\n\n\n代码\n含义\n\n\n\n\ntemplate &lt;class T&gt;\n模板头告知系统环境，我们定义的是一个模板函数，而且这个函数将有一个类型参数T出现时认为T命名了一个类型\n\n\ntypename\n告知系统环境，vector&lt;T&gt;::size_type是一个类型名，即使系统环境还不知道类型T具体代表什么\n\n\n(v[mid]+v[mid-1])/2\n在了解了v的元素类型下，才会知道v[mid]和v[mid-1]的类型\n\n\n\n\n模板实例化对vector&lt;int&gt;类型调用median→系统环境高效创建并编译这个函数的一个实例→使用int代替所有对T的使用\n对vector&lt;double&gt;类型调用median→系统环境高效创建并编译这个函数的一个实例→使用double代替所有对T的使用\n也即：系统环境产生了两个版本的median\n当我们无法确切说明编译器将如何处理实例化时，应该牢记：\n\nedit-compile-link，实例化动作通常不是在编译而是在链接期间发生\nIt is not until the templates are instantiated that the implementation can verify that the template code can be used with the types that were specified.\nHence, it is possible to get what seem like compile-time errors at link time.\n\n\n编写自己模板时\n为了对模板实例化，要求模板的定义（不仅是声明）必须是系统环境可以访问的\n定义了模板的源文件和头文件都必须是可访问的\n\n\n\n\n\n泛型函数和类型在设计和使用模板时，最困难的部分：精确理解模版和能被用于此模板的“适当的类型”之间的交互作用。\n数据结构独立性如果库使用迭代器从而要求我们两次提到c，那么我们有可能只需要编写一个find函数就可以在任何容器的任何连续的一部分中查找到一个值。\n泛型函数为什么要用迭代器参数而不直接使用容器参数：\n\n如果我们使用迭代器，就可以访问到具有特殊意义的但又不存在于容器中的元素\n\n算法与迭代器库定义了5种迭代器\n\n迭代器$\\sim$操作集合$\\sim$容器可以使用哪些算法$\\sim$访问容器元素的策略\n\n\n\n\n\n访问策略\n对应库函数\n迭代器应该支持的操作\n\n\n\n\n顺序只读访问\nfind\n输入迭代器\n\n\n顺序只写访问\ncopy\n输出迭代器\n\n\n顺序读-写访问\nreplace\n正向迭代器\n\n\n可逆访问\nreverse\n双向迭代器\n\n\n随机访问\nbinary_search\n随机访问迭代器\n\n\n\n\n\n\n\n\n迭代器类型\n支持操作\n\n\n\n\n输入迭代器\n++,==,!=,*\n\n\n输出迭代器\n不能在对*it的两个赋值运算之间执行超过一次的++it操作也不能在没有对it进行递增的情况下对it进行多次赋值\n\n\n正向迭代器\n*it,++it和it++,it == j和it != j,it -&gt; member\n\n\n双向迭代器\n正向迭代器和--\n\n\n随机访问迭代器\n双向迭代器和算术运算\n\n\n\n\nfind_template.cpp调用find(begin,end,x)的结果\n\n在区间[begin,end)中第一个满足*iter = x的iter\nend,不存在*iter = x的iter时\n\ntemplate &lt;class In,class X> In find(In begin,In end,const X&amp; x)\n&#123;\n    while (begin != end &amp;&amp; *begin != x)\n        ++begin;\n    return begin;\n&#125;\n// ++ 用于实现顺序访问\n// * 用于访问iter指向的容器元素\n// != 用于比较iter是否相等\n使用其他操作时候的递归风格find_template2.cpp\ntemplate &lt;class In,class X> In find(In begin,In end,const X&amp; x)\n&#123;\n  if (begin == end || *begin == x)\n      return begin;\n \tbegin++;\n  return find(begin,end,x)\n&#125;\ncopy_template.cpptemplate &lt;class In,class out>\nOut copy(In begin,In end,Out dest)\n&#123;\n  while(begin != end)\n    *dest++ = *begin++;\n  return dest;\n&#125;\n//前两个迭代器指示了一个序列，函数会从这个序列进行复制\n//第三个指示了目的序列的开头\n//begin和end是输入迭代器，只用它们读元素\nreplace_template.cpptemplate&lt;class For,class X>\nvoid replace(For beg,For end,const X&amp; x,const Y&amp; y)\n&#123;\n  while(beg != end)&#123;\n    if(*beg == x)\n      *beg = y;\n    ++beg;\n  &#125;\n&#125;\n//这个函数检查了在区间[beg,end)中的元素并用y来替换所有等于x的元素\nreverse_template.cpptemplate&lt;class Bi>\nvoid reverse&lt;Bi begin,Bi end>\n&#123;\n  while (begin != end)&#123;\n    --end;\n    if (begin != end)\n      swap(*begin++,*end);\n  &#125;\n&#125;\n//从向量的尾部自后向前逆向推进end并从向量的开头正向推进begin\n//这个过程中，交换它们所指向的元素\nbinary_search_template.cpptemplate &lt;class Ran,class X>\nbool binary_search(Ran begin,Ran end,const X&amp; x)\n&#123;\n    while (begin&lt;end)\n    &#123;\n        Ran mid = begin + (end - begin) / 2;\n        if (x &lt; *mid)\n        &#123;\n            end = mid;\n        &#125;\n        else if(*mid &lt; x)\n            begin = mid + 1;\n        else return true;\n    &#125;\n    return false;\n&#125;\n\n迭代器区间和越界值为什么要指定紧位于区间最后的元素之后的一个位置？\n\n区间无元素，无法找到一个最后的元素以标记终点\n如果用迭代器标记区间终点，就可以仅是为了判定相等或不相等而去比较迭代器，而且使用了这种标记方法之后，就无须再定义“一个迭代器小于另一个迭代器”的具体意义\n这种方式下可以以一种自然的方式表示“区间之外”\n\n输入和输出迭代器使用迭代器提高适应性split_template.cpp\n​    \ntemplate &lt;class Out>\nvoid split(const string&amp; str,Out os)&#123;\n    typedef string::const_iterator iter;\n\n    iter i = str.begin();\n    while (i != str.end())\n    &#123;\n        i = find_if(i,str.end(),not_space);\n\n        iter j = find_if(i,str.end(),space);\n\n        if (i != str.end())\n            *os++ = string(i,j);\n        i = j; \n    &#125;\n&#125;\n调用形式\nsplit(s,back_inserter(word_list));\n测试程序\nint main()\n&#123;\n  string s;\n  while(getline(cin,s))\n    split(s,ostream_iterator&lt;string>(cout,\"\\n\"));\n  return 0;\n&#125;\n","slug":"CPP/C8 编写泛型函数","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"260ea000f421b3eddad461c7e5d42b80","title":"CPP9 定义新类型","content":"定义新类型可以将C++分成两种\n\n内部类型 -&gt; 被定义成语言核心的一部分\n自定义类型(class type) \n\nC+设计思想\n\n应该让程序员创建与内部类型一样易于使用的类型\n创建具有简明直观的接口的类型\n实质性的语言支持\n类的设计过程中的体验和判断\n\n\n\n\n\nStudent_info回顾三个问题\n\n希望使用我们的函数的程序员必须遵从某些规定\n代码在读取数据后不改变\nStudent_info结构的接口非常分散\n\n自定义类型自定义类型：用于将相关的数据值组合在一个数据结构中的技术\n\n能够将这个数据结构当做一个单独的实体进行处理\n使用Student_info类型的程序员可以而且必须直接操作这些数据元素\n由于Student_info定义并没有限制对数据元素的访问\n由于对于Student_info并没有其他可用的操作\n\n\n我们的要求\n不想让用户直接访问数据\n希望将Student_info对象的存储方式的实现细节隐藏起来\n\n\n\n\n\n成员函数非成员函数保护将grade和read函数定义为成员后，修正了问题的一半\n\nStudent_info类型的用户不需要再直接操控对象的内部状态\n我们希望将数据隐藏起来并允许用户仅仅通过成员函数访问这些数据\n\nStudent_info.cpp\nclass Student_info&#123;\npublic:\n    std::string name() const &#123;return n;&#125;\n    bool valid() const &#123;return !homework.empty();&#125;\n\n    std::istream&amp; read(std::istream&amp;);\n    double grade() const;\n\nprivate:\n    std::string n;\n    double midterm,final;\n    std::vector&lt;double> homework;\n&#125;;\nbool compare (const Student_info&amp;, const Student_info&amp;);\n其中\n\nPublic：接口可供调用\nPrivate：内部数据不可改变\n\nClass于Struct的区别\n\n\n\n\n类型\n特点\n\n\n\n\nclass\n在第一个{和第一个保护标识符之间全部成员都是私有\n\n\nstruct\n在第一个{和第一个保护标识符之间全部成员都是公有\n\n\n\n\nStudent_info类Student_info.cpp\nclass Student_info&#123;\npublic:\n    std::string name() const &#123;return n;&#125;\n    bool valid() const &#123;return !homework.empty();&#125;\n\n    std::istream&amp; read(std::istream&amp;);\n    double grade() const;\n\nprivate:\n    std::string n;\n    double midterm,final;\n    std::vector&lt;double> homework;\n&#125;;\nbool compare (const Student_info&amp;, const Student_info&amp;);\n构造函数构造函数的作用 ：定义对象的初始化方式\nclass Student_info&#123;\n  public:\n  \tStudent_info(); //构造一个空的Student_info对象\n  \tStudent_info(std::istream&amp;); // 读一个流从而构造一个对象\n&#125;\n\n\n\n\n构造函数\n特点\n举例\n\n\n\n\n默认构造函数\n不带参数的构造函数\nStudent_info::Student_info():midterm(0),final(0)&#123; &#125;\n\n\n带参数的构造函数\n带参数的构造函数\nStudent_info::Student_info() (istream&amp; is)&#123;read(is);&#125;\n\n\n\n\n构造函数初始化程序\n\n\ngraph TD\n实现分配内存以保存这个对象 --> 按照构造函数初始化程序列表而对对象进行初始化\n--> 执行构造函数的函数体\n\n使用Student_info类main.cpp\nint main()\n&#123;\n    vector&lt;Student_info> students;\n    Student_info record;\n    string::size_type maxlen = 0;\n\n    while (record.read(cin))\n    &#123;\n        maxlen = max(maxlen,record.name().size());\n        students.push_back(record);\n    &#125;\n\n    sort(students.begin(),students.end(),compare);\n\n    for (vector&lt;Student_info>::size_type i = 0; i != students.size(); ++i)\n    &#123;\n        cout &lt;&lt; students[i].name() &lt;&lt; string(maxlen + 1 - students[i].name.size(),' ');\n\n        try\n        &#123;\n            double final_grade = students[i].grade();\n            streamsize prec = cout.precision();\n            cout &lt;&lt; setprecision(3) &lt;&lt; final_grade &lt;&lt; setprecision(prec) &lt;&lt; endl;\n        &#125;\n        catch(domain_error e)\n        &#123;\n            cout &lt;&lt; e.what() &lt;&lt; endl;\n        &#125;\n        \n    &#125;\n    return 0;\n&#125;\n小结\n\n\n\n名词\n定义\n\n\n\n\n用户自定义类型\n被定义成struct或者class\n\n\n保护标识符\n控制着对一个类类型的成员的访问方式\n\n\n成员函数\n与数据相同，类型也可以定义成员函数对一个特定对象的成员函数调用实际上隐含着对这个对象的引用成员函数既可以在类定义的内部定义，也可以在类定义以外的地方定义\n\n\n构造函数\n特殊的成员函数定义类型的对象是如何被初始化的\n\n\n构造函数初始化程序列表\n构造函数初始化程序是一个用逗号分隔的”member-name(value)”的列表每一个member-name所表示的成员都会被初始化成相关联的value值\n\n\n\n\n","slug":"CPP/C9 定义新类型","date":"2021-08-26T03:46:33.000Z","categories_index":"CPP","tags_index":"CPP","author_index":"Rambo"},{"id":"a7f1ed76601ff92b732ab0f222c2a42f","title":"C1_计算机系统漫游","content":"A Tour of Computer Systems\n计算机系统漫游主要内容\n计算机系统：硬件+软件\n内部信息\n表示为一组组的位\n依据context有不同的解释方式\n编译过程被翻译成不同形式\n\n\n层次结构\n复制$\\to$开销\n高层次存储设备作为低层次设备的cache\n\n\n操作系统\n文件$\\to$I/O\n虚拟内存$\\to$主存和磁盘\n进程$\\to$处理器、主存、I/O\n\n\n网络\n提供计算机系统之间通信的手段\n特殊系统角度来看，网络视为I/O\n\n\n\n#include&lt;stdio.h>\nint main()\n&#123;\n  printf(\"hello,world\\n\");\n  return 0;\n&#125;\n跟踪hello程序生命周期，介绍出现的关键概念、专业术语和组成部分\n\n创建$\\to$运行$\\to$输出简单消息$\\to$终止\n\n信息就是位+上下文\n\n\n\n名词\n定义\n\n\n\n\n源程序\n程序员通过编辑器创建并保存的文本文件实际上就是一个由值0和1组成的位序列\n\n\n字节\n8个位为一个字节\n\n\n文本文件\n只由ASCII字符构成的文件\n\n\n二进制文件\n所有其他文件\n\n\nhello.c表示方法说明的基本思想\n系统中所有的信息都是由一串比特表示的\n\n\n区分不同数据对象的方法\n读到这些数据对象时的上下文\n\n\n\n\n\n\n\n\n\n\n\n\n\nC语言起源\n\n与Unix系统关系密切\n大部分Unix内核以及所有支撑工具和函数库都用C语言写的\n\n\n小而简单\n为实践目的设计的\n\n\n程序被其他程序翻译成不同的格式\n\ngraph TD\nhello.c  \n--预处理器-->hello.i\n--编译器-->hello.s\n--汇编器-->hello.o\n--链接器-->hello\n\n源程序 \n--根据以#开头的命令修改原始C程序--> 修改了的源程序  \n--文本文件.i翻译成文本文件.s--> 汇编程序  \n--.s翻译成机器语言指令并打包-->  可重定位目标程序  \n--链接多个.o-->  可执行目标程序\n\nprintf.o --链接器-->hello\n\n\n\n\n\n\n\n\n\n\nGNU项目\n\nGNU’s Not Unix\n开发出一个完整的类Unix系统，源代码能够不受限制地被修改和传播\n包括\nEMACS编辑器\nGCC编译器\nGDB调试器\n汇编器\n链接器\n处理二进制文件的工具\n其他部件\n\n\nfree software\nfree speech :heavy_check_mark:\nfree beer :negative_squared_cross_mark:\n\n\n\n了解编译系统如何工作大有益处\n优化程序性能\n了解一些机器代码以及编译器将不同C语句转化为机器代码的方式\n\n\n理解链接时出现的错误\n无法解析引用\n静态变量、全局变量\n静态库、动态库\n命令行上排列库的顺序\n为什么有些链接错误直到运行时才会出现\n\n\n避免安全漏洞\n缓冲区溢出错误\n\n\n\n处理器读并解释储存在内存中的指令系统硬件组成\n\n\n\n\n硬件\n作用\n\n\n\n\n总线\n携带信息字节并负责在各个部件间传递通常被设计成传送定长的字节块，word\n\n\nI/O设备\n系统与外部世界的联系通道\n\n\n控制器\n在I/O总线和I/O设备之间传递信息I/O设备本身或者系统的主印制电路板上的芯片组\n\n\n适配器\nI/O设备本身或者系统的主印制电路板上的芯片组一块插在主板插槽上的卡\n\n\n主存\n临时存储设备，处理器执行程序时，存放程序和程序处理的数据物理上：一组DRAM芯片组成逻辑上：一个线性的字节数组，每个字节都有其唯一的地址(数组索引)\n\n\n处理器\n解释(或执行)存储在主存中指令的引擎\n\n\n程序计数器(PC)\n处理器的核心一个大小为一个字的存储设备(或寄存器)任何时候，PC都指向主存中的某条机器语言指令\n\n\nRegister file\n小存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一名字\n\n\nALU\n计算新的数据和地址值\n\n\n\n\ngraph TD\n系统通电\n--> 处理器执行程序计数器指向的指令\n--> 更新程序计数器\n--> 指向下一条指令\n\n\n\n指令集架构：描述每条机器代码指令的效果，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤\n\n微体系结构：描述处理器实际上如何实现的\n\n\n操作\n\n\n\n\n操作类型\n具体\n\n\n\n\n加载\n从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容\n\n\n存储\n从寄存器复制一个字节或者一个字道主存的某个位置，覆盖这个位置上原来的内容\n\n\n操作\n两个寄存器的内容复制到ALU，ALU做算术运算，并将结果放到一个寄存器中覆盖其内容\n\n\n跳转\n从指令本身抽取一个字，将这个字复制到PC中，覆盖PC中原来的值\n\n\n\n\n运行hello程序高速缓存至关重要\n问题：系统花费大量时间把信息从一个地方搬到另一个地方，这些复制就是开销\n目标：使这些复制操作尽可能快地完成\n处理器-主存 读取数据差异较大\n针对这种差异，系统设计者采用更小更快的存储设备 cache，作为暂时的集结区域，存放处理器近期可能需要的信息\n系统可以获得一个很大的存储器 ，同时访问速度也很快的原因：\n\n利用高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势\n通过让cache存放可能经常访问的数据，大部分内存操作都能在快速的cache中完成\n\n存储设备形成层次结构\n主要思想：上一层的存储器作为低一层存储器的高速缓存\n操作系统管理硬件\n操作系统：应用程序和硬件之间插入的一层软件\n\n防止硬件被失控的应用程序滥用\n向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备\n\n\n\n\n\n抽象\n硬件\n\n\n\n\n文件\nI/O设备\n\n\n虚拟内存\n主存和磁盘I/O设备\n\n\n进程\n处理器、主存和I/O设备\n\n\n\n\n进程\n\n\n\n名词\n定义\n\n\n\n\n进程\n操作系统对一个正在运行的程序的一种抽象一个系统上可以同时运行多个进程，而每个进程都好像独占使用硬件\n\n\n并发运行\n一个进程的指令和另一个进程的指令交错执行的一个CPU看上去都像是在并发地执行多个进程\n\n\n上下文切换\n通过处理器在进程间切换实现\n\n\n内核\n操作系统代码常驻主存的部分\n\n\n系统调用\n操作系统将控制权传递给内核，内核执行被请求的操作并返回应用程序\n\n\n\n\n假象：好像系统上只有这个程序在运行，处理器看上去就像在不间断地一条接一条执行程序中的指令\n\ngraph TD\nOS --track-->context --context_switch-->pass_control2another_context\n\n\n线程\n一个进程实际上可以由多个称为线程的执行单元组成\n每个线程都运行在进程的上下文中，并共享同样的代码和全局数据\n\n虚拟内存\n\n\n\n\n名词\n定义\n\n\n\n\n虚拟内存\n为每一个进程提供了一个假象，即每个进程都在独占地使用主存\n\n\n虚拟地址空间\n每个进程看到的内存都是一致的\n\n\n\n\n\n\n\n\n区\n特点\n\n\n\n\n程序代码和数据\n对所有进程来说，代码从同一固定地址开始紧接着是和C全局变量相对应的数据位置\n\n\n堆\n调用像malloc和free这样的C标准库时，堆可以在运行时动态地扩展和收缩\n\n\n共享库\n地址空间的中间部分：C标准库和数学库这样的共享库的代码和数据的区域\n\n\n栈\n位于用户虚拟地址空间顶部，编译器用它来实现函数调用\n\n\n内核虚拟内存\n\n\n\n\n文件字节序列\n\n每个I/O设备都可以视为文件\n所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件实现\n向应用程序提供一个统一视图看待所有I/O\n\n系统之间利用网络通信\n之前，我们一直将系统视为一个孤立的硬件和软件集合体\n实际上，现代系统经常通过网络和其他系统连接到一起\n可将网络视为一个I/O设备\n\n\n重要主题\n系统不仅仅只是硬件，而是硬件和系统软件互相交织的集合体\n\nAmdahl定律\n\n\n\n\n类别\n具体\n\n\n\n\n主要思想\n当我们对系统某个部分加速时其对系统整体性能的影响取决于该部分的重要性和加速程度\n\n\n$T_{old}$\n系统执行某应用程序的时间\n\n\n$\\alpha$\n系统某部分所需执行时间与$T_{old}$的比例\n\n\n$k$\n系统某部分性能提升比例\n\n\n$T_{new}$\n总的执行时间\n\n\n$S$\n加速比\n\n\n主要观点\n要想显著加速整个系统，必须提升全系统中相当大的部分的速度\n\n\n\n\n\nT_{new} = (1-\\alpha)T_{old} + (\\alpha T_{old})/k\n\\\\=T_{old}[(1-\\alpha) +\\alpha/k]\n\n\\\\ S = \\frac{1}{(1-\\alpha)+\\alpha/k}并发和并行\n\n\n\n名词\n定义\n\n\n\n\n并发concurrency\n一个同时具有多个活动的系统$\\to$计算机做的更多\n\n\n并行parallelism\n用并发来使一个系统运行得更快$\\to$计算机做的更快\n\n\n\n\n\n\n线程级并发Thread-Level Concurrency\nBuilding on the process abstraction\n\n\n多处理器系统\n构建一个由单操作系统内核控制的多处理器组成的系统\n\n\n多核处理器\n将多个CPU集成到一个集成电路芯片上\n\n\n超线程Hyperthreading同时多线程simultaneous multi-threading\n一项允许一个CPU执行多个控制流的技术\n\n\n\n\n\n\n指令级并行Instruction-Level Parallelism\n较低的抽象层次上，现代处理器可以同时执行多条指令\n\n\n流水线pipelining\n执行一条指令所需的活动划分成不同步骤\n\n\n超标量super- scalar\n处理器可以达到比一个周期一条指令更快的执行速率\n\n\n\n\n\n\n单指令、多数据并行SIMD Parallelism\n最低层次上，硬件允许一条指令产生多个可以并行执行的操作\n\n\n\n\n\n多处理器的使用从两方面提高系统性能\n\n减少了在执行多个任务时模拟并发的需要\n可以使应用程序运行得更快\n\n计算机系统中抽象的重要性\n程序员无需了解内部工作便可以使用\n练习题\n\n\n","slug":"CSAPP/C1-计算机系统漫游","date":"2021-08-26T03:46:33.000Z","categories_index":"CSAPP","tags_index":"CSAPP","author_index":"Rambo"},{"id":"3d37c1a36f275310395f0cfef8cc99c3","title":"NUDT考研经验贴分享","content":"国防科技大学考研经验贴（英一88）个人情况说明2021年考研报考国防科技大学智能科学学院电子信息-控制方向（专硕），初复试均为第一，具体成绩如下：\n\n其中需要说明的几点\n\n政治还好，正常水平，不过学校政治线为60分，有几个高分大佬被刷\n英语确实出乎意料，有点幸运，不过也是有自己的一套学习方法，希望分享给大家\n数学一也是有一点幸运，蒙的对了不少\n专业课相对简单，基本上会做的都拿到了分\n\n讲在前面的话\n本文目的：分享考研经验给2022考研的各位师弟师妹\n侧重点：顶层心态和方法而非底层细节\n讲在前面的话凝练\n考研没什么了不起，敲门砖而已\n但是既然已经准备要考，赋予一点意义然后努力也是现在能做的最好的事情\n\n\n\n周围的同学们都今年考研，希望大家都上岸，不必二战，赶紧上岸追求新的人生。\n虽然可以给考研中对自己心境、专业知识的打磨赋予一些除去拿到入学敲门砖的额外意义，但是还是把应试通过作为首要目标，有限时间内拿到尽可能多的分。\n专业素养的提升自然是在尘埃落定后更加从容些，但是如果能够以真正提升素养来制定学习目标，在更加深刻理解专业知识之外，对自己更加有利的应该是这种打怪升级过程中的持续动力。\n在这里可能把自己的一些经验分享给大家。涉及到教材选择、具体准备什么的问题经验贴很多了，我只说明自己考研中偏顶层心态和方法的一些经验。更多的是自己的而非别人的经验，大家可以选择适合自己的听一听。同时也要多善于检索，知乎上面很多答案了。\n\n如何在考研数学中取得 140+ 的好成绩？ - 知乎 https://www.zhihu.com/question/21068499\n考研英语一85分上岸经验分享 - 是小太阳啊的文章 - 知乎 https://zhuanlan.zhihu.com/p/366684243\n……\n\n讲在前面的话就是，我很希望自己不用考研，我也很讨厌自己为了应试变得熟练的让人心疼，但是我没有别的选择，如果有的选我想去清华，想保研，可惜没得选。考研经验贴，希望大家理性看待其中的观点。只是希望看到应付枯燥考试之外的一些有趣的、给自己生活来点调剂。\n对自己的认可在考研成绩出来之后得到了进一步的强化。一直做对的事情是困难的，但是至少要向着突破自己的极限那个方向努力。考研不同于高考，只有上岸和落水两种情况，也很难了解到对手的情况，所以正儿八经是跟自己较劲，能做的就是每天百分之一百二的计划，能完成百分之九十其实很是不错。\n在做好谨慎的选择之后尽力奔跑把你的同窗甩在身后，不上岸也没得办法，没法找自己的原因了。\n关于国防科技大学报考情况\n智能科学学院\n控制学硕8个录取5个\n控制专硕15个录取12个\n整体复试差距不大\n\n\n\n考研择校\n冲清华\n清华很难考，自己掂量着办\n不抖机灵了，要量力而行\n上岸了慨叹当时低估了自己的实力固然很难受\n但是落水时外界带来的对自己的怀疑容易在人生关键节点击垮自己\n考研人如何科学地择校择专业？（方法干货） - 大郎神的文章 - 知乎 https://zhuanlan.zhihu.com/p/42883506\n\n\n\n\n总的层面建议\n制定计划\n具体\n不要事无巨细\n恰当的激励机制\n\n\n知识系统化\n锻炼身体\n电子化笔记方便检索\n静下心来\n认真做一件事很重要\n问问自己你真的想要吗？\n\n\n对比是一种很好的学习方法\n\n制定计划\n超额计划\n日记复盘\n好的继续保持\n坏的已经过去\n\n\n\n我在考研过程中一个避免自己浑浑噩噩的度过一天的重要手段是会不停的以超额目标制定详细的计划；通常会定自己能力范围的1.2倍工作量，督促自己完成。\n效率高和被困难击倒时通过日记复盘，复习的好的已经过去，差的也经过复盘挫败感没有那么强。\n\n9.14-9.20\n\n\n\n\n线性代数\n高等数学\n政治(含习题)\n英语\n\n\n\n\n9.14\n讲义C1 习题✅\n1000题C1 A、B✅\n马克思主义的传播1、2✅习题✅\nList7✅\n\n\n9.15\n讲义C2 习题✅\n1000题C2、3 A、B、C✅\n中国共产党的诞生1、2✅习题✅\nList8✅\n\n\n9.16\n讲义C3 习题✅\n1000题C4 A、B、C✅\n大革命的失败与土地革命的兴起1、2✅\nList9✅\n\n\n9.17\n讲义C4 习题✅\n1000题C5 A、B、C✅\n抗日战争1、2✅\nList10⭕️\n\n\n9.18\n讲义C5 习题✅\n1000题C5✅\n抗日战争3、4⭕️\nList11⭕️\n\n\n9.19\n讲义C6 习题⭕️\n1000题C6⭕️\n解放战争与建立新中国1、2⭕️\nList12⭕️\n\n\n\n\n9.21-9.27\n\n\n\n\n高等数学\n英语\n政治\n线性代数\n自动控制原理\n\n\n\n\n9.21\n1000C9✅\nList10✅\n抗日战争3、4✅\n讲义C6 习题✅\n线性系统的时域分析法总结✅\n\n\n9.22\n1000C8✅10✅\nList11⭕️\n解放战争与建立新中国1、2✅\n660刷题C1✅、2、3\n自动控制的一般概念、数学模型总结✅\n\n\n9.23\n1000C14✅\nList12⭕️\n社会主义改造1、2✅\n660刷题4、5、6⭕️\n线性系统的频域分析法⭕️\n\n\n9.24\n1000C17✅+微分算子预习⭕️\nList13⭕️\n社会主义建设成就与改革✅\n1000题C1、2、3⭕️\n线性系统的频域分析法⭕️\n\n\n9.25\n1000C18 A、B✅\nList14⭕️\n导论与毛泽东思想的形成1、2✅\n1000题C4、5、6⭕️\n线性系统的校正方法⭕️\n\n\n9.26\n1000C13⭕️\nList15⭕️\n毛泽东思想1、2⭕️\n\n线性系统的校正方法⭕️\n\n\n\n\n9.28-10.1\n\n\n\n\n高等数学\n英语\n政治\n线性代数\n自动控制原理\n概统\n\n\n\n\n9.28\n1000C15+微分算子\nList11✅\n毛泽东思想上1、2✅\n所有教辅C1\n7-3.1\n1000题C1\n\n\n9.29\n多元函数微分学18讲+汤家凤+1000题\nList12✅\n毛泽东思想下1、2、3✅\n所有教辅C2\n7-3.2\n1000题C2\n\n\n9.30\n无穷级数18讲+汤家凤\nList13\n邓小平理论\n所有教辅C3\n7-4.1\n1000题C3\n\n\n10.1\n无穷级数1000题\nList14\n三个代表\n所有教辅C4\n7-4.2\n1000题C4\n\n\n\n\n10.5-10.8\n\n\n\n\n自动控制原理\n英语\n政治\n高等数学\n概统\n\n\n\n\n10.5\nC3卢练手+习题✅\nList13+欧路✅\n邓小平3+三个代表✅\n不扎实点C1、2✅\nC1✅\n\n\n10.6\nC3习题✅\nList14+欧路✅\n新时代、总任务✅\n不扎实点C4、10✅\nC2✅\n\n\n10.7\nC4卢练手+习题✅\nList15+欧路✅\n五位一体1、2、3✅\n不扎实点C5、6✅\nC3✅\n\n\n10.8\nC4习题✅\nList16+欧路✅\n五位一体4、5、6✅\n不扎实点C7、8✅\nC4✅\n\n\n10.9\nC5卢练手+习题✅\nList17+欧路✅\n五位一体1、2✅\n不扎实点C9✅\nC5✅\n\n\n10.10\nC5习题\nList18+欧路✅\n新时代内外条件和领导核心1、2✅\n不扎实点C3、11⭕️\nC6\n\n\n10.11\n\n\n思修扫尾✅\n\n\n\n\n\n\n\n四个全面1、2、3、4✅\n\n\n\n\n\n10.12-10.18\n\n\n\n\n数学\n英语\n政治\n自控\n\n\n\n\n10.12\n1987、1988✅\n1986 I、1、2✅\n五位一体✅\nC5习题+章节扫尾✅\n\n\n10.13\n1989、1990✅\n1987 I、1、2✅2001 I、1、2✅\n四个全面、C12-14✅思修法基单选题✅\nC5习题+章节扫尾✅\n\n\n10.14\n1991、1992✅\n2001 3、4、5✅\n毛中特多选C1、C2、C3、C4✅\nC6⭕️\n\n\n10.15\n1993、1994✅\n2005 I、1、2✅\n毛中特多选C5、C6、C7、C8✅\nC6⭕️\n\n\n10.16\n1996、1997✅\n2005 3、4、5✅\n毛中特多选C9、C10✅\nC7⭕️\n\n\n10.17\n1995⭕️1998⭕️\n\n\nC7⭕️\n\n\n10.18\n\n\n\n现控C1⭕️\n\n\n\n\n10.19-10.25\n\n\n\n\n数学\n英语\n政治\n自控\n\n\n\n\n10.19\n1995、1998✅\n2006I、1、2✅\n史纲多选C1、2、3、4✅\nC7习题1✅\n\n\n10.20\n1999、2000✅\n2006 3、4、5✅\n史纲多选C5、6、7、8✅\nC7习题2\n\n\n10.21\n2001、2002✅\n2007I、1、2✅\n史纲多选C9、10、11✅\nC6习题1\n\n\n10.22\n2003、2004✅\n2007 3、4、5✅\n毛中特多选C11、12、13、14✅；思修法基C1、2✅\nC6习题2\n\n\n10.23\n2005、2006✅\n2008I、1、2✅\n思修法基多选C3、4、5、6✅\n现控C1\n\n\n10.24\n2007✅、2008\n2008 3、4、5⭕️\n马原142题开始⭕️\n现控C2\n\n\n\n\n10.26-10.30\n\n\n\n\n数学\n补缺\n英语\n政治\n专业课\n\n\n\n\n10.26\n2008✅\n补缺\n2008 3、4、5✅\n马原C1、2、3、4\n现控C1\n\n\n10.27\n2009✅\n补缺\n2009I、1、2✅\n马原C5、6、7、8\n\n\n\n10.28\n2010\n补缺\n2009 3、4、5✅\n马原多选C1、2\n\n\n\n10.29\n2011\n补缺\n2010I、1、2\n马原多选C3、4\n\n\n\n10.30\n2012\n补缺\n2011 3、4、5\n马原多选C5、6、7\n\n\n\n\n11.9- 11.12\n\n\n\n\n数学\n英语\n单词\n政治\n851\n自然地理\n\n\n\n\n11.9\n二重积分✅\n2011 3、4、5✅\n150个✅\n冲刺笔记 马原结尾✅\n2003及订正\n绪论、元素起源和演化✅\n\n\n11.10\n三重积分✅\n2012 I、2、3✅\n150个✅\n冲刺笔记 毛概1-4✅\n2004\n大气圈化学演化1、2、3、4✅\n\n\n11.11\n线面积分✅\n2012 3、4、5✅\n150个✅\n1000题 马原单选题✅\n2005\n水圈化学组成及演化、生物环境、生命元素✅\n\n\n11.12\n\n2013 I、2、3✅\n150个✅\n1000题 毛概1-4✅\n2006\n考试⭕️\n\n\n11.13\n\n\n150个✅\n1000题 毛概 5-9✅\n\n\n\n\n\n11.14 - 11.17\n\n\n\n\n数学\n英语\n单词\n政治\n851\n\n\n\n\n11.14\n1800物理、引力等等✅⭕️\n2014 I、2、3✅\n150个✅\n冲刺笔记毛概 10-14 + 1000题10-14\n2007✅\n\n\n11.15\n1800幂级数；1000题幂级数⭕️\n2014 3、4、5✅\n150个✅\n冲刺笔记史纲1-3 + 1000题1-3✅\n2008✅\n\n\n11.16\n1800中值定理；1000题中值定理⭕️\n2016 I✅、2、3⭕️\n150个✅\n冲刺笔记史纲4-7 + 1000题4-7✅\n2009✅\n\n\n11.17\n线性代数几何意义⭕️线性代数讲义1-5✅\n2016 3、4、5⭕️\n150个✅\n冲刺笔记史纲8-11 + 1000题8-11⭕️\n2010✅\n\n\n11.18\n张宇预测卷1✅\n\n\n\n2011✅\n\n\n\n\n11.19 -11.22\n\n\n\n\n数学(上午)\n英语(中午)\n851(下午)\n政治(间歇)\n政治马原多选1-8\n\n\n\n\n11.19周四\n张宇预测卷2✅\n2016 2、3+2006翻译\n2012✅\n冲刺笔记史纲8-11 + 1000题8-11✅\n1-3\n\n\n11.20\n张宇预测卷3\n2016 4、5+2007翻译\n2013\n冲刺笔记毛概9-12 + 1000题9-12\n4-6\n\n\n11.21\n张宇预测卷4\n2017 I、2+2008翻译\n2014\n冲刺笔记思修法基 + 1000题\n7-9\n\n\n11.22\n张宇预测卷5\n2017 3、4+2009翻译\n2015\n\n10-12\n\n\n\n\n自动控制原理题海\n\n\n\n\n频域分析\n根轨迹\n校正\n能控能观判断\n极点配置\n\n\n\n\n11.19周四\n课本习题1-5✅\n4-1：4-10✅\n6-1：6-11\n1-5\n1-5\n\n\n11.20\n5-33：5-43\n4-11：4-20\n6-12：6-20\n6-10\n6-10\n\n\n11.21\n5-44：5-54\n4-21：4-30\n6-21：6-30\n11-15\n11-15\n\n\n11.22\n\n4-31：4-40\n6-31：6-40\n16-20\n16-20\n\n\n\n\n数学一\n\n\n\n\n中值定理\n幂级数\n线性代数讲义C1-6\n概率统计复习全书C1-6\n\n\n\n\n11.19周四\n1800P30 11-23\n1800P106 1-10\n1-5\n1-5\n\n\n11.20\n1800P36 17-27\n1800P106 11-20\n6-10\n6-10\n\n\n11.21\n1800P36 28-38\n1800P106 21-31\n11-15\n11-15\n\n\n11.22\n1800P38 39-49\n1800P106 32-42\n16-20\n16-20\n\n\n\n\n12.7 - 12.10\n\n\n\n\n数学模拟题\n政治背诵\n英语背诵\n\n\n\n\n12.7\n李林2 张宇7\n徐涛D1、2、3；肖八1\n2005、2006作文\n\n\n12.8\n李林3 张宇8\n徐涛D4、5、6；肖八2\n2007、2008作文\n\n\n12.9\n李林4 张宇1\n徐涛D7、8、9；肖八3\n2009、2010作文\n\n\n12.10\n李林5 张宇2\n徐涛D10、11、12；肖八4\n2011、2012作文\n\n\n\n\n\n知识的系统化\n建立知识内部联系→学习紧凑、便携→时常复盘变得方便\n\n知识的系统化对于任何一门学科来讲都是事半功倍，通过建立知识的内部联系来将学习紧凑化，便于时刻回顾，通过时间堆砌来掌握。\n参见先前公众号发布的几篇笔记\n\n锻炼身体锻炼身体给我提供了一段缓解复习的疲劳，同时又能够没有负罪感的放空大脑或者思考平时没有空闲思考的”杂念”的easy时光，与此同时强身健体，为祖国健康工作五十年。\n电子化笔记方便检索\n笔记软件：Typora\n可以自己多探索，功能很强大\n美观的笔记也让自己更有动力\n\n\n\n电子化笔记为我的检索提供了很强的便利，同时为我学习提供了动力。很多时候整理出笔记已经成为我学习模式中所必需的一个环节。如同先前整理的概率论中各种分布的对比，尽管开始的整理很耗时，到后面的便利性却日益显著。\n\n关于数学\n计算能力\n基础概念的深刻含义，与生活的接口处的具体应用\n滚动式复习\n知识的系统化\n薄弱点轮番轰炸，不信搞不定。但不要长期钻牛角尖，牛角尖大师就是你\n解题步骤程式化\n\n计算能力\n易忽视\n步骤+计算\n\n\n计算不过关帮不了\n问题\n框架边界不清晰\n计算步骤目的性不强\n\n\n解决办法\n计算时过程记录下来，时常复盘\n\n\n举例\n\n计算能力是复习过程中大家容易忽视的一方面，在知识点的不断巩固过程中，可以有节省时间的想法把解题步骤的思路程式化的写下来，多做几道题找找规律，把解题的框架搞熟是重要的。\n然而框架之中的具体内容就算汤老师也没法拯救你，笔给你之后这张卷子就你来负责。计算粗心、计算量大的情况下脑袋晕都是常见的不必要的丢分之处。\n原因简要点讲可以说是 在具体计算过程中框架边界不清晰、计算步骤目的性不强。\n解决方法我的建议是在平时解题过程中养成良好的解题习惯。分析题目后可以列出程式化的框架，写下来方便自己和阅卷人看，就像是写代码过程中的合理注释不仅利于他人观看，更加利于自己修改。\n\n可以举例给大家说明：\n\n\n\n基础概念的深刻理解及与生活接口处的具体应用数学学习过程中，个人经验就是大部分非数学专业的普通同学，我们的数学抽象能力没有那么强，很难从看似晦涩的定理中寻找对我们生活有启发的部分，其实这也暗含了一种目的导向型的学习方法，具体不展开。\n所以能把简单的问题高度抽象化很考验我们的数学功底，但是能把抽象化的定理具体到身边的具体事例并且讲解清楚又很考验我们对于定理的准确理解和具化能力。\n以下是个人的理解，但是毕竟水平有限\n高等数学\n运动的三维世界的精细描述\n\n高等数学对我们这个处于运动中的三维及以下的世界作出了精细的描述，以抽象的数学语言来解决生活中一个个具体的、繁杂的问题。\n具体的情况可以看看下面这个表格，理解很浅显\n\n\n\n\n知识点\n实际应用\n\n\n\n\n函数极限与连续\n极限和无限分割的思想是沟通离散和连续的桥梁\n\n\n一元函数微分学\n变化率\n\n\n一元函数积分学\n无限分割再组合，化不规则为规则\n\n\n多元函数微分学\n不同方向变化率\n\n\n二重积分\n曲顶柱体的体积……\n\n\n微分方程\n生活中的变化关系很多时候是隐式的，需要求解出显式解\n\n\n无穷级数\n用解析的形式来逼近函数\n\n\n多元函数积分学预备知识\n构建了一套三维空间下简便描述元素的数学语言\n\n\n多元函数积分学\n三维空间中的质量等的求解\n\n\n\n\n线性代数\n代数角度\n方程组求解\n符号简化计算的表达\n\n\n几何角度\n空间变换\n旋转矩阵\n平移向量\n……\n\n\n\n\n推荐材料\nhttps://www.bilibili.com/video/BV1ys411472E?share_source=copy_web\n线性代数的几何意义\n\n\n\n数值计算角度引入了表示方程组、数据组、变换关系的符号语言从而简化计算的描述；同时其中的变换思想又构建了现实生活或者更高维空间中无处不在的变换情形。\n当时整理了一些常见的表达式及其对应的几何意义，在台式机里面，可能后面会整理出来。\n\n\n\n概率论与数理统计概率论与数理统计没学明白，最后一道大题题目也没太看懂，没太大发言权。很浅显的理解，起源于博弈，终止于对于现代大厦的统计学描述？有点描述不来，太菜了。还要好好钻研一下。\n滚动式复习\n目的\n复习紧凑\n知识点多次接触，消除恐惧\n\n\n注意\n分章节可以适当选择性跳过留到后面处理\n章节内部知识点耦合程度较高不适宜分散开复习\n\n\n\n滚动式复习的目的在于使得复习紧凑，以及对知识点的多次接触，消除恐惧，提升效率。\n我的计划通常是遇到不会的就先记下来，后面统一处理，但是这样的比较坏的一点是基础概念不掌握容易引发后面一系列的不懂，很有挫败感。\n所以建议还是，比较难的章节可以稍微放一放，但是章节内部耦合的小细节还是尽量今日事今日毕。轮胎滚起来！Dejavu!\n\n知识的系统化\n结构化知识更易被接受\n知识系统化后变得便携、高密度；方便随时复习\n输入输出构建网图\n\n通常来讲我们的大脑容易接受结构化的知识，类比思维导图相较于文字描述更容易被大家接受。就是因为知识的整合、结构化使得内部的联系把知识点串接起来；知识点的耦合、内部逻辑关系把零散的化为整体的，便携式知识方便了大脑的时常回顾。\n正反馈机制下 我们很难说是这样结构化的知识体系 还是时间的堆砌 提升了我们对知识理解的效率。\n但是你并不需要思考效率提升的原因，就和理解这个世界一样。通常来说世界的本原那些终极问题对于饭都吃不饱的人来说指导意义性价比较低，我们只需要了解外部的接口就很是足够。\n下面讲具体方法：\n可以通过对于知识点的输入和输出构建网图，比如说三重积分的输入端应用到了定积分的求解、三维空间的立体建模；输出端应用到高斯公式的另一种求解办法等。\n薄弱点轮番轰炸\n拒绝鸵鸟思维\n\n这一点和滚动式复习有些类似，但是换成了薄弱点的轰炸。单独拎出来说明很重要，拒绝鸵鸟思维。\n认为这个知识点是不重要的、不考的是危险的，不如大方承认我不会这一点，这个知识点有些别扭但是并非不可攻破，然后多花时间轮番轰炸。这样起码在考场上碰到有心理优势。\n\n\n解题步骤程式化看似很应试，但是背后其实是抽象一般规律而后应用到各个个体的实际应用。\n解决一类问题的通用方法，或者说观千剑而后识器。\n体育运动员训练也是如此，不断训练使得应对特殊情况成为常态，最后没有特例，都烂熟于心。\n关于英语\n词汇量很重要，但在阅读中掌握更重要。单词背一大堆不做阅读对我而言效率不是太高\n精读比泛读效率更高\n阅读先看题后阅读\n\n词汇量是能够读懂文章的重要基础，但是光有词汇量很难拿高分。我的建议是\n首先花两个小时把英语考纲词汇中完全看得懂的词汇剔除掉，把剩余单词摘录出来，墨墨背单词也好，欧路词典生词本也好，手抄也好，总之剩下的单词才是重点。\n\n单词背过一遍后便可以开始精读阅读。\n具体流程可以是：\ngraph LR\n\n读问题 -->\n答案翻译  -->\n读文章 -->\n勾画单词.与问题相关语句标注题号 -->\n再读问题 -->\n回到标号处解题\n\n \n在精读过程中，可以把所有含糊的句子都逐字翻译出来，一开始这样的过程很痛苦，但是我的经验是对于你阅读心境的培养和翻译题的语感有很大的帮助，前者其实更重要些。\n\n\n\n\n\n\n关于专业课\n基础概念很重要\n真题比基础概念还重要\n提前联系认识的师兄师姐可以避免一些坑，适当时候发个红包什么的也是应该的，人家也是花了时间的\n\n资料分享\nhttps://pan.baidu.com/s/1GuY0ZMqZvyLguUspWA7zeA 提取码: wck3\n更多学习资料可关注公众号\n\n","slug":"Exam/考研经验贴知乎","date":"2021-08-26T03:46:33.000Z","categories_index":"Exam","tags_index":"Exam","author_index":"Rambo"},{"id":"16c6197a747c160400b2f8933851aa25","title":"Read1 山月记","content":"山月记 中岛敦\n对于中国文化故事的了解和再创造\n寓思想于故事\n言语之优美，寥寥数笔已入作者营造的环境\n\n阅读这本书的过程中，最大的感受是是日本作家对于中国文化的解读。\n由日本视角分析中国故事，得出自己的结论，日文写作后翻译为中文，行文之流畅，读起来是一种享受，这实在是难得的。很多时候对于翻译腔的文学小说类很多时候没有办法提起兴趣来读，这本书却恰恰相反。\n山月记\n\n\n\n\n\n\n\n\n\n我立刻就想到了死。恰好这时，一只兔子在我眼前跑过。我一看到它，体内的人性就踪迹皆无了。等到人性再次恢复的时候，发现自己的嘴上已沾满了兔血，身边撒落着兔毛。这就是我变成老虎后的首次经历。自此至今，我的所作所为，实在是难以启齿。只是一天之中，必定有数小时恢复人性。在此时间内，我与往日一样，能够说人话，思考复杂的问题，甚至还能背诵经书章句。以这样的‘人心’来看自己作为老虎的暴虐行径，回顾自己的命运之际，便是最觉可悲、恐惧与愤慨之时。然而，随着光阴的流逝，就连这恢复人性的时间也越来越短了。过去，我会为自己变成老虎而惊诧不已，最近却发现，自己竟在为曾经是一个人而纳闷了。真叫人不寒而栗。也许再过些时日，我心中的人性就会被兽性所淹没，如同旧宫基石，渐渐地为泥沙所淹没一般。如此，我将彻底忘却过去的一切，作为一只老虎狂奔呼啸，即便像今天这样遇见你也会认不出故人旧友，将你撕裂吞噬也毫不后悔了吧。由此看来，恐怕无论是野兽还是人类，原本都是别种物体，最初还记得自己是什么，尔后便渐渐忘却，认定自己从来就是如此模样了。唉，这些都无关紧要。待到心中的人性消失殆尽，或许反倒能让我心安理得吧。可尽管这样，我心中的人性，依然为此而感到无比地惶恐。唉，对于终将忘记曾经是人，我是多么地惶恐、悲切和沉痛啊。如此心情，是无人能懂的。无人能懂。若非有着与我相同的遭遇，是绝不会懂的。哦，对了，在尚未彻底丧失人性之前，我有一事相求。”\n这个心境，自卑与自傲的矛盾，跟自己大一时候的心境十分相像。胸怀大志却又虚度光阴，在每日稀稀拉拉的课程安排中渐渐迷失自我，不断悔恨却又无所适从，没有前进的动力和方向。\n而今生活半步迈上正轨，生活也有了新的前进方向，浩瀚的知识海洋又足够消磨我的大部分闲暇时光。\n我想我也不会忘记这个白天徜徉于赛博空间，与二进制数据交流；夜晚沉浸在哲学世界中在地下室沉思；同时不断思考感情更好的处理方式的这个炎热又充满希望的2021年八月夏天。\n\n\n\n\n\n\n\n\n\n方才我说，不知为何会遭此厄运，但细想起来，倒也并非茫然无绪。在我还是人的时候，尽量避免与人交往，人们也因此说我倨傲不逊，妄自尊大。人们不知道，其实是我心中某种近似于羞耻心的东西在作怪。当然，曾被誉为乡党之鬼才的我，并非没有自尊心。然而，这种自尊心，无疑是一种怯弱的自尊心。我想以诗成名，却又不进而投师访友，相与切磋琢磨。与此同时，又不屑与凡夫俗子为伍。这都是我那怯弱的自尊心和妄自尊大的羞耻心在作怪。我深怕自己本非美玉，故而不敢加以刻苦琢磨，却又半信自己是块美玉，故又不肯庸庸碌碌，与瓦砾为伍。于是我渐渐地脱离凡尘，疏远世人，结果便是一任愤懑与羞恨日益助长内心那怯弱的自尊心。其实，任何人都是驯兽师，而那野兽，无非就是各人的性情而已。于我而言，这种妄自尊大的羞耻心就是野兽，就是猛虎。它毁了我自己，害苦了我的妻儿，伤害了我的友人，最后，又如此这般，将我的外形也变成了与内心相一致的模样。如今想来，我自己仅有的那么一点才华也都付之东流了。我常卖弄什么‘无所作为，则人生太长；欲有所为，则人生太短’的格言，其实我哪有什么远大的志向，无非是害怕暴露自己才华不足之卑劣的恐惧和不肯刻苦用功的无耻之怠惰而已。才华远逊于我，却凭磨砺精进而卓然成家的诗人，不知凡几。只可惜变成老虎后的今日，我才终于明白这个道理。\n这里的野兽和驯兽师之论，很难不让我想起《少年派的奇幻漂流》观影后马伯庸的《李安的隐喻森林》当中关于Richard Parker是Pi内心的兽性，整个漂流隐喻了兽性和人性斗争的论述。\n名人传悟净出世\n不同哲学思想流派在不同人物那里的体现\n以具体的话语来阐释作者对于不同哲学流派的理解\nzwj自己的解读\n由于缺乏对哲学的系统学习，更多只是自己在22年生活中的经验之谈\n而关于我自身思考问题方式的成因，我自己又缺乏心理学系统学习，也没法作出解释\n我想方法论的学习对于更加深刻的认识自身有着醍醐灌顶的作用，这本书的阅读可能可以激发我这方面的学习动力\n下面的一些想法都是松散的、随性的、没有系统的，可能思考的多了，读的书多了会整理的系统些\n\n\n\n一对于“我”的思考\n\n\n\n\n\n\n\n\n当时，不仅仅是妖怪，所有的活物都相信自己是由什么东西转世投胎而来的。在流沙河的河底，大家都说他前世是天上灵霄殿的卷帘大将。因此，就连深感怀疑的悟净本人，最后都不得不装出深信不疑的模样来。可事实上，在所有的妖怪中，只有他一个暗地里不相信转世投胎说。\n之前以为是一个整体的东西，如今分崩离析了，而在对每一部分加以思考的过程中，其整体的含义就全然不明白了。\n\n奇怪的是，很多周围的人要么选择“躺平”，要么选择拼死拼活，感觉愿意在生活中交流这些的人不是很多，会有这样奇怪思考的人也不多。阿柴名言是“我们来思考一些终极的问题”。\n大一大二在稀稀拉拉的课程安排中很容易思考这些问题，但是却“胸怀大志，虚度光阴”，没有站在巨人肩膀上看问题\n大三大四老些了，却逐渐变得事故、糊弄、嘻嘻哈哈，固然有对自己的保护，但是现在想来，其实也是自己松懈了，背叛了革命\n“整体和个体”的区别\n常常会思考到的是十年浩劫中的个人在群体行为下的不同，王小波的“话语捐税”差不多可以概括我的想法\n最近可能是《鬼子来了》中花屋小三郎在脱离日军群体范围后的一段时间和回归群体后的想法之差异的对比\n\n\n\n老鱼精\n\n\n\n\n\n\n\n\n一条身兼医生、占星师和祈祷者的老鱼精，有一次见到悟净后便对他说：\n“哎呀，好可怜啊。你这是得了因果之病了。得这种病的人，一百个人中有九十九个都只能十分悲惨地度过一生。要说，我们之中原本是没人得这种病的，可自从我们开始吃人之后，就开始有极少数人得这种病。得了这种病，就不能直截了当地接受任何事物。无论看到什么，遇上什么，都首先会想‘为什么’，而这个‘为什么’是真正的大神、顶级的大仙才知道的。一般的活物只要考虑起这样的问题，往往就活不下去了。不考虑这样的问题，才是我们这个世上所有的活物间的约定嘛。而其中最严重的是病人怀疑起‘自己’的存在来。为什么我会将我当作我呢？将别人当作我不是也没什么关系吗？我到底是什么呢？开始这么想，就是该病的晚期症状。怎么样，被我说中了吧？真是可怜啊。这病是无药可救的，也无人能医，只能自己救治自己。倘若没有什么特别的机缘，恐怕你一生一世都不会再开开心心。”\n\n我的想法：对于哲学本源问题\n有如此的论述\n哲学揭示了世界运行的内在规律\n我们平常的生活只需要了解一部分的外部接口，对于黑匣子内部不甚了解并不妨碍我们正常运行的生活\n\n\n在数学的学习过程中追问“为什么”确实给我的学习生活带来了快乐和动力，也有良好的反馈告诉我其实这样做并非无意义的\n有的人可以不问为什么活的开开心心，但是有的人却不行。我想都各有各的幸福所在\n\n二\n\n\n\n\n\n\n\n\n他们坚信，用文字来记录智慧，就跟空手去拽住一缕轻烟而不破坏其形状一般，简直傻透了。\n虽说妖怪们不拿文字当回事儿，可并不等于他们就瞧不起思想。在那一万三千个妖怪当中，哲学家还真不少呢。只是由于他们的语汇极度贫乏，只能用非常天真朴素的语言来思考最最艰深的重大问题。他们在这流沙河的河底开出了一溜儿思考的店铺，以至于河底飘荡着一股子哲学的忧郁。\n有个貌似聪明的妖怪\n\n\n\n\n\n\n\n\n“生即不死。死即无我。何惧之有？”\n\n浅显一点的理解，思考生死的问题对于现实没有什么指导意义？或者说是不需要思考这一类杞人忧天的问题？\n\n\n\n\n\n\n\n\n\n\n为什么妖怪就是妖怪，而不是人呢？那是因为他们都将自己的某一特性发展到极致，毫不顾及与其他特性之间是否保持均衡，一直发展到丑陋不堪的、非人的地步。说到底，他们都是些畸形的残疾者。\n有的极度贪吃，因而嘴巴和肚子长得极大；有的极度淫荡，因而相应的器官十分发达；有的极度单纯，因而除了脑袋以外，其他所有部位都退化殆尽。\n他们全都固执己见，顽固地坚守着自己的秉性和世界观，不懂得与别人讨论后还能得出层次更高的结论。这是由于他们过于彰显自己的特性，不愿意遵循别人的思路。因此，在这流沙河的河底，存在着数百种世界观和形而上学，彼此绝不融合。有的怀有安稳而绝望的欢喜；有的开朗活泼得没边；还有的心有所愿而无法实现，整天唉声叹气，如同无数漂摆着的海草一般，晃晃悠悠，游移不定。\n\n作者关于不同哲学流派的观点？或许应当怀包容之心，容天下各种观点？\n\n三黑卵道人\n\n\n\n\n\n\n\n\n然而，现实却让悟净大失所望。因为，无论是坐在石洞深处巨鳌背上的黑卵道人也好，还是围在他身边的数十名弟子也好，开口闭口，尽是些神秘莫测的法术，以及如何运用这些法术来欺骗敌人从而获取宝物的实用方法，根本没人愿意跟悟净来探讨什么没用的思想问题。结果，悟净惨遭愚弄、嘲笑之后，被赶出了三星洞。\n\n有的人不懂是装糊涂，有的人不懂是真不懂？我想可能我还是比较喜欢和真诚一点、可爱一点的人交流，故弄玄虚好像有点让我这样的人反感\n\n沙虹隐士\n\n\n\n\n\n\n\n\n“世上的一切都是空的。世上没一件好事。如果说有的话，就是这个世道总有一天会终结的，用不着去冥思苦想什么高深的道理。瞧瞧我们身边的一切就够了。没完没了的变幻、不安、懊恼、恐怖、幻灭、斗争、倦怠，没完没了，简直就是昏昏昧昧，纷纷扰扰，不知归处，我们都只活在当下这么个瞬间，并且，我们脚下的这个现在，立刻就会消失而成为过去的。下一个瞬间，再下一个瞬间，也都这样。就如同旅人行走在沙丘斜坡上一样，每走一步，就崩塌一点。何处才是我们的安身之地呢？没有。如果我们停下脚步，则势必倒地。我们的一生，就是一刻不停地行走。幸福？那仅仅是空想的概念罢了，绝不是什么现实的状态。仅仅是空有其名的希望而已啊。”\n看到悟净面呈不安之色，老隐士又安慰他说道：\n“不过呢，年轻人，你也不用害怕。被波浪卷走的人会淹死，而乘在波浪之上的人是能够超越它的。要超越这种有为转变到达不坏不动的境地，也不是做不到。古代的真人，不是都能超越是非，超越善恶，物我两忘，从而到达不死不生的境界吗？但是，如果像自古流传的那样，将这种境地设想为极乐世界，那可就大错特错了。那里既没有痛苦，也没有普通生灵所拥有的快乐。无色，无味。平平淡淡，如蜡，如沙。”\n听到这里，悟净忍不住小心翼翼地插了句嘴，说：“我想听的不是个人的幸福，或如何确立不动之心。而是想知道我自己，以及整个世界的终极意义到底是什么。\n”老隐士眨巴了一下积满眼屎的眼睛，回答道：“自己？世界？难道你认为在自己之外，还存在什么客观世界吗？让我来告诉你吧，所谓世界，就是自己投影在时间与空间上的幻象啊。自己要是死了，世界也就完蛋了。那种认为自己死后世界依然存在的想法，是俗不可耐、荒谬至极的谬见。即便世界消失了，这个不明所以、不可思议的自己，也会继续存在下去的。”\n\n不知为什么，“被波浪卷走的人会淹死，而乘在波浪之上的人是能够超越它的”一句让我想起了“御风而行”这样的状态\n“自己要是死了，世界也就完蛋了” 我思故我在？主观唯心论？\n\n坐忘先生\n\n\n\n\n\n\n\n\n两人一时无言，对坐了一会儿之后，悟净战战兢兢地开口问道：“先生，恕我冒昧，在下有一事请教。所谓的‘我’，到底是个什么玩意儿呢？”咄！秦时镀轹钻！\n坐忘先生脸部和身体全都一动不动，只是张开厚厚的嘴唇，如同做梦一般地说道：“老不吃饭觉得饿，到了冬天觉得冷。你，就是这么个玩意儿。”\n“衡量时间长短的尺度，仅仅是有所感受者的实际感受罢了。连这点都不懂的家伙，就是十足的蠢蛋。听说人类世界里出现了衡量时间长度的器械，恐怕只会给将来带来巨大的误解吧。大椿之寿，朝菌之夭，又有什么长短之分呢？所谓时间，只是我们头脑中的一个装置而已啊。”\n\n关于时间\n\n一个青年\n\n\n\n\n\n\n\n\n“怀有恐惧之心吧，凡夫俗子们！然后，相信神灵吧！”\n一个青年站在流沙河最最热闹的四岔路口，高声叫道。\n“要知道，我们那短暂的生涯，是处在其前与其后都浩渺无边的‘大永劫’之中的。要知道，我们所居住的狭窄空间，其实是处在我们对其一无所知，它也对我们一无所知的，广袤无垠之中的。有谁，能不为自己的渺小而感到战栗呢？说穿了，我们都是被铁链拴住了的死囚犯。每一个瞬间，都有那么几个在我们面前被处决。我们毫无希望，仅仅是等着挨刀而已。时不我待啊。难道只有靠自我欺骗和酩酊大醉来度过这段短暂的时光吗？被诅咒的胆小鬼们！难道你们还想在这段短暂的时光内，凭借着可悲的理性而自恋不已吗？你们这些不知天高地厚的狂徒！你们这点贫瘠的理性与意志，是连打个喷嚏都左右不了的。难道不是吗？”\n“我们所能做的，仅仅是敬爱神灵，厌恶自己而已。有些人自以为是什么独立的本体而沾沾自喜，洋洋得意。简直是可笑至极！说到底，我们还得以整体的意志为自己的意志，为了整体，仅仅是为了整体而活下去。只有与神合二为一，才能成就灵魂。”\n这确实是发自灵魂深处的神圣而睿智的声音，对此，悟净是毫无疑虑的。但是，他也深切地感受到，自己如今如饥似渴地追求的，并不是这种神圣的声音。这种金玉良言确实如同一剂良药，然而，将治疗疖子的药推荐给疟疾病人，又有什么用呢？\n\n客观唯心论？\n\n丑陋不堪的乞丐\n\n\n\n\n\n\n\n\n\n“恕我冒昧。你似乎觉得我很可怜，是吗？可我觉得，让人觉得可怜的，反倒是你啊。你以为我变成如此模样，心里一定在怨恨造物主，是吧？干吗要怨恨呢？正相反，一想到将我塑造成如此珍稀的模样，我觉得反倒要感谢造物主才是啊。今后，我还会变成什么有趣的模样呢？我的内心正充满期待呢。我的左臂要是变成一只鸡，就让它去司晨好了。我的右臂要是变成一张弹弓，那就用它来打个斑鸠下来烤着吃。我的屁股要是变成车轮，我的灵魂要是变成马，那就是一辆上好的马车了，得珍惜使用啊。怎么着，你吃惊了？我的名字叫作子舆，还有三个莫逆之交，他们是子祀、子犁和子来。我们都是女偊氏的弟子，早已超越了形体局限，进入不生不死之境地。水淹不死，火烧不死，睡着时不做梦，醒来后无忧无虑。前一阵子我们四人还在一起谈笑风生呢。我们是以‘无’为头，以‘生’为背，以‘死’为屁股的。啊哈哈哈……”\n四虬髯鲇子\n\n\n\n\n\n\n\n\n“一味地去忧虑遥远的将来，则眼前必有忧患。所谓达人，是不去登高望远的。譬如说这条鱼吧。”说着，他一把抓住一条在他眼前游过的鲤鱼，立刻送进嘴里大嚼了起来，“这条鱼，嗯，就说这条鱼吧，为什么会从我的眼前游过并成了我的点心呢？这里面是有着必然之因缘的。深究如此因缘，自然完全符合哲仙[插图]的行事风格。然而，在抓到这条鲤鱼之前就一味地沉湎于如此思考，就只会眼睁睁地看着猎物溜走。所以说，应该首先抓住这条鲤鱼，并将其当作点心吃掉，然后再去考虑那样的问题，也还为时不晚，是不是？我看你，就是那种老纠缠着鲤鱼为什么是鲤鱼，鲤鱼跟鲫鱼有什么不同等愚不可及的形而上学的问题，而老让鲤鱼白白溜走的家伙。你那忧郁的眼神，已经清楚明白地告诉了我这一点。怎么样？被我说中了吧？”\n悟净垂下了脑袋，觉得这鲇鱼精说得确实没错。\n这时，虬髯鲇子已经吃光了鲤鱼，开始将贪婪的目光投射到悟净低垂着的脖子上。突然，他的眼中露出凶光，喉咙里“咕嘟”作响。悟净正好在这当儿抬起头来，看到鲇鱼精的这副馋相后立刻感到危险并迅速后退。好险！鲇鱼精如同刀子一般锋利的爪子紧贴着悟净的喉咙扫了过去。一击不中之后，这妖怪恼羞成怒，和身扑了上来，一张贪婪无比的大脸迫在眼前。悟净奋力蹬水，搅起一片烟雾般的泥沙，在此掩护下，他仓皇逃出了洞口。悟净浑身战栗，心有余悸地寻思道：今天总算是以切身经历，从那凶猛的妖怪身上学到了“当下主义”之精髓了。\n\n“当下主义”或许作者已经点明\n\n无肠公子\n\n\n\n\n\n\n\n\n悟净出席了著名的无肠公子的讲筵。\n这位圣僧可是主张“爱邻人”的。可谁知他宣讲到一半的时候，突然觉得肚子饿了，就将自己的两三个儿子（他们原本就是蟹精，一次能产下无数卵子）“咔嚓咔嚓”地吃掉。看得悟净震惊不已。\n一个宣扬慈悲为怀、忍辱负重的圣人，竟然在众目睽睽之下将自己的儿子捉来吃了！不仅如此，吃完之后，他竟像是忘了这事儿似的，又开始宣扬起他的“慈悲”来。\n不，不是忘了。毫无疑问，他刚才的“充饥行为”，原本就是在下意识的状态下完成的。或许这正是我需要学习的地方啊！——悟净自己给蟹精编出了一个奇特的解释。\n在我的生活中，也有这种出于本能的“没我的”的瞬间吗？——悟净觉得获得了一条珍贵的教诲。他跪下身来，拜了一拜。\n不，凡事都要通过一个个的概念来加以解释，否则就于心不安，这正是我的缺点啊。——他又重新反思了一下。\n对了，教诲应该原汁原味地接受，而不该将其封存起来。对，就是这么回事儿。——悟净又跪拜了一次，这才恭恭敬敬地退了出去。\n蒲衣子\n\n\n\n\n\n\n\n\n“首先是感受。要磨炼出最最美妙、最最敏锐的感觉。离开了对于自然美的直接感受，就仅仅是灰色的梦而已。”一名弟子说道，“深深地潜下心来观察一下大自然吧。蓝天、白云、微风，飘雪、淡蓝色的冰、摇曳着的红藻、夜里在水中闪闪发光的硅藻类、鹦鹉螺的螺旋、紫水晶的结晶、红色的石榴石、碧绿的萤石。如此美丽，如此令人心醉，不是全都在诉说着大自然的秘密吗？”\n他所说的话，简直就是诗人的语言。\n“所言极是。然而，就在快要破解大自然之密码的瞬间，那种幸福的预感就会突然消失，我们又不得不面对美丽而又冷峻的大自然之侧脸了。”另一名弟子接过话头来说道，“这自然是我们的感觉磨炼得还不够，心潜得还不够深的缘故。我们还得用功修炼才行啊。因为，师父所说的‘看即是爱，爱即是作’那一境界，应该是不久就能达到的。”\n\n寄希望于自然？\n不知怎么想起来杀千刀的《瓦尔登湖》，阿西巴，在这样的缺乏贸易的理想主义中对自然地理的爱愈深，浑然一个呆子模样，一心只想去新疆追求“大漠孤烟直，长河落日圆”\n\n斑衣鳜婆\n\n\n\n\n\n\n\n\n“要我说这‘道’呀，要我说这‘道’呀，圣贤的教诲也好，仙哲的修炼也罢，都在于如何延续这‘无上法悦’之瞬间。你想想看，能够生于这世上，实在是百千万亿恒河沙劫无限之时间中极为偶然、极为庆幸之事。然后，死亡却会以迅雷不及掩耳之势飞快地降临到我们的头上。我们，就是以如此偶然之生，在等待着轻而易举之死。你想想看，除了追求‘无上法悦’，‘道’还会在哪儿呢？啊！那种销魂蚀骨的欢喜！啊！那种永远新鲜的陶醉！”\n随即，女妖又眯缝起如痴如醉的双眼说道：\n“虽说你长得太丑了，我不想留你——这么说十分对你不住，但我老实告诉你吧，在我的后院，每年都会累死上百个小伙子。但是，我要告诉你的是，这些人都死得十分快乐，都为自己能如此这般地度过一生而感到非常满足。没有一个留在我这里之后，是在怨恨中死去的。倒是有人由于死亡导致无法继续享乐而心有不甘。”最后，鳜婆用充满怜悯的眼神望着悟净那丑陋的模样，又补充道：\n“所谓‘德’，就是能够享乐的能力啊。”在为由于自己太丑而被免于列入每年死去的百人之中而表示了感谢之后，悟净告别了鳜婆，继续踏上旅程。\n\n《有话好好说》，什么是德？一脸蛋二胸三屁股，这就是德！笑\n能够享乐，像@大家一起去那般的对各种各样的事物都充满乐趣，一定不是阴阳怪气，我是很希望自己有广泛兴趣的。跟朋友聊天有时候也会很快词穷，我感觉是需要培养自己各方面兴趣的\n\n我是什么？\n\n\n\n\n人物\n语言\n观点\n\n\n\n\n一位贤者\n“你首先大吼一声试试。倘若吼声为‘波——‘，你就是猪。倘若吼声为‘嘎——‘，你就是鹅。”\n以外部的认知来反推自我的存在\n\n\n另一位贤者\n“只要你不勉强自己问什么‘我是什么’，你就不难理解你自己了。”“眼睛能看见一切，唯独看不见自己。所谓‘我’，就是我不能理解的东西。”\n？\n\n\n又一位贤者\n“我一直是我。在我的现在的意识诞生之前，我就已经经历了无穷的时间（虽说谁都记不得这一点了）。在现在的我的意识消亡之后，我也将会存在于无穷的时间中吧。关于这一点，如今谁都没有预见到，并且，到了那时，现在的我的意识一定早被忘得一干二净了。”\n？\n\n\n\n“一个连续的我是个什么玩意儿？那只是记忆的影子的堆积而已。”“记忆的丧失，就是俺们每天所做的事情的全部。由于我们忘记了已经忘记的事情，所以才觉得许多事情十分新鲜。其实那就是些被我们忘得一干二净的事情。不要说是昨天的事情了，就是上一个瞬间的事情，也即当时的知觉，当时的情感，全都会在下一个瞬间被忘却的。这其中仅有极少的一部分，会留下朦胧模糊的痕迹。因此说，悟净啊，现在这一瞬间，是多么地重要，多么地宝贵啊。”\n？\n\n\n\n\n悟净经过思考后的感受\n\n\n\n\n\n\n\n\n\n五年的时间，就这么过去了。在此期间，针对悟净这同一个“症状”，不同的“医生”开出了不同的处方。悟净不断地重复着奔波于不同“医生”之间的蠢行，最后，他觉得自己一点也没有因此而变聪明。岂止是没有变聪明，他甚至觉得自己变成了一个轻飘飘的（不是自己的）不知是什么的玩意儿了。从前的自己尽管愚蠢，可至少要比现在的自己敦实——几乎是肉体感觉，总之，自己那时还是相当有分量的。而现在呢，变得没分量了，一阵风就能吹跑。尽管外表被涂了许多花样，可内里却空空如也。\n六女偊氏\n\n\n\n\n\n\n\n\n他从女偊氏嘴里听到的唯一一句话是：“相比起贤者之知人来，愚者更为知己。因此，自己的病，还得自己治啊。”\n到了第三个月的月底，悟净终于绝望了。他去跟老师告别。\n谁知这时女偊氏竟然开口了，并且滔滔不绝地跟他说了许多——关于“因没生三只眼睛而感到悲伤的人，是十分愚蠢的”；关于“一定要用自我意志来控制指甲和头发的生长的人，是非常不幸的”；关于“喝醉酒的人从车上掉下来不会受伤”；关于“尽管不能一概而论地说思考这事儿不好，但就跟猪不会晕船一样，不思考的人是幸福的。不过呢，思考思考这件事儿本身是不应该的”，云云。\n“懂得神圣之疯狂的人是幸福的。因为他们杀死了自我，从而拯救了自我。不懂得神圣之疯狂的人的一生，是一场灾祸。因为他们既不杀死自我，也不拯救自我，只是慢慢地走向死亡而已。你要懂得，所谓‘爱’，就是一种更高级的理解。所谓‘行’，就是更明确的思考。悟净，你非要将所有的事情全都浸在意识的毒汁之中，你好可怜啊。你要知道，所有决定我们命运的重大变化，全都是无关乎我们的意识而进行的哦。你好好想想，你出生之前，可曾意识到此事？”\n悟净恭恭敬敬地回答道：“老师的教诲，我如今觉得能够深切领会。其实，在长年累月的游历之中，我也渐渐地感觉到仅仅依靠思考，只会在泥沼中越陷越深，但又苦于无法突破如今的自我，脱胎换骨，故而痛苦不堪。”\n听了这话之后，女偊氏说道：\n“溪流流到断崖附近，打一个漩涡，然后化作一道瀑布而掉落下去。悟净啊，你如今就是在漩涡之前踌躇不前。一旦卷入了漩涡，那么就会一口气飞落谷底了。在掉落的途中，是没工夫思考、反省和犹豫不决的。胆怯的悟净啊，你胆战心惊、无限怜悯地在一旁望着如同溪流一般打着旋、飞流直下的人们，自己却为跳与不跳而踌躇不前，你明明知道自己迟早也会掉落谷底的，你明明知道不被卷入漩涡也绝非什么幸福。即便这样你还是恋恋不舍于旁观者的地位吗？愚蠢的悟净啊，你难道不知道，在生之漩涡中喘息的人们，事实上并不如旁观者所以为的那般不幸啊（至少要比持怀疑论的旁观者幸福得多）。”\n六观音菩萨\n\n\n\n\n\n\n\n\n悟净不由自主地垂下了脑袋，耳边则响起一个美妙的女声——是妙音，梵音，还是海潮音？“悟净啊，你仔细听我说话，好好地加以领会吧。不知天高地厚的悟净啊。未得而谓得，未证而谓证，世尊责之为增上慢[插图]。那么，像你这样非要求证于不可证，更是极度的增上慢了。你所追求的，是连阿罗汉、辟支佛都不能追求，也不想追求的东西。可怜的悟净啊，你是怎么会让自己的灵魂走入如此歧途的呢？正观得而净业立成，而你因心相羸劣如今才陷入了三途无量之苦恼。想来，你已不能由观想而得救，只能靠勤勉劳作而自救了。所谓时间，实乃人之作为也。这个世界，整体看来似乎是毫无意义的，但作用于具体之细节，就有了无限之意义。悟净啊，你首先要将自己摆放在一个适当的位置上，然后投身于适当的作为。今后，你要完全抛弃不知天高地厚的‘为什么’。除此之外，你别无获救之道。\n“……真是事情因人而起，适时而发呀。半年前的我，是绝不会做这种奇怪的梦的。……刚才梦中那菩萨所说的话，想起来跟那女偊氏和虬髯鲇子也并无多大的差别，可今夜我听着就觉得特别受用，真是怪事儿啊。话虽如此，我再怎么蠢也不会真的将这梦中听来的话，当作自己的救赎之道的。但是，也不知为什么，我总觉得梦里菩萨告诉我的唐僧他们将经过这儿的事情，或许是真的。真是事情适时而发。……”\n七\n\n\n\n\n\n\n\n\n“真是奇怪。总觉得心里不怎么踏实啊。不再勉强寻找不懂之事的答案，难道就等于懂了吗？这事情怎么这么暧昧呢？这转变得也太不彻底了吧！呵呵，真是难以接受啊。总而言之，所幸的是，自己不像以前那么地苦恼了……”\n悟净叹异悟空八戒之争\n\n\n\n\n\n\n\n\n\n悟空：“你要变成龙的意识不强烈，所以老变不成。\n”八戒：“没有的事。我是拼命地想‘变成龙，变成龙，变成龙’来着的。使劲想，用心想的。”\n悟空：“你没变成龙，就说明你用心还不够专一。”\n八戒：“你怎么能这么说呢？你这不是结果论吗？”\n悟空：“哦，是啊，你说得没错。仅凭结果来批判原因，当然不是什么最好的方法。可是，这似乎也是世上最管用的方法了。用在你身上，正合适。”\n按照悟空的说法，所谓变化之法，其实就是这样的：想要变成某个东西的心意纯粹专一到了极点，强烈迫切到了极致，你最终就变成这个东西了。倘若没有变成，就是因为你的心意没有迫切到如此程度。所谓法术之修行，就是学习如何将自己的心意聚集成一种纯净无垢、强烈无比的东西。这样的修行自然是很艰难的，可一旦达到了那样的境界，就不需要每次都花那么大的力气了，只需将心意转到某种形状上，就能立刻变成这种东西。事实上也不仅限于此，对于其他的诸般技艺而言，道理也是相同的。要说这变化之术为什么人不会而狐狸能行呢？就在于人心中挂念的事情太多，精神难以集中，而野兽反倒没那么多需要操心的琐事，精神容易集中的缘故云云。\n关于悟空\n\n\n\n\n\n\n\n\n\n他的体内似乎燃烧着一团烈火，熊熊燃烧着的烈火。而这团烈火能很快转移到身旁之人的身上。听他说话，会十分自然地相信他所相信的东西。只要待在他的身边，自己的内心也会变得自信满满。他就是一个火种，整个世界就是为他而准备的干柴。世界就是为了被他点燃而存在的。\n他用自己体内的烈火，去引爆外部世界中闲置着的冰冷的火药。\n","slug":"Reading/山月记","date":"2021-08-26T03:46:33.000Z","categories_index":"Reading","tags_index":"Reading","author_index":"Rambo"},{"id":"45e3d46203ca5cc5718cda218b7c4f03","title":"Manim1 Installation","content":"manim安装(MacOS)相关依赖项的安装https://docs.manim.community/en/stable/installation/mac.html\nTo install cairo:\nbrew install cairo\nTo install ffmpeg:\nbrew install ffmpeg\nTo install LaTeX:\nbrew install --cask mactex\n安装manimpip3 install manim\n快速入门first Scene代码说明To produce your first scene, create a new file in your project folder called scene.py,\nproject&#x2F;\n└─scene.py\nscene.py\nfrom manim import *\n#从mainm库中导入所有内容\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()  # create a circle\n        circle.set_fill(PINK, opacity=0.5)  # set the color and transparency\n        self.play(Create(circle))  # show the circle on screen\n代码说明\nclass SquareToCircle(Scene):\n    def construct(self):\n        ...\n创建对象、将其显示在屏幕上并为其设置动画\ncircle = Circle()  # create a circle\n        circle.set_fill(PINK, opacity=0.5)  # set the color and transparency\n创建一个圆圈并设置其颜色和不透明度\nself.play(Create(circle))  # show the circle on screen\n使用动画在屏幕上显示圆\n测试manim -pql scene.py SquareToCircle\n#-p 渲染后播放场景\n#-ql 告诉manim以低质量渲染场景\n# -qh 则为高质量\n\nproject&#x2F;\n├─scene.py\n└─media\n  ├─videos\n  |  └─scene\n  |     └─480p15\n  |        ├─SquareToCircle.mp4\n  |        └─partial_movie_files\n  ├─text\n  └─Tex\nmanim render --help\n#官方帮助文档\nmanim scene.py SquareToCircle -i \n#导出为GIF\n\n进一步调整代码说明scene2.py\nfrom manim import *\n\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()  # create a circle\n        circle.set_fill(PINK, opacity=0.5)  # set color and transparency\n\n        square = Square()  # create a square\n        square.rotate(PI / 4)  # rotate a certain amount\n\n        self.play(Create(square))  # animate the creation of the square\n        self.play(Transform(square, circle))  # interpolate the square into the circle\n        self.play(FadeOut(square))  # fade out animation\n测试manim -pql scene2.py SquareToCircle\n\nmanim scene2.py SquareToCircle -i \n\n一些line flagsmanim -pql scene.py SquareToCircle -i\n#低质量gif导出\nhttps://docs.manim.community/en/stable/tutorials/configuration.html\n","slug":"manim/C1 installation","date":"2021-08-26T03:46:33.000Z","categories_index":"Manim","tags_index":"Manim","author_index":"Rambo"},{"id":"a5157b4321de82dc35f7014351511ed5","title":"Manim2 A Deeper Look","content":"Mainm BlocksManim涉及到的3个基本概念\n\nmobject\nanimation\nScene\n\n在mainm中定义了Mobject, Animation, and Scene这几个class\nMobjects\nbasic building block for all manim animations\nrepresents an object that can be displayed on the screen\n\nFor example, simple shapes such as Circle, Arrow, and Rectangle are all mobjects. More complicated constructs such as Axes, FunctionGraph, or BarChart are mobjects as well\n创建和显示mobjectsAs explained in Quickstart, usually all of the code in a manim script is put inside the construct() method of a Scene class. To display a mobject on the screen, call the add() method of the containing Scene. This is the principal way of displaying a mobject on the screen when it is not being animated. To remove a mobject from the screen, simply call the remove() method from the containing Scene.\ncreate_display_demo.py\n\nfrom manim import *\n\nclass CreatingMobjects(Scene):\n    def construct(self):\n        circle = Circle()\n        self.add(circle)\n        self.wait(1)\n        self.remove(circle)\n        self.wait(1)\n放置mobjectsLet’s define a new Scene called Shapes and add() some mobjects to it. This script generates a static picture that displays a circle, a square, and a triangle:\nplace_demo.py\n\nfrom manim import *\n\nclass Shapes(Scene):\n    def construct(self):\n        circle = Circle()\n        square = Square()\n        triangle = Triangle()\n\n        circle.shift(LEFT)\n        square.shift(UP)\n        triangle.shift(RIGHT)\n\n        self.add(circle, square, triangle)\n        self.wait(1)\nplace_demo2.py\n\nfrom manim import *\n\nclass MobjectPlacement(Scene):\n    def construct(self):\n        circle = Circle()\n        square = Square()\n        triangle = Triangle()\n\n        # place the circle two units left from the origin\n        circle.move_to(LEFT * 2)\n        # place the square to the left of the circle\n        square.next_to(circle, LEFT)\n        # align the left border of the triangle to the left border of the circle\n        triangle.align_to(circle, LEFT)\n\n        self.add(circle, square, triangle)\n        self.wait(1)\n改变Mobjects的样式style.py\n\nfrom manim import *\n\nclass MobjectStyling(Scene):\n    def construct(self):\n        circle = Circle().shift(LEFT)\n        square = Square().shift(UP)\n        triangle = Triangle().shift(RIGHT)\n\n        circle.set_stroke(color=GREEN, width=20)\n        square.set_fill(YELLOW, opacity=1.0)\n        triangle.set_fill(PINK, opacity=0.5)\n\n        self.add(circle, square, triangle)\n        self.wait(1)\nstyle2.py\n\nfrom manim import *\n\nclass MobjectZOrder(Scene):\n    def construct(self):\n        circle = Circle().shift(LEFT)\n        square = Square().shift(UP)\n        triangle = Triangle().shift(RIGHT)\n\n        circle.set_stroke(color=GREEN, width=20)\n        square.set_fill(YELLOW, opacity=1.0)\n        triangle.set_fill(PINK, opacity=0.5)\n\n        self.add(triangle, square, circle)\n        self.wait(1)\nAnimationsGenerally, you can add an animation to your scene by calling the play() method.\n添加animationadd_animation.py\n\nfrom manim import *\n\nclass SomeAnimations(Scene):\n    def construct(self):\n        square = Square()\n        self.add(square)\n\n        # some animations display mobjects, ...\n        self.play(FadeIn(square))\n\n        # ... some move or rotate mobjects around...\n        self.play(Rotate(square, PI/4))\n\n        # some animations remove mobjects from the screen\n        self.play(FadeOut(square))\n\n        self.wait(1)\nanimation运行时间runtime.py\n\nBy default, any animation passed to play() lasts for exactly one second. Use the run_time argument to control the duration.\nfrom manim import *\n\nclass RunTime(Scene):\n    def construct(self):\n        square = Square()\n        self.add(square)\n        self.play(ApplyMethod(square.shift, UP), run_time=3)\n        self.wait(1)\n创建自定义animationacustomed_animation.py\n\nfrom manim import *\n\nclass Count(Animation):\n    def __init__(self, number: DecimalNumber, start: float, end: float, **kwargs) -> None:\n        # Pass number as the mobject of the animation\n        super().__init__(number,  **kwargs)\n        # Set start and end\n        self.start = start\n        self.end = end\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        # Set value of DecimalNumber according to alpha\n        value = self.start + (alpha * (self.end - self.start))\n        self.mobject.set_value(value)\n\n\nclass CountingScene(Scene):\n    def construct(self):\n        # Create Decimal Number and add it to scene\n        number = DecimalNumber().set_color(WHITE).scale(5)\n        # Add an updater to keep the DecimalNumber centered as its value changes\n        number.add_updater(lambda number: number.move_to(ORIGIN))\n\n        self.add(number)\n\n        self.wait()\n\n        # Play the Count Animation to count from 0 to 100 in 4 seconds\n        self.play(Count(number, 0, 100), run_time=4, rate_func=linear)\n\n        self.wait()\n参考： Animation DecimalNumber interpolate_mobject() play()\n使用mobject的坐标axis.py\n\nfrom manim import *\n\nclass MobjectExample(Scene):\n    def construct(self):\n        p1= [-1,-1,0]\n        p2= [1,-1,0]\n        p3= [1,1,0]\n        p4= [-1,1,0]\n        a = Line(p1,p2).append_points(Line(p2,p3).get_points()).append_points(Line(p3,p4).get_points())\n        point_start= a.get_start()\n        point_end  = a.get_end()\n        point_center = a.get_center()\n        self.add(Text(f\"a.get_start() = &#123;np.round(point_start,2).tolist()&#125;\").scale(0.5).to_edge(UR).set_color(YELLOW))\n        self.add(Text(f\"a.get_end() = &#123;np.round(point_end,2).tolist()&#125;\").scale(0.5).next_to(self.mobjects[-1],DOWN).set_color(RED))\n        self.add(Text(f\"a.get_center() = &#123;np.round(point_center,2).tolist()&#125;\").scale(0.5).next_to(self.mobjects[-1],DOWN).set_color(BLUE))\n\n        self.add(Dot(a.get_start()).set_color(YELLOW).scale(2))\n        self.add(Dot(a.get_end()).set_color(RED).scale(2))\n        self.add(Dot(a.get_top()).set_color(GREEN_A).scale(2))\n        self.add(Dot(a.get_bottom()).set_color(GREEN_D).scale(2))\n        self.add(Dot(a.get_center()).set_color(BLUE).scale(2))\n        self.add(Dot(a.point_from_proportion(0.5)).set_color(ORANGE).scale(2))\n        self.add(*[Dot(x) for x in a.get_points()])\n        self.add(a)\nmobjects2mobjects的转换tr4fm.py\n\nfrom manim import *\n\nclass ExampleTransform(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        m1 = Square().set_color(RED)\n        m2 = Rectangle().set_color(RED).rotate(0.2)\n        self.play(Transform(m1,m2))\ntr4fm2.py\n\nfrom manim import *\n\nclass ExampleRotation(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        m1a = Square().set_color(RED).shift(LEFT)\n        m1b = Circle().set_color(RED).shift(LEFT)\n        m2a= Square().set_color(BLUE).shift(RIGHT)\n        m2b= Circle().set_color(BLUE).shift(RIGHT)\n\n        points = m2a.points\n        points = np.roll(points, int(len(points)/4), axis=0)\n        m2a.points = points\n\n        self.play(Transform(m1a,m1b),Transform(m2a,m2b), run_time=1)\nScene\nThe Scene class is the connective tissue of manim\nEvery mobject has to be added to a scene to be displayed, or removed from it to cease being displayed\n\nEvery animation has to be played by a scene, and every time interval where no animation occurs is determined by a call to wait(). All of the code of your video must be contained in the construct() method of a class that derives from Scene. Finally, a single file may contain multiple Scene subclasses if multiple scenes are to be rendered at the same time.\n","slug":"manim/C2 a deeper look","date":"2021-08-26T03:46:33.000Z","categories_index":"Manim","tags_index":"Manim","author_index":"Rambo"},{"id":"60bd8fd469f282ac6b13a9d5e27c3f6b","title":"Manim3 UsingText","content":"使用文本without $LaTeX$​​文本helloworld.py\nfrom manim import *\n\nclass HelloWorld(Scene):\n    def construct(self):\n        text = Text(\"Hello world\").scale(3)\n        self.add(text)\n\n带颜色文本MarkupText.py\nfrom manim import *\n\nclass SingleLineColor(Scene):\n    def construct(self):\n        text = MarkupText(f'all in red &lt;span fgcolor=\"&#123;YELLOW&#125;\">except this&lt;/span>', color=RED)\n        self.add(text)\n不同字体``\nfrom manim import *\n\nclass FontsExample(Scene):\n    def construct(self):\n        ft = Text(\"Noto Sans\", font=\"Noto Sans\")\n        self.add(ft)\n设置倾斜和权重倾斜\nfrom manim import *\n\nclass SlantsExample(Scene):\n    def construct(self):\n        a = Text(\"Italic\", slant=ITALIC)\n        self.add(a)\n权重\nfrom manim import *\n\nclass DifferentWeight(Scene):\n    def construct(self):\n        import manimpango\n\n        g = VGroup()\n        weight_list = dict(sorted(&#123;weight: manimpango.Weight(weight).value for weight in manimpango.Weight&#125;.items(), key=lambda x: x[1]))\n        for weight in weight_list:\n            g += Text(weight.name, weight=weight.name, font=\"Open Sans\")\n        self.add(g.arrange(DOWN).scale(0.5))\n颜色\nfrom manim import *\n\nclass SimpleColor(Scene):\n    def construct(self):\n        col = Text(\"RED COLOR\", color=RED)\n        self.add(col)\n特定字符着色\nfrom manim import *\n\nclass Textt2cExample(Scene):\n    def construct(self):\n        t2cindices = Text('Hello', t2c=&#123;'[1:-1]': BLUE&#125;).move_to(LEFT)\n        t2cwords = Text('World',t2c=&#123;'rl':RED&#125;).next_to(t2cindices, RIGHT)\n        self.add(t2cindices, t2cwords)\n渐变\nfrom manim import *\n\nclass GradientExample(Scene):\n    def construct(self):\n        t = Text(\"Hello\", gradient=(RED, BLUE, GREEN)).scale(2)\n        self.add(t)\n特定文本字符渐变\nfrom manim import *\n\nclass t2gExample(Scene):\n    def construct(self):\n        t2gindices = Text(\n            'Hello',\n            t2g=&#123;\n                '[1:-1]': (RED,GREEN),\n            &#125;,\n        ).move_to(LEFT)\n        t2gwords = Text(\n            'World',\n            t2g=&#123;\n                'World':(RED,BLUE),\n            &#125;,\n        ).next_to(t2gindices, RIGHT)\n        self.add(t2gindices, t2gwords)\n设置行距\nfrom manim import *\n\nclass LineSpacing(Scene):\n    def construct(self):\n        a = Text(\"Hello\\nWorld\", line_spacing=1)\n        b = Text(\"Hello\\nWorld\", line_spacing=4)\n        self.add(Group(a,b).arrange(LEFT, buff=5))\n禁用连字\nfrom manim import *\n\nclass DisableLigature(Scene):\n    def construct(self):\n        li = Text(\"fl ligature\").scale(2)\n        nli = Text(\"fl ligature\", disable_ligatures=True).scale(2)\n        self.add(Group(li, nli).arrange(DOWN, buff=.8))\n迭代文本\nfrom manim import *\n\nclass IterateColor(Scene):\n    def construct(self):\n        text = Text(\"Colors\").scale(2)\n        for letter in text:\n            letter.set_color(random_bright_color())\n        self.add(text)\nMarkup Textfrom manim import *\n\nclass MarkupTest(Scene):\n    def construct(self):\n        text = MarkupText(\n            f'&lt;span underline=\"double\" underline_color=\"green\">double green underline&lt;/span> in red text&lt;span fgcolor=\"&#123;YELLOW&#125;\"> except this&lt;/span>',\n            color=RED,\n        ).scale(0.7)\n        self.add(text)\nWith $LaTeX$简易版本from manim import *\n\nclass HelloLaTeX(Scene):\n    def construct(self):\n        tex = Tex(r\"\\LaTeX\").scale(3)\n        self.add(tex)\n行内公式from manim import *\n\nclass MathTeXDemo(Scene):\n    def construct(self):\n        rtarrow0 = MathTex(r\"\\xrightarrow&#123;x^6y^8&#125;\").scale(2)\n        rtarrow1 = Tex(r\"$\\xrightarrow&#123;x^6y^8&#125;$\").scale(2)\n\n        self.add(VGroup(rtarrow0, rtarrow1).arrange(DOWN))\n$LaTeX$命令from manim import *\n\nclass AMSLaTeX(Scene):\n    def construct(self):\n        tex = Tex(r'$\\mathtt&#123;H&#125; \\looparrowright$ \\LaTeX').scale(3)\n        self.add(tex)\n$LaTeX$ Attributesfrom manim import *\n\nclass LaTeXAttributes(Scene):\n    def construct(self):\n        tex = Tex(r'Hello \\LaTeX', color=BLUE).scale(3)\n        self.add(tex)\n额外的$LaTeX$包from manim import *\n\nclass AddPackageLatex(Scene):\n    def construct(self):\n        myTemplate = TexTemplate()\n        myTemplate.add_to_preamble(r\"\\usepackage&#123;mathrsfs&#125;\")\n        tex = Tex(r'$\\mathscr&#123;H&#125; \\rightarrow \\mathbb&#123;H&#125;$&#125;', tex_template=myTemplate).scale(3)\n        self.add(tex)\n子串和部分from manim import *\n\nclass LaTeXSubstrings(Scene):\n    def construct(self):\n        tex = Tex('Hello', r'$\\bigstar$', r'\\LaTeX').scale(3)\n        tex.set_color_by_tex('igsta', RED)\n        self.add(tex)\n仅着色指定字符from manim import *\n\nclass CorrectLaTeXSubstringColoring(Scene):\n    def construct(self):\n        equation = MathTex(\n            r\"e^x = x^0 + x^1 + \\frac&#123;1&#125;&#123;2&#125; x^2 + \\frac&#123;1&#125;&#123;6&#125; x^3 + \\cdots + \\frac&#123;1&#125;&#123;n!&#125; x^n + \\cdots\",\n            substrings_to_isolate=\"x\"\n        )\n        equation.set_color_by_tex(\"x\", YELLOW)\n        self.add(equation)\n模版库from manim import *\n\nclass LaTeXMathFonts(Scene):\n    def construct(self):\n        tex = Tex(r'$x^2 + y^2 = z^2$', tex_template=TexFontTemplates.french_cursive).scale(3)\n        self.add(tex)\nfrom manim import *\n\nclass LaTeXTemplateLibrary(Scene):\n    def construct(self):\n        tex = Tex('Hello 你好 \\\\LaTeX', tex_template=TexTemplateLibrary.ctex).scale(3)\n        self.add(tex)\n对齐公式from manim import *\n\nclass LaTeXAlignEnvironment(Scene):\n    def construct(self):\n        tex = MathTex(r'f(x) &amp;= 3 + 2 + 1\\\\ &amp;= 5 + 1 \\\\ &amp;= 6').scale(2)\n        self.add(tex)\n","slug":"manim/C3 UsingText","date":"2021-08-26T03:46:33.000Z","categories_index":"Manim","tags_index":"Manim","author_index":"Rambo"},{"id":"cdf1a7f1db00ebb74a977ba17a93dbe1","title":"DSA0 开篇词","content":"跨过“数据结构与算法”技术人所需修炼的“内功”\n\n操作系统\n计算机网络\n编译原理\n数据结构与算法\n……\n\n专栏内容设计\n\n众多数据结构和算法中，选取最实用的内容讲解\n数据结构和算法中背后的设计思想\n结合真实软件开发案例\n\n模块\n\n入门\n时间、空间复杂度\n大O表示法由来\n复杂度分析技巧\n最好、最坏、平均、均摊复杂度分析方法\n\n\n基础\n最基础、最常用的数据结构和算法\n\n\n高级\n不那么常用的数据结构和算法\n\n\n实战\n开源项目、框架或者系统设计问题，剖析背后数据结构和算法\n\n\n\n","slug":"DSA/C0开篇词","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"971ce7cf635f389a131d803d3ca3c395","title":"DSA1 Why DSA?","content":"为什么要学习数据结构和算法\n大厂面试\n业务开发工程师\n不需要自己实现，不代表不需要了解\n评估代码的性能和资源的消耗\n基础框架中糅合了基础数据结构和算法的设计思想\n\n\n基础架构研发工程师\n不被淘汰\n\n","slug":"DSA/C1  WHY DSA","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"cfd5571b43938e7edf361ab5277ffd65","title":"DSA10 Recursion","content":"递归：如何用三行代码找到“最终推荐人”？引入\n如何理解“递归”？递归应用广泛\n\nDFS深度优先搜索\n前中后序二叉树遍历\n\n满足的三个条件\n\n一个问题的解可以分解为几个子问题的解\n问题与分解后的子问题，除了数据规模不同，求解思路完全一样\n存在递归终止条件\n\n如何编写递归代码？写出递推公式、找到终止条件\n写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码\n注意：\n\n分解为多个子问题，递归代码没那么好理解\n我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，再一层一层返回，很容易被绕进去\n正确的思维方式\n如果一个问题 A 可以分解为若干子问题 B、C、D\n可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A\n只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系\n屏蔽掉递归细节，这样子理解起来就简单多了\n\n\n\n只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤\n递归代码要警惕堆栈溢出问题由来graph TD\n函数调用会使用栈来保存临时变量 --> 调用函数.临时变量封装为函数调用会使用栈来保存临时变量\n--> 函数执行完成返回.出栈-->递归求解数据规模很大.调用层次很深.一直入栈 -->堆栈溢出\n\n\n如何避免\n限制递归调用最大深度\n避免重复计算\n通过一个数据结构来保存已经求解过的$f(k)$\n\n\n\n// 全局变量，表示递归的深度。\nint depth = 0;\n\nint f(int n) &#123;\n  ++depth；\n  if (depth > 1000) throw exception;\n  \n  if (n == 1) return 1;\n  return f(n-1) + 1;\n&#125;\n\npublic int f(int n) &#123;\n  if (n == 1) return 1;\n  if (n == 2) return 2;\n  \n  // hasSolvedList可以理解成一个Map，key是n，value是f(n)\n  if (hasSolvedList.containsKey(n)) &#123;\n    return hasSolvedList.get(n);\n  &#125;\n  \n  int ret = f(n-1) + f(n-2);\n  hasSolvedList.put(n, ret);\n  return ret;\n&#125;\n怎样将递归代码改写为非递归代码递归代码优缺点\n优点\n表达力强、写起来简洁\n\n\n缺点\n空间复杂度高\n堆栈溢出风险\n存在重复计算\n过多函数调用耗时较多\n\n\n\n举例\nf(x) = f(x-1)+1int f(int n) &#123;\n  int ret = 1;\n  for (int i = 2; i &lt;= n; ++i) &#123;\n    ret = ret + 1;\n  &#125;\n  return ret;\n&#125;\n是不是所有递归代码都可以改为迭代循环的非递归写法？\n笼统讲，是的\n递归本身借助栈来实现，只不过使用的栈是系统或者虚拟机本身提供\n如果自己在内存堆上实现栈，手动模拟入栈、出栈，任何递归代码都可以改写成看上去不是递归代码的样子\n\n\n但是实际上将递归改为了“手动”递归，本质没有变，也没有解决问题，徒增复杂度\n\n解答开篇long findRootReferrerId(long actorId) &#123;\n  Long referrerId = select referrer_id from [table] where actor_id = actorId;\n  if (referrerId == null) return actorId;\n  return findRootReferrerId(referrerId);\n&#125;\n存在的问题\n\n递归很深→堆栈溢出\n数据库存在脏数据→无限递归问题\n\n","slug":"DSA/C10 递归","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"dc2049cb2b924724d0d9c0e20e1cbe8f","title":"DSA11 Sort1","content":"排序（上）：为什么插入排序比冒泡排序更受欢迎？概述\n如何分析一个排序算法？\n执行效率\n最好、最坏、平均情况时间复杂度\n时间复杂度的系数、常数、低阶\n比较次数和交换次数\n\n\n内存消耗\n原地排序特指空间复杂度是$O(1)$的排序算法\n\n\n稳定性\n如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变\n\n\n\n\n冒泡排序（Bubble Sort）\n\n\n// 冒泡排序，a表示数组，n表示数组大小\npublic void bubbleSort(int[] a, int n) &#123;\n  if (n &lt;= 1) return;\n \n for (int i = 0; i &lt; n; ++i) &#123;\n    // 提前退出冒泡循环的标志位\n    boolean flag = false;\n    for (int j = 0; j &lt; n - i - 1; ++j) &#123;\n      if (a[j] > a[j+1]) &#123; // 交换\n        int tmp = a[j];\n        a[j] = a[j+1];\n        a[j+1] = tmp;\n        flag = true;  // 表示有数据交换      \n      &#125;\n    &#125;\n    if (!flag) break;  // 没有数据交换，提前退出\n  &#125;\n&#125;\n几个问题\n原地排序\n稳定\n时间复杂度\n\n\n\n\n平均复杂度的分析\n有序度：数组中具有有序关系的元素对的个数\n\n满有序度：完全有序的数组的有序度\n\n逆序度 = 满有序度 - 有序度\n交换次数 = 逆序度 = \\frac{n*(n-1)}{2} - 初始有序度\n\n最好：有序度为0，交换$\\frac{n*(n-1)}{2}$次\n最差：有序度为$\\frac{n*(n-1)}{2}$，交换0次\n平均：交换$\\frac{n*(n-1)}{4}$\n\n故时间复杂度为$O(n^2)$\n插入排序（insertion sort）\n分为已排序区间和未排序区间\n\n// 插入排序，a表示数组，n表示数组大小\npublic void insertionSort(int[] a, int n) &#123;\n  if (n &lt;= 1) return;\n\n  for (int i = 1; i &lt; n; ++i) &#123;\n    int value = a[i];\n    int j = i - 1;\n    // 查找插入的位置\n    for (; j >= 0; --j) &#123;\n      if (a[j] > value) &#123;\n        a[j+1] = a[j];  // 数据移动\n      &#125; else &#123;\n        break;\n      &#125;\n    &#125;\n    a[j+1] = value; // 插入数据\n  &#125;\n&#125;\n几个问题\n原地排序\n稳定\n时间复杂度\n最好$O(n)$\n最坏$O(n^2)$\n\n\n\n选择排序（selection sort）\n分已排序区间和未排序区间\n每次从未排序区间中找到最小元素将其放到已排序区间末尾\n\n\n\n原地排序\n不稳定\n\n解答开篇为什么插入排序要比冒泡排序更受欢迎？\n答：从代码实现上来看，冒泡排序数据交换比插入排序的数据移动要复杂\n\n冒泡排序3个赋值操作\n插入排序1个赋值操作\n\n冒泡排序中数据的交换操作：\nif (a[j] > a[j+1]) &#123; // 交换\n   int tmp = a[j];\n   a[j] = a[j+1];\n   a[j+1] = tmp;\n   flag = true;\n&#125;\n\n插入排序中数据的移动操作：\nif (a[j] > value) &#123;\n  a[j+1] = a[j];  // 数据移动\n&#125; else &#123;\n  break;\n&#125;\n","slug":"DSA/C11 排序(上)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"9be35293ffa6798064be3bddd6f599aa","title":"DSA12 Sort2","content":"排序（下）：如何用快排思想在$O(n)$​内查找第K大元素？引入两种时间复杂度为$O(nlogn)$的排序算法\n\n归并排序\n快速排序\n\n归并排序（Merge sort）原理及实现\n\n数组从中间分成前后两部分\n对前后两部分分别排序\n再将排好序的两部分合并在一起\n\n递推公式：\nmerge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))\n\n终止条件：\np >= r 不用再继续分解\n// 归并排序算法, A是数组，n表示数组大小\nmerge_sort(A, n) &#123;\n  merge_sort_c(A, 0, n-1)\n&#125;\n\n// 递归调用函数\nmerge_sort_c(A, p, r) &#123;\n  // 递归终止条件\n  if p >= r  then return\n\n  // 取p到r之间的中间位置q\n  q = (p+r) / 2\n  // 分治递归\n  merge_sort_c(A, p, q)\n  merge_sort_c(A, q+1, r)\n  // 将A[p...q]和A[q+1...r]合并为A[p...r]\n  merge(A[p...r], A[p...q], A[q+1...r])\n&#125;\n\nmerge函数的伪代码\nmerge(A[p...r], A[p...q], A[q+1...r]) &#123;\n  var i := p，j := q+1，k := 0 // 初始化变量i, j, k\n  var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组\n  while i&lt;=q AND j&lt;=r do &#123;\n    if A[i] &lt;= A[j] &#123;\n      tmp[k++] = A[i++] // i++等于i:=i+1\n    &#125; else &#123;\n      tmp[k++] = A[j++]\n    &#125;\n  &#125;\n  \n  // 判断哪个子数组中有剩余的数据\n  var start := i，end := q\n  if j&lt;=r then start := j, end:=r\n  \n  // 将剩余的数据拷贝到临时数组tmp\n  while start &lt;= end do &#123;\n    tmp[k++] = A[start++]\n  &#125;\n  \n  // 将tmp中的数组拷贝回A[p...r]\n  for i:=0 to r-p do &#123;\n    A[p+i] = tmp[i]\n  &#125;\n&#125;\n性能分析\n稳定\n\n时间复杂度\n\n\nT(a) = T(b) + T(c) + K  \\\\\n\nT(1) = C \\\\\nT(n) = 2*T(n/2) + n； n>1 \\\\\n\nT(1) = C\\\\\n\nT(n) = 2*T(n/2) + n\\\\\n     = 2*(2*T(n/4) + n/2) + n \\\\= 4*T(n/4) + 2*n\\\\\n     = 4*(2*T(n/8) + n/4) + 2*n \\\\= 8*T(n/8) + 3*n\\\\\n     = 8*(2*T(n/16) + n/8) + 3*n \\\\= 16*T(n/16) + 4*n\\\\\n     ......\\\\\n     = 2^k * T(n/2^k) + k * n\\\\\n     ......$O(nlogn)$\n\n\n\n空间复杂度\n\n合并函数在合并时，需要借助额外的存储空间\n$O(n)$\n\n\n\n快速排序（Quick sort）原理及实现思想：\n\n递推公式：\nquick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)\n\n终止条件：\np >= r\n// 快速排序，A是数组，n表示数组的大小\nquick_sort(A, n) &#123;\n  quick_sort_c(A, 0, n-1)\n&#125;\n// 快速排序递归函数，p,r为下标\nquick_sort_c(A, p, r) &#123;\n  if p >= r then return\n  \n  q = partition(A, p, r) // 获取分区点\n  quick_sort_c(A, p, q-1)\n  quick_sort_c(A, q+1, r)\n&#125;\npartition函数--非原地\n\npartition函数--原地\n\npartition(A, p, r) &#123;\n  pivot := A[r]\n  i := p\n  for j := p to r-1 do &#123;\n    if A[j] &lt; pivot &#123;\n      swap A[i] with A[j]\n      i := i+1\n    &#125;\n  &#125;\n  swap A[i] with A[r]\n  return i\n对比\n","slug":"DSA/C12 排序(下)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"f0bf7281fb0e82f54bc8de918f6f9204","title":"DSA13 Sort3","content":"线性排序：如何根据年龄给100万用户数据排序？引入三种时间复杂度为$O(n)$的排序算法\n\n桶排序\n计数排序\n基数排序\n\n非基于比较的排序算法→时间复杂度为线性\n桶排序（Bucket sort）\n计数排序（counting sort）\n桶排序的特殊情况\n所处范围不大，最大值为k，划分为k个桶\n\n实现方法原始数据：2，5，3，0，2，3，0，3\n\n// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。\npublic void countingSort(int[] a, int n) &#123;\n  if (n &lt;= 1) return;\n\n  // 查找数组中数据的范围\n  int max = a[0];\n  for (int i = 1; i &lt; n; ++i) &#123;\n    if (max &lt; a[i]) &#123;\n      max = a[i];\n    &#125;\n  &#125;\n\n  int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max]\n  for (int i = 0; i &lt;= max; ++i) &#123;\n    c[i] = 0;\n  &#125;\n\n  // 计算每个元素的个数，放入c中\n  for (int i = 0; i &lt; n; ++i) &#123;\n    c[a[i]]++;\n  &#125;\n\n  // 依次累加\n  for (int i = 1; i &lt;= max; ++i) &#123;\n    c[i] = c[i-1] + c[i];\n  &#125;\n\n  // 临时数组r，存储排序之后的结果\n  int[] r = new int[n];\n  // 计算排序的关键步骤，有点难理解\n  for (int i = n - 1; i >= 0; --i) &#123;\n    int index = c[a[i]]-1;\n    r[index] = a[i];\n    c[a[i]]--;\n  &#125;\n\n  // 将结果拷贝给a数组\n  for (int i = 0; i &lt; n; ++i) &#123;\n    a[i] = r[i];\n  &#125;\n&#125;\n\n数据范围不大场景\n给非负整数排序，否则需要转化\n\n基数排序（radix sort）    \n","slug":"DSA/C13 线性排序","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"bb3030af5d71baf7746e61c6c316baf8","title":"DSA14 Sort4","content":"排序优化：如何实现一个通用的、高性能的排序函数？如何选择合适的排序算法\n\n线性排序场景特殊，不选用\n为了兼顾任意规模，首选时间复杂度为$O(nlogn)$\n归并排序空间复杂度可能较高\n\n故选择快速排序\n如何优化快速排序理想分区点：被分区点分开的两个分区中，数据的数量差不多\n\n三数取中法\n随机法\n\n","slug":"DSA/C14 排序优化","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"4fbc272395db721664d9df9e591dbece","title":"DSA15 Binary Search1","content":"二分查找（上）：如何用最省内存的方式实现快速查找功能？无处不在的二分思想\n\n二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0\nO(logn)惊人的查找速度\n\nlog_2 2^{32} = 32二分查找的递归与非递归实现循环实现public int bsearch(int[] a, int n, int value) &#123;\n  int low = 0;\n  int high = n - 1;\n\n  while (low &lt;= high) &#123;\n    int mid = (low + high) / 2;\n    if (a[mid] == value) &#123;\n      return mid;\n    &#125; else if (a[mid] &lt; value) &#123;\n      low = mid + 1;\n    &#125; else &#123;\n      high = mid - 1;\n    &#125;\n  &#125;\n\n  return -1;\n&#125;\n容易出错的3个地方\n\n循环退出条件\nlow&lt;=high，而非low&lt;high\n\n\nmid取值\nmid = (low+high)/2 大数情况下容易溢出\nmid = low +(high - low)/2\nmid = low + ((high-low)&gt;&gt;1)\n\n\nlow和high的更新\nlow = mid + 1\nhigh = mid - 1\n\n\n\n递归实现// 二分查找的递归实现\npublic int bsearch(int[] a, int n, int val) &#123;\n  return bsearchInternally(a, 0, n - 1, val);\n&#125;\n\nprivate int bsearchInternally(int[] a, int low, int high, int value) &#123;\n  if (low > high) return -1;\n\n  int mid =  low + ((high - low) >> 1);\n  if (a[mid] == value) &#123;\n    return mid;\n  &#125; else if (a[mid] &lt; value) &#123;\n    return bsearchInternally(a, mid+1, high, value);\n  &#125; else &#123;\n    return bsearchInternally(a, low, mid-1, value);\n  &#125;\n&#125;\n二分查找应用场景的局限性\n依赖顺序表结构，即数组\n需要按照下标随机访问元素\n\n\n针对有序数据\n数据量太小不适合二分查找\n数据量太大不适合二分查找\n\n","slug":"DSA/C15 二分查找(上)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"4c75cfdca780ea6522270fb11aab65bd","title":"DSA16 Binary Search2","content":"二分查找（下）：如何快速定位IP对应的省份地址？引入\n查找第一个值等于给定值的元素\npublic int bsearch(int[] a, int n, int value) &#123;\n  int low = 0;\n  int high = n - 1;\n  while (low &lt;= high) &#123;\n    int mid = low + ((high - low) >> 1);\n    if (a[mid] >= value) &#123;\n      high = mid - 1;\n    &#125; else &#123;\n      low = mid + 1;\n    &#125;\n  &#125;\n\n  if (low &lt; n &amp;&amp; a[low]==value) return low;\n  else return -1;\n&#125;\npublic int bsearch(int[] a, int n, int value) &#123;\n  int low = 0;\n  int high = n - 1;\n  while (low &lt;= high) &#123;\n    int mid =  low + ((high - low) >> 1);\n    if (a[mid] > value) &#123;\n      high = mid - 1;\n    &#125; else if (a[mid] &lt; value) &#123;\n      low = mid + 1;\n    &#125; else &#123;\n      if ((mid == 0) || (a[mid - 1] != value)) return mid;\n      else high = mid - 1;\n    &#125;\n  &#125;\n  return -1;\n&#125;\n\n很多人都觉得变形的二分查找很难写，主要原因是太追求第一种那样完美、简洁的写法\n对于工程开发的人来说，代码易读懂、没 Bug，其实更重要\n\n查找最后一个值等于给定值的元素public int bsearch(int[] a, int n, int value) &#123;\n  int low = 0;\n  int high = n - 1;\n  while (low &lt;= high) &#123;\n    int mid =  low + ((high - low) >> 1);\n    if (a[mid] > value) &#123;\n      high = mid - 1;\n    &#125; else if (a[mid] &lt; value) &#123;\n      low = mid + 1;\n    &#125; else &#123;\n      if ((mid == n - 1) || (a[mid + 1] != value)) return mid;\n      else low = mid + 1;\n    &#125;\n  &#125;\n  return -1;\n&#125;\n查找第一个大于等于给定值的元素public int bsearch(int[] a, int n, int value) &#123;\n  int low = 0;\n  int high = n - 1;\n  while (low &lt;= high) &#123;\n    int mid =  low + ((high - low) >> 1);\n    if (a[mid] >= value) &#123;\n      if ((mid == 0) || (a[mid - 1] &lt; value)) return mid;\n      else high = mid - 1;\n    &#125; else &#123;\n      low = mid + 1;\n    &#125;\n  &#125;\n  return -1;\n&#125;\n查找最后一个小于等于给定值的元素public int bsearch7(int[] a, int n, int value) &#123;\n  int low = 0;\n  int high = n - 1;\n  while (low &lt;= high) &#123;\n    int mid =  low + ((high - low) >> 1);\n    if (a[mid] > value) &#123;\n      high = mid - 1;\n    &#125; else &#123;\n      if ((mid == n - 1) || (a[mid + 1] > value)) return mid;\n      else low = mid + 1;\n    &#125;\n  &#125;\n  return -1;\n&#125;\n","slug":"DSA/C16 二分查找(下)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"0bec27181caef93fd79c11aa3edf5064","title":"DSA17 Skip List","content":"跳表：为什么Redis一定要用跳表来实现有序集合？引入如果数据存储在链表中，真的没法用二分查找算法了吗？\n跳表是一种各方面性能都比较优秀的动态数据结构，支持快速地插入、删除、查找操作\n如何理解跳表\n\n\n跳表 = 链表 + 多级索引用跳表查询到底有多快？graph TD\n链表n个结点 --每两个结点抽出一个结点作为上一级索引的结点 --> 第k级索引的结点个数为n/2`k\n\n\n\n跳表是不是很浪费内存？每2个结点抽1个\n\n\n\\frac{n}{2}+\\frac{n}{4}+\\cdots+8+4+2 = n-2需要额外再用接近n个结点的存储空间\n每3个结点抽1个\n\n\\frac{n}{3}+\\frac{n}{9}+\\cdots+9+3+1 = \\frac{n}{2}比上述情况减少了一般的索引结点存储空间\n实际情况实际上，在软件开发中，我们不必太在意索引占用的额外空间\n在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数\n但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象\n所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了\n高效的动态插入和删除插入\n删除如果结点在索引中也有出现，除了要删除原始链表中的结点，还要删除索引中的\n\n单向链表：一定要获取前驱结点\n双向链表：不需要考虑这个问题\n\n跳表索引的动态更新\n\n动态数据结构，需要某种手段来维护索引与原始链表大小之间的平衡\n链表结点增多→索引结点相应增加，避免复杂度退化及查找、插入、删除操作性能下降\n通过随机函数维护平衡性\n\n\n\n\n","slug":"DSA/C17 跳表","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"f2a6a2cecbbac22b23528956a3dabf70","title":"DSA18 Hash Table1","content":"散列表（上）：Word文档中的单词拼写检查功能是如何实现的？引入Word拼写检查功能\n散列思想Hash Table\n散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表\n经典例子\n\n\n参赛选手的编号：key 关键字\n\n标识一个选手\n\n\n参赛编号转化为数组下标的映射方法：Hash函数\n\n在本例中为选取key的后两位\n\n\n散列函数计算得到的值：Hash值\n\n\n\n  graph TD\nKey --HashFunction-->table -->索引\n\n\n\n散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性\n我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置\n当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据\n散列函数\n散列函数 = hash(key)int hash(String key) &#123;\n  // 获取后两位字符\n  string lastTwoChars = key.substr(length-2, length);\n  // 将后两位字符转换为整数\n  int hashValue = convert lastTwoChas to int-type;\n  return hashValue;\n&#125;\n散列函数设计基本要求\n\n散列函数计算得到的散列值是一个非负整数\n\n\nif \\quad key1 == key2 →hash(key1) == hash(key2)\n\nif \\quad key1 \\not= key2 →hash(key1) \\not= hash(key2)\n\n\n\n\n\n\n\n\n\n\n散列冲突：\n要想找到一个不同的key对应的散列值都不一样的散列函数，几乎是不可能的；\n而且因为数组的存储空间有限，也会加大散列冲突的概率\n散列冲突如何解决散列冲突问题呢？\n\n开放寻址法 Open Addressing\n如果出现了散列冲突，重新探测一个空闲位置，将其插入\n线性探测Linear  Probing\n二次探测Quadratic Probing\n双重散列Double hashing\n\n\n链表法 Chaining\n\n开放寻址法线性探测法当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次向后查找，看是否有空闲位置，直到找到为止\n\n\n\n插入\n查找\n删除→不能单纯把要删除的元素设置为空，会导致查找算法失效，故可以将删除的元素标记为deleted\n当线性探测查找时，遇到标记为deleted空间并不是停下来而是继续往下探测\n\n\n\n\n线性探测法的问题\n\n散列表中插入数据越来越多时，散列冲突发生可能性越来越大，空闲位置越来越少\n\n二次探测二次探测步长为原来的二次方\n\nhash(key)+0\\\\\nhash(key)+1^2\\\\\nhash(key) + 2^2\\\\\n\\cdots双重散列不仅要使用一个散列函数，而是使用一组散列函数\n\nhash1(key1) \\\\\nhash2(key2)\\\\\nhash3(key3)装载因子\nload\\_factor = 填入表中的元素个数 /散列表的长度链表法\n每个bucket或slot会对应一条链表\n所有散列值相同的元素都放到相同槽位对应的链表中\n\n\n","slug":"DSA/C18 散列表(上)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"5baaeff214933c2b700d2810a6a1c372","title":"DSA2 如何抓住重点","content":"如何抓住重点，系统高效地学习数据结构与算法？什么是数据结构？什么是算法？广义\n\n数据结构：一组数据的存储结构\n算法：操作数据的一组方法\n\n狭义\n\n著名的数据结构和算法\n\n数据结构与算法的关系\n\n数据结构为算法服务\n算法作用于特定的数据结构\n\n需要的基础\n数学基础\n编程基础\n\n学习重点\n复杂度分析\n如何更省、更快地存储和处理数据的问题\n\n\n其他\n\n\n\n\n常用的基础数据结构和算法10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树\n10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法\n事半功倍学习技巧\n边学边练、适度刷题\n多问、多思考、多互动\n留言区\n避免一知半解\n\n\n打怪升级学习法\n思考题认真思考且回复到留言区\n每节课后都写一篇学习笔记或者学习心得\n\n\n沉淀知识\n\n","slug":"DSA/C2 如何抓住重点","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"81c6479ab642eb7be2481f941202d8fb","title":"DSA19 Hash Table2","content":"散列表（中）：如何打造一个工业级水平的散列表？如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？\n如何设计散列函数好的散列函数要求\n\n设计不能太复杂\n过于复杂散列函数，消耗很多计算时间\n\n\n散列函数生成的值要尽可能随机且均匀分布\n避免或者最小化散列冲突\n即使冲突，散列到每个槽里的数据也会比较平均\n\n\n\n装载因子过大怎么办\n静态数据集合\n没有频繁插入和删除\n容易根据数据特点、分布，设计完美、极少冲突的散列函数\n\n\n动态散列表\n数据频繁变动，事先无法预估将要加入的数据个数\n无法事前申请一个足够大的散列表\n数据慢慢加入，装填因子变大，大到一定程度，散列冲突不可接受\n\n\n\n解决方法：动态扩容\n\n重新申请一个更大的散列表，将数据搬移到这个新散列表中\n\n\ngraph TD\n插入数据 -->最好情况 -->不需扩容\n插入数据 --> 最坏情况 --> 装载因子过高 -->启动扩容 -->重新申请内存空间 -->重新计算哈希位置 -->搬移数据\n\n\n如何避免低效的扩容为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成\n\n这期间的查询操作如何来做？\n答：先从新散列表中查找，如果没有找到，再去老散列表中查找\n如何选择冲突解决办法\n\n\n\n\n开放寻址法\n链表法\n\n\n\n\n优点\n散列表中数据都存储在数组中，可以有效地利用CPU缓存加快查询速度序列化起来比较简单\n对内存的利用率比开放寻址法要高对大装载因子的容忍度更高\n\n\n缺点\n删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据所有数据都存储在一个数组中，比起链表法来说，冲突代价更高\n对比较小的对象存储，比较消耗内存结点零散分布，不连续，对CPU缓存不友好\n\n\n适用场景\n数据量比较小装载因子小\n存储大对象、大数据量的散列表\n\n\n\n\n对链表法的改造\n\n工业级散列表举例分析Java Hash Map\n\n\n\n\n项目\n设计\n\n\n\n\n初始大小\n16\n\n\n装载因子和动态扩容\n最大装载因子默认为0.75，扩容为原来两倍大小\n\n\n散列冲突解决方法\n底层采用链表法JDK1.8版本中，当链表长度太长(默认超过8时)，链表就转换为红黑树红黑树结点少于8个时，将红黑树转化为链表\n\n\n散列函数\nhash(object key) hashCode()\n\n\n\n\nint hash(Object key) &#123;\n    int h = key.hashCode()；\n    return (h ^ (h >>> 16)) &amp; (capicity -1); //capicity表示散列表的大小\n&#125;\npublic int hashCode() &#123;\n  int var1 = this.hash;\n  if(var1 == 0 &amp;&amp; this.value.length > 0) &#123;\n    char[] var2 = this.value;\n    for(int var3 = 0; var3 &lt; this.value.length; ++var3) &#123;\n      var1 = 31 * var1 + var2[var3];\n    &#125;\n    this.hash = var1;\n  &#125;\n  return var1;\n&#125;\n解答开篇工业级散列表特性\n\n支持快速查询、插入、删除操作\n内存占用合理，不能浪费过多内存空间\n性能稳定，极端情况下也不会退化到无法接受的情况\n\n如何实现\n\n合适散列函数\n定义装载因子阈值，设计动态扩容策略\n合适散列冲突解决方法\n\n","slug":"DSA/C19 散列表(中)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"4b485bd537f5fd1e1b5f6120bc5388d2","title":"DSA20 Hash Table3","content":"散列表（下）：为什么散列表和链表经常会一起使用？LRU缓存淘汰算法链表实现回顾.assets/image-20210724173623972-1627546113415.png)\n一个缓存cache系统包含下面几个操作\n\n添加数据\n删除数据\n查找数据\n\n如果我们将散列表和链表两种数据结构组合使用，三个操作的时间复杂度都可降低到$O(1)$\n\n\n\n\n\n字段\n作用\n\n\n\n\ndata\n存储数据\n\n\nprev\n前驱指针\n\n\nnext\n后继指针\n\n\nhnext\n为了将结点串在散列表的拉链中\n\n\n\n\n\n\n\n\n操作\n具体\n\n\n\n\n查找数据\n1.散列表在缓存中找到数据2.移动到双向链表尾部\n\n\n删除数据\n1.找到数据所在结点2.将结点删除\n\n\n添加数据\n如下图\n\n\n\n\ngraph TD\n看数据是否在缓存中 -->在缓存中 -->移动到双向链表尾部\n看数据是否在缓存中 --> 不在缓存中 --> 看缓存有没有满 -->已满 -->将双向链表头部结点删除.再将数据放到链表尾部\n看缓存有没有满 -->未满--> 直接将数据放到链表尾部\n\n\nRedis有序集合细化Redis有序集合的操作\n\n添加一个成员对象\n按照键值删除一个成员对象\n按照键值查找一个成员对象\n按照分值区间查找数据\n按照分值从小到大排序成员变量\n\nJava LinkedHashMapLinkedHashMap并非是一个通过链表法解决散列冲突的散列表\nHashMap&lt;Integer, Integer&gt; m &#x3D; new LinkedHashMap&lt;&gt;();\nm.put(3, 11);\nm.put(1, 12);\nm.put(5, 23);\nm.put(2, 22);\n\nfor (Map.Entry e : m.entrySet()) &#123;\n  System.out.println(e.getKey());\n&#125;\n结果：打印3,1,5,2→支持按照插入顺序遍历数据\n&#x2F;&#x2F; 10是初始大小，0.75是装载因子，true是表示按照访问时间排序\nHashMap&lt;Integer, Integer&gt; m &#x3D; new LinkedHashMap&lt;&gt;(10, 0.75f, true);\nm.put(3, 11);\nm.put(1, 12);\nm.put(5, 23);\nm.put(2, 22);\n\nm.put(3, 26);\nm.get(5);\n\nfor (Map.Entry e : m.entrySet()) &#123;\n  System.out.println(e.getKey());\n&#125;\n结果：打印1,2,3,5→支持按照访问顺序来遍历数据\n\n\n\nLinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突\n","slug":"DSA/C20 散列表(下)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"df821ff4999b5ea1cca6788fc47b1fb5","title":"DSA21 Hash Algorithm1","content":"哈希算法（上）：如何防止数据库中的用户信息被脱库？引入\n2011CSDN“脱库”事件\n在实际开发中，如何用哈希算法解决问题\n\n什么是哈希算法？哈希算法：将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法。而通过原始数据映射之后得到的二进制值串就是哈希值。\n优秀哈希算法的要求\n\n从哈希值不能反向推导出原始数据\n对输入数据非常敏感\n散列冲突的概率要很小\n执行效率要尽量高效，针对较长的文本，也能快速计算出哈希值\n\n以MD5为例MD5(\"今天我来讲哈希算法\") = bb4767201ad42c74e650c1b6c03d78fa\nMD5(\"jiajia\") = cd611a31ea969b908932d44d126d195b\nMD5(\"我今天讲哈希算法！\") = 425f0d5a917188d2c3c3dc85b5e4f2cb\nMD5(\"我今天讲哈希算法\") = a1fb91ac128e6aa37fe42c663971ac3d\n哈希算法的应用安全加密\nMD5 Message-Digest Algorithm\nSHA Secure Hash Algorithm\nDES Data Encryption Standard\nAES Advanced Encryption Standard\n\n对用于加密的哈希算法来说，有两点格外重要\n\n很难根据哈希值反向推导出原始数据→防止原始数据被泄露\n散列冲突概率很小\n理论上没办法做到完全不冲突→鸽巢原理\n哈希算法产生的哈希值的长度固定且有限→能表示的数据有限→我们要哈希的数据是无穷的\n\n\n\n唯一标识\ngraph TD\n海量图库搜素图片-->不能单纯用图片元信息-->每个图片取一个唯一标识 -->唯一标识和相应图片文件路径信息都存储在散列表中\n\n数据校验\ngraph TD\n100个文件块 --哈希算法-->哈希值--存储-->种子文件 -->文件下载完成 -->对下载好的文件块逐一求哈希值 -->与种子文件保存的哈希值比对 -->相同 -->下载完成\n与种子文件保存的哈希值比对 -->不同 -->重新下载这个文件块\n\n散列函数散列函数也是哈希算法的一种应用\n\n相对哈希算法的其他应用，散列函数对于散列算法冲突的要求低很多\n\n散列函数对于散列算法计算得到的值，是否能反向解密也并不关心\n\n更加关注散列后的值能否平均分布\n更加追求效率\n\n解答开篇\n\n\n\n\n\n\n\n\n字典攻击：黑客拿到加密之后的密文，但可以通过猜来破解\n\n维护一个常用密码的字典表\n字典中每个密码用哈希算法计算哈希值\n拿哈希值跟脱库后的密文比对\n\n解决方案：\n\n引入salt\n跟用户密码组合在一起\n拿组合后的字符串做哈希算法加密，存储到数据库中\n\n","slug":"DSA/C21 哈希算法(上)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"a8b428ae06db3a75338b25077c7c9ca3","title":"DSA22 Hash Algorithm2","content":"哈希算法（下）：哈希算法在分布式系统中有哪些应用？哈希算法是如何解决这些分布式问题的\n负载均衡负载均衡算法很多，如何才能实现一个会话粘滞的负载均衡算法？即需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上\n\n直接的办法\n维护一张映射关系表\n弊端\n客户端很多，映射表很大，浪费内存\n客户端下线、上线，服务器扩容、缩容都会导致映射失效，维护映射表成本很大\n\n\n\n\n哈希算法\n\n\ngraph TD\n客户端IP地址/会话ID --哈希算法-->哈希值 --与服务器列表大小进行取模运算-->应该被路由到的服务器编号\n\n数据分片如何统计“搜索关键词”出现的次数？难点\n\n搜索日志很大，没办法放到一台机器的内存中\n如果只用一台机器处理，时间会很长\n\n解决方案\n\n先对数据分片\n后采用多台机器处理\n\n具体思路\n\ngraph TD\n搜索记录的日志文件 --读取-->搜索关键词 --哈希函数-->哈希值 --与机器的台数n取模-->应该被分配到的机器编号 --> 哈希值相同的搜索关键词就被分配到了同一个机器上\n\n如何快速判断图片是否在图库中？问题\n\n假设现在图库中有1亿张图片，在单台机器上构建散列表行不通，因为单台机器内存有限\n\n解决思路\n\n对数据分片\n采用多机处理\n\n具体实现\n\ngraph TD\n准备n台机器且每台机器只维护某一部分图片对应的散列表 -->读取图片且计算唯一标识 --与机器个数n求余取模-->要分配的机器编号 -->将图片唯一标识和图片路径发往对应的机器 -->构建散列表  \n图片--哈希算法--> 唯一标识 --与机器个数n求余取模-->得到值为k则去编号k的机器构建的散列表中查找\n\n分布式存储\ngraph TD\n海量数据需要缓存 --哈希算法取哈希值后对机器个数取模-->数据分布在多台机器\n-->数据增多需扩容 --一致性哈希算法-->新机器加入时将某几个小区间数据从原来机器搬移到新机器\n\n\n\n所有数据都要重新计算哈希值\n缓存中的数据一下都失效了\n据请求都会穿透缓存，直接请求数据库\n发生雪崩效应，压垮数据库\n\n一致性哈希算法\n\n假设k个机器，数据的哈希值范围是[0,MAX]\n将整个范围划分为m个小区间，每个机器负责m/k个区间\n当有新机器加入时，就将某几个小区间数据从原来机器中搬移到新的机器中\n\n","slug":"DSA/C22 哈希算法(下)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"56aa12aba5d53418e62bb5c5f6efe64b","title":"DSA23 Binary Tree1","content":"二叉树基础（上）：什么样的二叉树适合用数组来存储？问题引入\n二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？\n树\n\n\n\n\n名词\n定义\n\n\n\n\n节点\n树中的每个元素\n\n\n父子关系\n用来连接相邻节点之间的关系\n\n\n父节点\n上级节点\n\n\n子节点\n下级节点\n\n\n兄弟节点\n同级节点\n\n\n叶子节点/叶节点\n没有子节点的节点\n\n\n节点高度\n节点到叶子节点的最长路径（边数）\n\n\n节点深度\n根节点到这个节点所经历的边的个数\n\n\n节点层数\n节点深度+1\n\n\n树的高度\n根节点的高度\n\n\n\n\n\n二叉树相关定义每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点\n\n\n满二叉树，2，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点\n完全二叉树，3，叶子节点都在最底两层，最后一层叶子节点靠左排列，除了最后一层，其它层节点个数都要达到最大\n\n\n如何表示（存储）一棵二叉树？\n链式存储法\n基于指针或者引用\n\n\n\n顺序存储法\n基于数组\n\n节点 X 存储在数组中下标为 i 的位置，下标为 2  i 的位置存储的就是左子节点，下标为 2  i + 1 的位置存储的就是右子节点\n反过来，下标为 i/2 的位置存储就是它的父节点。\n\n\n\n非完全二叉树会浪费比较多的数组存储空间\n\n结论：\n如果某棵二叉树是一棵完全二叉树，用数组无疑是最节省内存的一种方式。数组不需额外存储左右子节点指针\n二叉树的遍历\n递推公式\n前序遍历的递推公式：\npreOrder(r) &#x3D; print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)\n\n中序遍历的递推公式：\ninOrder(r) &#x3D; inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)\n\n后序遍历的递推公式：\npostOrder(r) &#x3D; postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r\n代码\nvoid preOrder(Node* root) &#123;\n  if (root == null) return;\n  print root // 此处为伪代码，表示打印root节点\n  preOrder(root->left);\n  preOrder(root->right);\n&#125;\n\nvoid inOrder(Node* root) &#123;\n  if (root == null) return;\n  inOrder(root->left);\n  print root // 此处为伪代码，表示打印root节点\n  inOrder(root->right);\n&#125;\n\nvoid postOrder(Node* root) &#123;\n  if (root == null) return;\n  postOrder(root->left);\n  postOrder(root->right);\n  print root // 此处为伪代码，表示打印root节点\n&#125;\n遍历的时间复杂度\n$O(n)$\n","slug":"DSA/C23 二叉树基础(上)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"17d7fb60ad31417e734a0509256cfdc1","title":"DSA24 Binary Tree2","content":"二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？二叉查找树的最大特点：支持动态数据集合的快速插入、删除、查找\n散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是 O(1)。既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？\n二叉查找树二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值\n\n\n\n\n\n操作\n图解\n代码\n\n\n\n\n查找\n\n.assets/image-20210801093054515.png)\n\n\n插入\n\n.assets/image-20210801093117826.png)\n\n\n删除\n\n.assets/image-20210801093217055.png)\n\n\n\n\n\n查找操作\ngraph TD\n 取根节点-->等于查找的数据--> yes -->返回\n等于查找的数据--> no --> 查找数据比根节点值小 -->左子树递归查找\nno --> 查找数据比根节点值大-->右子树递归查找\n\npublic class BinarySearchTree &#123;\n  private Node tree;\n\n  public Node find(int data) &#123;\n    Node p = tree;\n    while (p != null) &#123;\n      if (data &lt; p.data) p = p.left;\n      else if (data > p.data) p = p.right;\n      else return p;\n    &#125;\n    return null;\n  &#125;\n\n  public static class Node &#123;\n    private int data;\n    private Node left;\n    private Node right;\n\n    public Node(int data) &#123;\n      this.data = data;\n    &#125;\n  &#125;\n&#125;\n插入操作\ngraph TD\n 自上而下取节点--> 插入数据比节点数据大 -->节点右子树为空 -->插入到右子节点位置\n 插入数据比节点数据大 -->节点右子树不为空 -->递归遍历右子树查找插入位置\n  自上而下取节点--> 插入数据比节点数据小 -->节点左子树为空 -->插入到左子节点位置\n  插入数据比节点数据小 -->节点左子树不为空 -->递归遍历左子树查找插入位置\n\npublic void insert(int data) &#123;\n  if (tree == null) &#123;\n    tree = new Node(data);\n    return;\n  &#125;\n\n  Node p = tree;\n  while (p != null) &#123;\n    if (data > p.data) &#123;\n      if (p.right == null) &#123;\n        p.right = new Node(data);\n        return;\n      &#125;\n      p = p.right;\n    &#125; else &#123; // data &lt; p.data\n      if (p.left == null) &#123;\n        p.left = new Node(data);\n        return;\n      &#125;\n      p = p.left;\n    &#125;\n  &#125;\n&#125;\n删除操作graph LR\n删除的节点没有子节点  --> 直接将父节点中指向要删除节点的指针置为null\n\n\n删除的节点只有一个子节点--> 直接将父节点中指向要删除节点的指针指向要删除节点的子节点\n\n删除的节点有两个子节点 --> 找到节点右子树中的最小节点 -->替换到要删除的节点上 -->删除最小节点\n\n\n代码\npublic void delete(int data) &#123;\n  Node p = tree; // p指向要删除的节点，初始化指向根节点\n  Node pp = null; // pp记录的是p的父节点\n  while (p != null &amp;&amp; p.data != data) &#123;\n    pp = p;\n    if (data > p.data) p = p.right;\n    else p = p.left;\n  &#125;\n  if (p == null) return; // 没有找到\n\n  // 要删除的节点有两个子节点\n  if (p.left != null &amp;&amp; p.right != null) &#123; // 查找右子树中最小节点\n    Node minP = p.right;\n    Node minPP = p; // minPP表示minP的父节点\n    while (minP.left != null) &#123;\n      minPP = minP;\n      minP = minP.left;\n    &#125;\n    p.data = minP.data; // 将minP的数据替换到p中\n    p = minP; // 下面就变成了删除minP了\n    pp = minPP;\n  &#125;\n\n  // 删除节点是叶子节点或者仅有一个子节点\n  Node child; // p的子节点\n  if (p.left != null) child = p.left;\n  else if (p.right != null) child = p.right;\n  else child = null;\n\n  if (pp == null) tree = child; // 删除的是根节点\n  else if (pp.left == p) pp.left = child;\n  else pp.right = child;\n&#125;\n另一种简单的办法\n\n单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉\n浪费内存，但操作简单\n没有增加插入、查找操作代码实现的难度\n\n支持重复数据的二叉查找树\n实际软件开发中，二叉查找树中存储的是一个包含很多字段的对象\n\n利用对象的某个字段作为key来构建二叉查找树\n\n对象中的其他字段叫做卫星数据\n\n那么存储的两个对象键值相同该如何处理\n\n方法1：通过链表和支持动态扩容的数组等数据结构把值相同的数据都存储在同一个节点上\n方法2\n\n\n\n\n解答开篇Why 二叉查找树？\n\n散列表无需存储，二叉树只需要中序遍历\n散列表扩容耗时很多，且遇到散列冲突性能不稳定\n尽管散列表查找等操作的时间复杂度为常量级，但因为哈希冲突存在常量不一定比logn小\n散列表构造比二叉查找树复杂\n为避免过多散列冲突，装载因子不能太大\n\n","slug":"DSA/C24 二叉树基础(下)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"d603cea4e398050da6c08bad435d355e","title":"DSA25 Red-Black Tree1","content":"红黑树（上）：为什么工程中都用红黑树这种二叉树？引入\n二叉查找树各个操作时间复杂度跟树的高度成正比，理想情况下，时间复杂度是$O(logn)$\n\n不过二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于$log_2n$的情况，从而导致各个操作的效率下降\n\n为什么工程中都喜欢用红黑树，而不是其他平衡二叉查找树呢？\n\n什么是“平衡二叉查找树”平衡二叉树：二叉树中任意一个节点的左右子树的高度相差不能大于1\n红黑树：从根节点到各个叶子节点的最长路径有可能会比最短路径大一倍\n发明平衡二叉查找树的初衷：\n\n解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现的时间复杂度退化的问题\n\n故平衡\n\n让整棵树左右看起来对称、平衡，不要出现左子树很高、右子树很矮的情况\n让整棵树的高度相对来说低一些，相应操作效率高一些\n\n如何定义一棵红黑树？\nRed-Black Tree，R-B tree\n红黑树中的节点，一类标记为黑色，一类标记为红色\n\n\n\n\n\n节点类型\n颜色\n\n\n\n\n根节点\n黑色\n\n\n叶子节点\n黑色的空节点，不存储数据\n\n\n相邻节点\n不能同时为红色\n\n\n每个节点到其可达叶子节点的所有路径\n包含相同数目的黑色节点\n\n\n\n\n\n为什么说红黑树是近似平衡的？\n平衡→性能不退化\n近似平衡→性能不会退化得太严重\n一棵极其平衡的二叉树的高度大约是$log_2n$，要证明红黑树是近似平衡的，只需要分析红黑树的高度是否比较稳定地趋近$log_2n$就好\n\n推导过程\n\ngraph TD\n将红色节点从红黑树中去掉 --> 单纯包含黑色节点的红黑树的高度是多少\n\n\n\n仅包含黑色节点的四叉树的高度 graph TD\n把红色节点加回去 -->高度变为多少\n\n\n由于红色节点不能相邻，有一个红色节点就至少有一个黑色节点，所以\n最长路径不会超过$2log_2n$\n结论：\n\n红黑树的高度近似$2log_2n$\n\n解答开篇AVL树是一种高度平衡的二叉树\nhttps://baike.baidu.com/item/AVL%E6%A0%91/10986648\n\n优点：查找效率非常高\n缺点：为了维持高度的平衡，需要付出更多代价\n每次插入、删除都要做调整，比较复杂、耗时\n\n\n\n红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低\n","slug":"DSA/C25 红黑树(上)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"134dfc72e46d7c11aedb7ca140c26710","title":"DSA27 Recursion Tree","content":"递归树：如何借助树来求解递归算法的时间复杂度？递归树与时间复杂度分析 \n\n实战1：分析快速排序的时间复杂度假设平均情况下，每次分区后，两个分区的大小比例为1:k，当k=9时，递推公式为：\n\nT(n) = T(\\frac{n}{10})+T(\\frac{9n}{10})+n用递归树来分析：\n\n\n每一层分区操作所遍历的数据的个数之和就是n\n递归树的高度h\n如何求解\n\n\n\n快排过程遍历的数据个数就是hn，时间复杂度为$O(h\\n)$\n所以$O(nlogn)$\n\n\n\n实战2：分析斐波那契数列的时间复杂度\n\n时间复杂度介于$O(2^n)$与$O(2^{\\frac{n}{2}})$\n\n实战3：分析全排列的时间复杂度递推公式\n假设数组中存储的是1，2， 3...n。\n        \nf(1,2,...n) &#x3D; &#123;最后一位是1, f(n-1)&#125; + &#123;最后一位是2, f(n-1)&#125; +...+&#123;最后一位是n, f(n-1)&#125;。\n代码\n// 调用方式：\n// int[]a = a=&#123;1, 2, 3, 4&#125;; printPermutations(a, 4, 4);\n// k表示要处理的子数组的数据个数\npublic void printPermutations(int[] data, int n, int k) &#123;\n  if (k == 1) &#123;\n    for (int i = 0; i &lt; n; ++i) &#123;\n      System.out.print(data[i] + \" \");\n    &#125;\n    System.out.println();\n  &#125;\n\n  for (int i = 0; i &lt; k; ++i) &#123;\n    int tmp = data[i];\n    data[i] = data[k-1];\n    data[k-1] = tmp;\n\n    printPermutations(data, n, k - 1);\n\n    tmp = data[i];\n    data[i] = data[k-1];\n    data[k-1] = tmp;\n  &#125;\n&#125;\n\n时间复杂度介于$O(n!)$与$O(n*n!)$之间\n","slug":"DSA/C27 递归树","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"7693d3ff77636135d449fe9da08ce394","title":"DSA26 Red-Black Tree2","content":"红黑树（下）：掌握这些技巧，你也可以实现一个红黑树\n爱：稳定、高效的性能\n恨：实现起来比较难\n\n实现红黑树的基本思想大致过程遇到什么样的节点排布，我们就对应怎么去调整\n回顾红黑树的要求\n\n\n\n节点类型\n颜色\n\n\n\n\n根节点\n黑色\n\n\n叶子节点\n黑色的空节点，不存储数据\n\n\n相邻节点\n不能同时为红色\n\n\n每个节点到其可达叶子节点的所有路径\n包含相同数目的黑色节点\n\n\n\n\n左右旋\n左旋：围绕某个节点的左旋\n右旋：围绕某个节点的右旋\n\n\n插入操作的平衡调整红黑树规定：\n\n插入节点必须是红色的\n二叉查找树中新插入的节点都放在叶子节点\n\ncases及对应操作\n\n左右旋转\n改变颜色\n关注节点：正在处理的节点\n叔叔节点：父节点的兄弟节点\n祖父节点：父节点的父节点\n\n特殊情况\n\n\n\n\ncase\n操作\n\n\n\n\n插入节点的父节点为黑色\n/\n\n\n插入节点是根节点\n直接改变它的颜色为黑色\n\n\n\n\n其他情况\ncase1：关注节点为a，叔叔节点d为红色\nb、d设为黑色\nc设为红色\n关注节点变为c\n跳到case2或case3\n\n\ncase2：关注节点为a，叔叔节点d为黑色，关注节点a是其父节点b的右子节点\n关注节点变为b\n围绕新的关注节点b左旋\n跳到case3\n\n\ncase3：关注节点是a，叔叔节点d是黑色，关注节点a是其父节点b的左子节点\n围绕关注节点a的祖父节点c右旋\n将关注节点a的父节点b、兄弟节点c颜色互换\n调整结束\n\n\n删除操作的平衡调整针对删除节点初步调整保证整棵红黑树在一个节点删除之后，仍然满足：每个节点从该节点到达其可达叶子节点的所有路径都包含相同数目的黑色节点\ncase1：如果要删除的节点是a，只有一个子节点b\n\n删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样\n节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色\n调整结束，不需要进行二次调整\n\n\ncase2：如果要删除的节点a有两个非空子节点，并且它的后继节点就是节点a的右子节点c\n\n如果节点 a 的后继节点就是右子节点  c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a  的位置。这一部分操作跟普通的二叉查找树的删除操作无异\n然后把节点 c 的颜色设置为跟节点 a 相同的颜色\n如果节点 c  是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红 - 黑”或者“黑 -  黑”\n这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做\n\n\ncase3：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点\n\n找到后继节点 d，并将它删除，删除后继节点 d  的过程参照 CASE  1\n将节点 a 替换成后继节点 d\n把节点 d 的颜色设置为跟节点 a 相同的颜色\n如果节点 d  是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 -  黑”\n这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做\n\n\n针对关注节点进行二次调整保证不能存在相邻的两个红色节点\nCASE 1：如果关注节点是 a，它的兄弟节点 c 是红色的\n\n围绕关注节点 a 的父节点 b 左旋\n关注节点 a 的父节点 b 和祖父节点 c 交换颜色\n关注节点不变\n继续从四种情况中选择适合的规则来调整\n\n\nCASE 2：如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的\n\n将关注节点 a 的兄弟节点 c  的颜色变成红色\n从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色\n给关注节点 a 的父节点 b  添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”\n关注节点从 a 变成其父节点 b\n继续从四种情况中选择符合的规则来调整\n\n\nCASE 3：如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色\n\n围绕关注节点 a 的兄弟节点 c 右旋\n节点 c 和节点 d 交换颜色\n关注节点不变\n跳转到 CASE  4，继续调整\n\n\nCASE 4：如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的\n\n围绕关注节点 a 的父节点 b 左旋\n将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色\n将关注节点 a 的父节点 b 的颜色设置为黑色\n从关注节点 a  中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色\n将关注节点 a 的叔叔节点 e 设置为黑色\n调整结束\n\n\n","slug":"DSA/C26 红黑树(下)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"3d8241738a6ca807ab996c00fc84c560","title":"DSA29 Heap Application","content":"堆的应用：如何快速获取到Top 10最热门的搜索关键词？堆的几个经典应用\n\n优先级队列\n求Top K\n求中位数\n\n堆的应用一：优先级队列\n优先级队列\n队列\n出队顺序按照优先级来\n\n\n优先级队列与堆很像\n插入元素→堆中插入元素\n取出优先级最高的元素→取出堆顶元素\n\n\n\n合并有序小文件\n问题描述\n100个小文件\n每个文件大小为100MB\n每个文件中存储的都是有序字符串\n希望将100个小文件合并为有序大文件\n\n\n整体思路1：数组\n\n\n\n\ngraph TD\n从100个文件中各取第一个字符串 --> 放入数组中比较大小--> 最小的字符串放入合并后的大文件中--> 删除对应数组\n\n\n整体思路2：优先级队列\n\n\n\n\ngraph TD\n小文件中取出的字符串放入小顶堆中 --> 将字符串放入到大文件中.并将其从堆中删除\n--> 再从小文件中取出下一个字符串.放入堆中 --> 循环操作\n\n高性能定时器\n解决方案\n\n每过1秒就扫描一遍任务列表→低效\n任务约定执行时间离当前时间可能还有很久\n每次都要扫描整个任务列表，列表大则会很耗时\n\n\n优先级队列\n\n\n\n\ngraph TD\n任务 --按照任务设定的执行时间 -->存储在优先级队列中 -->拿队首任务的执行时间点与当前时间点相减得到间隔T \n--> 经过T后执行任务 --新一轮-->任务\n\n堆的应用二：求Top K抽象为两类\n\n静态数据集合\n数据集合事先确定，不会再变\n\n\n动态数据集合\n数据集合事先并不确定，有数据动态加入到集合中\n\n\n\n静态：\n\ngraph TD\n维护一个大小为K的小顶堆 --> 顺序遍历数组 --> 从数组中取出数据与堆顶元素比较\n--> 比堆顶元素大 -->  堆顶元素删除且将该元素插入堆中\n\n从数组中取出数据与堆顶元素比较 --> 比堆顶元素小  --> 不作处理 --> 继续遍历数组\n\n动态：\ngraph TD\n维护一个K大小的小顶堆 --数据被添加到集合中时-->拿它与堆顶元素对比 --> 比堆顶元素大 \n\n--> 堆顶元素删除且将该元素插入堆中\n\n拿它与堆顶元素对比 --> 比堆顶元素小 --> 不作处理\n\n堆的应用三：求中位数如何求动态数据集合中的中位数\n借助堆这种数据结构，我们不用排序，就可以非常高效地实现求中位数操作\n\n\n\ngraph TD \n维护两个堆 --> 大顶堆存储前半部分数据 -->加入元素 --小于等于大顶堆堆顶元素?-->yes -->新数据插入到大顶堆 --> 元素不满足约定 -->堆中不停将堆顶元素移到另一个堆\n维护两个堆 --> 小顶堆存储后半部分数据-->加入元素--小于等于大顶堆堆顶元素?-->no -->新数据插入到小顶堆--> 元素不满足约定-->堆中不停将堆顶元素移到另一个堆\n\n解答开篇假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？\n处理场景限定为单机、可使用内存为1GB\n散列表解决方案graph TD\n顺序扫描10亿个搜索关键词 --> 散列表查询 -->存在 -->次数加1 --> 用堆求TOPK \n 散列表查询 -->不存在 --> 插入到散列表并记录次数为1  --> 用堆求TOPK\n\n 用堆求TOPK --> 建立一个大小为10的小顶堆 --> 遍历散列表依次取出每个搜索关键词即对应出现的次数 -->与堆顶搜索关键词对比 --出现次数比堆顶搜索关键词的次数多--> 删除堆顶关键词并将这个出现次数更多地关键词加入到堆中\n\n漏洞\n10 亿的关键词还是很多的。我们假设 10 亿条搜索关键词中不重复的有 1 亿条，如果每个搜索关键词的平均长度是 50 个字节，那存储 1 亿个关键词起码需要 5GB 的内存空间，而散列表因为要避免频繁冲突，不会选择太大的装载因子，所以消耗的内存空间就更多了。而我们的机器只有 1GB 的可用内存空间，所以我们无法一次性将所有的搜索关键词加入到内存中。\n哈希算法引入graph TD\n创建10个空文件 -->遍历10亿个关键词 --哈希算法-->哈希值 --与10取模-->搜索关键词应该被分到的文件编号 --> 散列表+堆分别求出TOP10 --> 合并并再求TOP10\n\n\n","slug":"DSA/C29 堆的应用","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"503921898d741f6fd2003fcfcab3b5d3","title":"DSA3 Complexity Analysis1","content":"复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？为什么需要复杂度分析？事后统计法的局限\n测试结果依赖于测试环境\ni9 vs i3\n\n\n测试结果受数据规模影响大\n小规模数据排序，出入排序&gt;快速排序\n\n\n\n大O复杂度表示法code1\nint cal(int n) &#123;\n  int sum = 0;\n  int i = 1;\n  for (; i &lt;= n; ++i) &#123;\n    sum = sum + i;\n  &#125;\n  return sum;\n&#125;\n\nTime = (2n+2) * unit\\_timecode2\n\nint cal(int n) &#123;\n  int sum = 0;\n  int i = 1;\n  int j = 1;\n  for (; i &lt;= n; ++i) &#123;\n    j = 1;\n    for (; j &lt;= n; ++j) &#123;\n      sum = sum +  i * j;\n    &#125;\n  &#125;\n&#125;\n\nTime = (2n^2+2n+3) * unit\\_time结论：\n\n所有代码的执行时间$T(n)$与每行代码的执行次数$f(n)$成正比\n\n即：\n\nT(n) = O(f(n)) \\\\\nT(n) -> 代码执行的时间 \\\\\nf(n) -> 每行代码执行的次数综合\n\n大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以也叫做渐进时间复杂度，简称时间复杂度\n时间复杂度分析\n只关注循环执行次数最多的一段代码\n加法法则：总复杂度等于量级最大的那段代码的复杂度\n乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n几种常见时间复杂度实例分析\n\n\n\n\n时间复杂度\n举例\n\n\n\n\n$O(1)$\n\n\n\n$O(logn) O(nlogn)$\n\n\n\n$O(m+n) O(m*n)$\n\n\n\n\n\n\n空间复杂度分析void print(int n) &#123;\n  int i = 0;\n  int[] a = new int[n];\n  for (i; i &lt;n; ++i) &#123;\n    a[i] = i * i;\n  &#125;\n\n  for (i = n-1; i >= 0; --i) &#123;\n    print out a[i]\n  &#125;\n&#125;\n","slug":"DSA/C3 复杂度分析(上)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"1ecdd1e00fb73a51c0511d1921f5b63c","title":"DSA28 Heap","content":"堆和堆排序：为什么说堆排序没有快速排序快？特殊的树：堆(Heap)\n堆排序\n\n原地\n时间复杂度为$O(nlogn)$\n实际软件开发中，快速排序的性能要比堆排序好\n\n如何理解堆？\n完全二叉树\n堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值\n大顶堆\n小顶堆\n\n\n\n\n如何实现一个堆？\n堆支持哪些操作\n如何存储一个堆\n\n用数组存储堆\n\n\n\n\n下标\n节点\n\n\n\n\ni\n关注节点\n\n\ni*2\n左子节点\n\n\ni*2+1\n右子节点\n\n\n$\\frac{i}{2}$\n父节点\n\n\n\n\n堆上的操作往堆中插入一个元素堆化：插入元素后调整堆，使其重新满足堆的特性\n\n从下往上\n从上往下\n\n\n\npublic class Heap &#123;\n  private int[] a; // 数组，从下标1开始存储数据\n  private int n;  // 堆可以存储的最大数据个数\n  private int count; // 堆中已经存储的数据个数\n\n  public Heap(int capacity) &#123;\n    a = new int[capacity + 1];\n    n = capacity;\n    count = 0;\n  &#125;\n\n  public void insert(int data) &#123;\n    if (count >= n) return; // 堆满了\n    ++count;\n    a[count] = data;\n    int i = count;\n    while (i/2 > 0 &amp;&amp; a[i] > a[i/2]) &#123; // 自下往上堆化\n      swap(a, i, i/2); // swap()函数作用：交换下标为i和i/2的两个元素\n      i = i/2;\n    &#125;\n  &#125;\n &#125;\n删除堆顶元素堆顶元素存储的就是堆中数据最大值或者最小值\n从下往上堆化，不满足完全二叉树的特性\n\n从上往下堆化方法不会出现数组空洞\n\npublic void removeMax() &#123;\n  if (count == 0) return -1; // 堆中没有数据\n  a[1] = a[count];\n  --count;\n  heapify(a, count, 1);\n&#125;\n\nprivate void heapify(int[] a, int n, int i) &#123; // 自上往下堆化\n  while (true) &#123;\n    int maxPos = i;\n    if (i*2 &lt;= n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2;\n    if (i*2+1 &lt;= n &amp;&amp; a[maxPos] &lt; a[i*2+1]) maxPos = i*2+1;\n    if (maxPos == i) break;\n    swap(a, i, maxPos);\n    i = maxPos;\n  &#125;\n&#125;\n如何基于堆实现排序？\n时间复杂度\n$O(nlogn)$\n\n\n大致步骤\n建堆\n排序\n\n\n\n建堆思路\n\n借助前面讲的，在堆中插入一个元素的思路\n假设起初堆中只包含一个数据\n调用插入操作，将下标从2到n的数据依次插入到堆中\n\n\n从后往前处理数组，从上往下堆化\n\n\n\nprivate static void buildHeap(int[] a, int n) &#123;\n  for (int i = n/2; i >= 1; --i) &#123;\n    heapify(a, n, i);\n  &#125;\n&#125;\n\nprivate static void heapify(int[] a, int n, int i) &#123;\n  while (true) &#123;\n    int maxPos = i;\n    if (i*2 &lt;= n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2;\n    if (i*2+1 &lt;= n &amp;&amp; a[maxPos] &lt; a[i*2+1]) maxPos = i*2+1;\n    if (maxPos == i) break;\n    swap(a, i, maxPos);\n    i = maxPos;\n  &#125;\n&#125;\n排序建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织\n\n数组中第一个元素就是堆顶，也就是最大的元素\n将其与最后一个元素交换，则最大元素放到下标为n的位置\n\n\n// n表示数据的个数，数组a中的数据从下标1到n的位置。\npublic static void sort(int[] a, int n) &#123;\n  buildHeap(a, n);\n  int k = n;\n  while (k > 1) &#123;\n    swap(a, 1, k);\n    --k;\n    heapify(a, k, 1);\n  &#125;\n&#125;\n解答开篇为什么快速排序比堆排序性能好？\n\n堆排序数据访问的方式没有快速排序友好\n快速排序：顺序访问\n堆排序：跳着访问，对CPU缓存不好\n\n\n对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序\n建堆过程可能会打乱数据原有先后顺序，使得有序度降低\n基于比较则只需要：比较+交换\n\n\n\n","slug":"DSA/C28 堆和堆排序","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"23870052c199bf06d18a4a93d8161ea8","title":"DSA30 Graph","content":"图的表示：如何存储微博、微信等社交网络中的好友关系？如何理解图？\n\n\n\n\n\n\n名词\n定义\n\n\n\n\n顶点vertex\n图中的元素\n\n\n边edge\n图中顶点与任意其他顶点建立的关系\n\n\n度degree\n跟顶点相连接的边的条数\n\n\n有向图\n边有方向的图\n\n\n无向图\n边无方向的图\n\n\n带权图\n每条边都有一个权重\n\n\n入度 in-degree\n有多少条边指向这个顶点\n\n\n出度 out-degree\n有多少条边以这个顶点为起点指向其他顶点\n\n\n\n\n邻接矩阵存储方法Adjacency Matrix\n\n\n简单、直观\n浪费存储空间\n无向图中对称，对于稀疏图Sparse Matrix更加浪费空间\n\n\n\n邻接表存储方法Adjacency List\n\n解答开篇\n微博：有向图\n操作\n判断用户A是否关注了用户B\n判断用户A是否是用户B的粉丝\n用户A关注用户B\n用户A取消关注用户B\n根据用户名称的首字母排序，分页获取用户的粉丝列表\n根据用户名称的首字母排序，分页获取用户的关注列表\n\n\n存储方法\n社交网络为稀疏图，故采用邻接表\n逆邻接表：知道用户的粉丝列表\n\n\n\n改进版本\n将邻接表中的链表改为支持快速查找的动态数据结构→跳表\n跳表插入、删除、查找都很高效\n数据有序，分页获取变得高效\n\n\n不同规模数据的解决方案\n小规模数据→内存中\n大规模数据\n哈希算法数据分片将邻接表存储在不同机器上\n外部存储\n\n\n\n\n\n\n\n","slug":"DSA/C30 图的表示","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"7e4c0f4e2f510c4e8317f9775d710031","title":"DSA31 DFS&BFS","content":"深度和广度优先搜索：如何找出社交网络中的三度好友关系？什么是搜索算法？\nDFS，Depth-First-Search，深度优先搜索\nBFS，Breadth-First-Search，广度优先搜索\n\n都是基于图结构的。在图中找出从一个顶点出发，到另一个顶点的路径\n图的代码实现public class Graph &#123; // 无向图\n  private int v; // 顶点的个数\n  private LinkedList&lt;Integer> adj[]; // 邻接表\n\n  public Graph(int v) &#123;\n    this.v = v;\n    adj = new LinkedList[v];\n    for (int i=0; i&lt;v; ++i) &#123;\n      adj[i] = new LinkedList&lt;>();\n    &#125;\n  &#125;\n\n  public void addEdge(int s, int t) &#123; // 无向图一条边存两次\n    adj[s].add(t);\n    adj[t].add(s);\n  &#125;\n&#125;\n广度优先搜索BFS\n地毯式层层推进的搜索策略\n先查找离起始顶点最近的，然后是次近的，依次往外搜索\n\n\n\n\npublic void bfs(int s, int t) &#123;\n  if (s == t) return;\n  boolean[] visited = new boolean[v];\n  visited[s]=true;\n  Queue&lt;Integer> queue = new LinkedList&lt;>();\n  queue.add(s);\n  int[] prev = new int[v];\n  for (int i = 0; i &lt; v; ++i) &#123;\n    prev[i] = -1;\n  &#125;\n  while (queue.size() != 0) &#123;\n    int w = queue.poll();\n   for (int i = 0; i &lt; adj[w].size(); ++i) &#123;\n      int q = adj[w].get(i);\n      if (!visited[q]) &#123;\n        prev[q] = w;\n        if (q == t) &#123;\n          print(prev, s, t);\n          return;\n        &#125;\n        visited[q] = true;\n        queue.add(q);\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\nprivate void print(int[] prev, int s, int t) &#123; // 递归打印s->t的路径\n  if (prev[t] != -1 &amp;&amp; t != s) &#123;\n    print(prev, s, prev[t]);\n  &#125;\n  System.out.print(t + \" \");\n&#125;\n\n\n\n\n变量\n含义\n操作\n\n\n\n\nvisited\n已经被访问的顶点，避免顶点被重复访问\n如果顶点q被访问，相应的visted[q] = true\n\n\nqueue\n队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点\n当我们访问到第k层顶点时候，需要把第k层顶点记录下来，稍后才能通过第k层顶点来找第k+1层顶点\n\n\nprev\n记录搜索路径\n反向存储，prev[w]存储的是顶点w从哪个前驱顶点遍历过来\n\n\n\n\n\n\n\n深度优先搜索DFS最直观的例子就是“走迷宫”\n\nboolean found = false; // 全局变量或者类成员变量\n\npublic void dfs(int s, int t) &#123;\n  found = false;\n  boolean[] visited = new boolean[v];\n  int[] prev = new int[v];\n  for (int i = 0; i &lt; v; ++i) &#123;\n    prev[i] = -1;\n  &#125;\n  recurDfs(s, t, visited, prev);\n  print(prev, s, t);\n&#125;\n\nprivate void recurDfs(int w, int t, boolean[] visited, int[] prev) &#123;\n  if (found == true) return;\n  visited[w] = true;\n  if (w == t) &#123;\n    found = true;\n    return;\n  &#125;\n  for (int i = 0; i &lt; adj[w].size(); ++i) &#123;\n    int q = adj[w].get(i);\n    if (!visited[q]) &#123;\n      prev[q] = w;\n      recurDfs(q, t, visited, prev);\n    &#125;\n  &#125;\n&#125;\n\n\n\n\n变量\n含义\n操作\n\n\n\n\nvisited\n已经被访问的顶点，避免顶点被重复访问\n如果顶点q被访问，相应的visted[q] = true\n\n\nqueue\n队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点\n当我们访问到第k层顶点时候，需要把第k层顶点记录下来，稍后才能通过第k层顶点来找第k+1层顶点\n\n\nprev\n记录搜索路径\n反向存储，prev[w]存储的是顶点w从哪个前驱顶点遍历过来\n\n\nfound\n当我们找到终止顶点t之后，就不再递归继续查找了\n\n\n\n\n","slug":"DSA/C31 深度和广度优先搜索","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"2786242c5ba6ce0832bbacd81c75d253","title":"DSA32 String Match1","content":"字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？字符串匹配\n算法\n\n单模式串匹配的算法：一个串跟一个串进行匹配\nBF算法\nRK算法\n\n\n多模式串匹配的算法：在一个串中同时查找多个串\nBM算法\nKMP算法\n\n\n\nBF算法Brute Force，暴力匹配算法，朴素匹配算法\n在字符串A中查找字符串B \n\n主串：A\n模式串：B\n\n一言以蔽之\n\n在主串中，检查起始位置分别是0、1、2、…、n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配的\n\n\n特点：\n\n理论上来讲，时间复杂度很高\n实际开发中比较常用\n实际开发中，大部分情况下，模式串和主串的长度都不会太长\n算法思想简单、代码实现简单\n\n\n\nRK算法Rabin-Karpsuanfa \n算法思路\n\ngraph TD\n主串中的n-m+1个子串 --哈希算法--> 哈希值 -->逐个与模式串的哈希值比较大小 --相等--> 匹配\n\n\n不过通过哈希算法计算子串哈希值时需要遍历子串中的每个字符，尽管模式串与子串比较效率提高了，但是算法整体效率并没有提高。有没有办法可以提高哈希算法计算子串哈希值的效率呢？\n解决方法：\n\n假设要匹配的字符串的字符集中只包含K个字符\n可以用一个K进制数来表示一个子串\nK进制数转化成十进制数，作为子串的哈希值\n\n\n其中，相邻两个子串的哈希值计算公式有一定关系\n\n\n即：\n\nh[i] = (h[i-1]-26^{m-1}\\times s[i-1] - 'a')\\times 26 +26^0\\times (s[i+m-1]-'a')小结\nBF\n拿模式串与主串中是所有子串匹配，看是否有能匹配的子串\n\n\nRK\n借助哈希算法对BF算法进行改造\n对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较\n\n\n\n","slug":"DSA/C32 字符串匹配基础(上)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"0ec81c6d3aa8372bc4bd0a74846f2430","title":"DSA33 String Match2","content":"字符串匹配基础（中）：如何实现文本编辑器中的查找功能？文本编辑器中的查找替换功能\n\nBM算法，Boyer-Moore\nKMP算法\n\nBM算法核心思想\n\n当模式串和主串某个字符不匹配的时候，能够跳过一些可定不会匹配的情况，将模式串往后多滑动几位\n算法原理分析坏字符规则\n\n\n\n\ngraph TD\n发生不匹配时 --> 坏字符对应的模式串中字符下标记做si --> 坏字符在模式串中是否存在 --yes-->把这个坏字符在模式串中的下标记做xi  -->模式串后移位数为si-xi\n坏字符在模式串中是否存在 --no-->xi记做-1 -->模式串后移位数为si-xi\n\n\n好后缀规则\n这个时候如何滑动？\n\n坏字符规则？\n好后缀规则？\n\ngraph TD\n将已经匹配好的bc叫做好后缀记做u --> 拿它在模式串中查找 \n--找到另一个跟u相匹配的子串u*-->将模式串滑动到子串u*与主串中u对齐的位置\n\n 拿它在模式串中查找 \n--未找到另一个跟u相匹配的子串u*-->考虑好后缀的后缀子串是否存在跟模式串的前缀子串匹配的 --> 从好后缀的后缀子串中找一个最长的并且能跟模式串的前缀子串匹配的\n\n\n\n\n\n\n\n如何选择用好后缀规则还是坏字符规则\n分别计算好后缀和坏字符往后滑动的位数\n取两个数中最大的作为模式串往后滑动的位数\n\n算法代码实现坏字符规则的实现\ngraph TD\n遇到坏字符 --> 计算往后移动的位数si-xi -->xi如何求得 \n--坏方法--> 坏字符在模式串中顺序遍历查找 --> 低效\n\nxi如何求得 \n--好方法--> 模式串中每个字符及其下标存到散列表中 --> 快速找到坏字符在模式串的位置下标\n\n\n\n\n\n\n数组属性\n含义\n\n\n\n\n数组下标\n字符的ASCII码\n\n\n数组中的元素\n存储这个字符在模式串中出现的位置\n\n\n\n\nprivate static final int SIZE = 256; // 全局变量或成员变量\nprivate void generateBC(char[] b, int m, int[] bc) &#123;\n  for (int i = 0; i &lt; SIZE; ++i) &#123;\n    bc[i] = -1; // 初始化bc\n  &#125;\n  for (int i = 0; i &lt; m; ++i) &#123;\n    int ascii = (int)b[i]; // 计算b[i]的ASCII值\n    bc[ascii] = i;\n  &#125;\n&#125;\nBM算法的大框架（先不考虑好后缀，仅考虑坏字符，且不考虑si-xi计算得到的移动为数可能会出现负数的情况）\npublic int bm(char[] a, int n, char[] b, int m) &#123;\n  int[] bc = new int[SIZE]; // 记录模式串中每个字符最后出现的位置\n  generateBC(b, m, bc); // 构建坏字符哈希表\n  int i = 0; // i表示主串与模式串对齐的第一个字符\n  while (i &lt;= n - m) &#123;\n    int j;\n    for (j = m - 1; j >= 0; --j) &#123; // 模式串从后往前匹配\n      if (a[i+j] != b[j]) break; // 坏字符对应模式串中的下标是j\n    &#125;\n    if (j &lt; 0) &#123;\n      return i; // 匹配成功，返回主串与模式串第一个匹配的字符的位置\n    &#125;\n    // 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位\n    i = i + (j - bc[(int)a[i+j]]); \n  &#125;\n  return -1;\n&#125;\n填充好后缀规则\n\n\n\n项目\n具体\n\n\n\n\n好后缀处理规则核心内容\n模式串中，查找跟好后缀匹配的另一个子串好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串\n\n\n为了不至于低效如何做？\n好后缀本身也是模式串本身的后缀子串在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置\n\n\n如何表示模式串中不同的后缀子串？\n记录长度如图1所示\n\n\nsuffix数组\n下标k：表示后缀子串的长度下标对应的数组值：在模式串中跟好后缀{u}相匹配的子串{u*}的起始下标值如图2所示\n\n\nprefix数组\n记录模式串的后缀子串是否能匹配模式串的前缀子串如图3所示\n\n\n如何计算并填充suffix和prefix两个数组\n下标从0到i的子串 + 整个模式串 → 公共后缀子串公共后缀子串长度 = ksuffix[k] = j如果j = 0→ prefix[k] = true;\n\n\n在模式串跟主串匹配中遇到不能匹配的字符，如何根据好后缀规则，计算模式串往后移动的位数\n如图所示\n\n\n\n\n\n\n\n\n&#x2F;&#x2F; b表示模式串，m表示长度，suffix，prefix数组事先申请好了\nprivate void generateGS(char[] b, int m, int[] suffix, boolean[] prefix) &#123;\n  for (int i &#x3D; 0; i &lt; m; ++i) &#123; &#x2F;&#x2F; 初始化\n    suffix[i] &#x3D; -1;\n    prefix[i] &#x3D; false;\n  &#125;\n  for (int i &#x3D; 0; i &lt; m - 1; ++i) &#123; &#x2F;&#x2F; b[0, i]\n    int j &#x3D; i;\n    int k &#x3D; 0; &#x2F;&#x2F; 公共后缀子串长度\n    while (j &gt;&#x3D; 0 &amp;&amp; b[j] &#x3D;&#x3D; b[m-1-k]) &#123; &#x2F;&#x2F; 与b[0, m-1]求公共后缀子串\n      --j;\n      ++k;\n      suffix[k] &#x3D; j+1; &#x2F;&#x2F;j+1表示公共后缀子串在b[0, i]中的起始下标\n    &#125;\n    if (j &#x3D;&#x3D; -1) prefix[k] &#x3D; true; &#x2F;&#x2F;如果公共后缀子串也是模式串的前缀子串\n  &#125;\n&#125;\n\n\n\n完整代码// a,b表示主串和模式串；n，m表示主串和模式串的长度。\npublic int bm(char[] a, int n, char[] b, int m) &#123;\n  int[] bc = new int[SIZE]; // 记录模式串中每个字符最后出现的位置\n  generateBC(b, m, bc); // 构建坏字符哈希表\n  int[] suffix = new int[m];\n  boolean[] prefix = new boolean[m];\n  generateGS(b, m, suffix, prefix);\n  int i = 0; // j表示主串与模式串匹配的第一个字符\n  while (i &lt;= n - m) &#123;\n    int j;\n    for (j = m - 1; j >= 0; --j) &#123; // 模式串从后往前匹配\n      if (a[i+j] != b[j]) break; // 坏字符对应模式串中的下标是j\n    &#125;\n    if (j &lt; 0) &#123;\n      return i; // 匹配成功，返回主串与模式串第一个匹配的字符的位置\n    &#125;\n    int x = j - bc[(int)a[i+j]];\n    int y = 0;\n    if (j &lt; m-1) &#123; // 如果有好后缀的话\n      y = moveByGS(j, m, suffix, prefix);\n    &#125;\n    i = i + Math.max(x, y);\n  &#125;\n  return -1;\n&#125;\n\n// j表示坏字符对应的模式串中的字符下标; m表示模式串长度\nprivate int moveByGS(int j, int m, int[] suffix, boolean[] prefix) &#123;\n  int k = m - 1 - j; // 好后缀长度\n  if (suffix[k] != -1) return j - suffix[k] +1;\n  for (int r = j+2; r &lt;= m-1; ++r) &#123;\n    if (prefix[m-r] == true) &#123;\n      return r;\n    &#125;\n  &#125;\n  return m;\n&#125;\n小结核心思想\n\ngraph TD\n利用模式串本身特点 --> 模式串中某个字符与主串不能匹配时候 --> 将模式串往后多滑动几位 --> 减少不必要的字符比较 --> 提高匹配效率\n\n算法构建规则\n\n坏字符规则\n好后缀规则\n\n","slug":"DSA/C33 字符串匹配基础(中)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"6ac917baf75da522e92f8103dc9fe5ea","title":"DSA35 Trie Tree","content":"Trie树：如何实现搜索引擎的搜索关键词提示功能？搜索引擎的搜索关键词提示功能\n\n什么是Trie树？\n字典树，树形结构\n专门处理字符串匹配的数据结构\n解决在一组字符串集合中快速查找某个字符串的问题\n\n先看看Trie树长什么样\n本质：利用字符串之间公共前缀，将重复前缀合并在一起\n\n6个字符串分别为：how hi her hello so see\n希望在里面多次查找某个字符串是否存在\n每次查找都要匹配导致低效\n故对6个字符串预处理，组织成Trie树结构，之后每次查找都是在Trie树中进行匹配查找\n\n\n\n\n如何实现一棵Trie树？两个操作\n\n将字符串集合构造成Trie树\n在Trie树中查询一个字符串\n\n如何存储\n\n多叉树\n借助散列表思想，通过一个下标与字符一一映射的数组来存储子节点的指针\n\n\n\n\n假设字符串只有a到z这26个小写字母，数组中下标为0的位置存储指向子节点a的指针\n如果某个字符子节点不存在，就在对应的下标位置存储null\n字符的ASCII码减去“a”的ASCII码，迅速找到匹配的子节点的指针\npublic class Trie &#123;\n  private TrieNode root &#x3D; new TrieNode(&#39;&#x2F;&#39;); &#x2F;&#x2F; 存储无意义字符\n\n  &#x2F;&#x2F; 往Trie树中插入一个字符串\n  public void insert(char[] text) &#123;\n    TrieNode p &#x3D; root;\n    for (int i &#x3D; 0; i &lt; text.length; ++i) &#123;\n      int index &#x3D; text[i] - &#39;a&#39;;\n      if (p.children[index] &#x3D;&#x3D; null) &#123;\n        TrieNode newNode &#x3D; new TrieNode(text[i]);\n        p.children[index] &#x3D; newNode;\n      &#125;\n      p &#x3D; p.children[index];\n    &#125;\n    p.isEndingChar &#x3D; true;\n  &#125;\n\n  &#x2F;&#x2F; 在Trie树中查找一个字符串\n  public boolean find(char[] pattern) &#123;\n    TrieNode p &#x3D; root;\n    for (int i &#x3D; 0; i &lt; pattern.length; ++i) &#123;\n      int index &#x3D; pattern[i] - &#39;a&#39;;\n      if (p.children[index] &#x3D;&#x3D; null) &#123;\n        return false; &#x2F;&#x2F; 不存在pattern\n      &#125;\n      p &#x3D; p.children[index];\n    &#125;\n    if (p.isEndingChar &#x3D;&#x3D; false) return false; &#x2F;&#x2F; 不能完全匹配，只是前缀\n    else return true; &#x2F;&#x2F; 找到pattern\n  &#125;\n\n  public class TrieNode &#123;\n    public char data;\n    public TrieNode[] children &#x3D; new TrieNode[26];\n    public boolean isEndingChar &#x3D; false;\n    public TrieNode(char data) &#123;\n      this.data &#x3D; data;\n    &#125;\n  &#125;\n&#125;\nTrie树真的很耗内存吗？我们可以稍微牺牲一点查询的效率，将每个节点中的数组换成其他数据结构，来存储一个节点的子节点指针\nTrie树与散列表、红黑树的比较Trie树在刚刚的场景中，对要处理的字符串有极其严苛的要求\n\n字符串中包含的字符集不能太大→存储空间浪费很多\n要求字符串前缀重合比较多→否则空间消耗大很多\n需要从零开始实现→简单问题复杂化\n通过指针穿起来的数据块不连续→缓存不友好，性能打折扣\n\n解答开篇\n","slug":"DSA/C35 Trie树","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"9ae95ab2c9e432ffcdddad19b3709cb8","title":"DSA34 String Match3","content":"字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法？所有字符串匹配算法中，最知名的一种非KMP算法莫属\nKMP算法基本原理Knuth-Morris-Pratt\n核心思想\n\n模式串与主串匹配过程中，当遇到不可匹配的字符时，希望找到一些规律，将模式串向后多滑动几位，跳过那些肯定不会匹配的情况\n\n\n\n\n\nKMP算法的框架\n&#x2F;&#x2F; a, b分别是主串和模式串；n, m分别是主串和模式串的长度。\npublic static int kmp(char[] a, int n, char[] b, int m) &#123;\n  int[] next &#x3D; getNexts(b, m);\n  int j &#x3D; 0;\n  for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n    while (j &gt; 0 &amp;&amp; a[i] !&#x3D; b[j]) &#123; &#x2F;&#x2F; 一直找到a[i]和b[j]\n      j &#x3D; next[j - 1] + 1;\n    &#125;\n    if (a[i] &#x3D;&#x3D; b[j]) &#123;\n      ++j;\n    &#125;\n    if (j &#x3D;&#x3D; m) &#123; &#x2F;&#x2F; 找到匹配模式串的了\n      return i - m + 1;\n    &#125;\n  &#125;\n  return -1;\n&#125;\n失效函数的计算方法next数组如何计算出来\n笨办法：依次找出\n\n高效方法：\n\n\n\n整个框架代码&#x2F;&#x2F; b表示模式串，m表示模式串的长度\nprivate static int[] getNexts(char[] b, int m) &#123;\n  int[] next &#x3D; new int[m];\n  next[0] &#x3D; -1;\n  int k &#x3D; -1;\n  for (int i &#x3D; 1; i &lt; m; ++i) &#123;\n    while (k !&#x3D; -1 &amp;&amp; b[k + 1] !&#x3D; b[i]) &#123;\n      k &#x3D; next[k];\n    &#125;\n    if (b[k + 1] &#x3D;&#x3D; b[i]) &#123;\n      ++k;\n    &#125;\n    next[i] &#x3D; k;\n  &#125;\n  return next;\n&#125;\n","slug":"DSA/C34 字符串匹配基础(下)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"06d10bcf0dacb0e855883f8036c8872c","title":"DSA36 AC自动机","content":"AC自动机：如何用多模式串匹配实现敏感词过滤功能？引入敏感词过滤功能是如何实现的？\n\n字符串匹配算法\n通过维护一个敏感词的字典，当用户输入一段文字内容之后，通过字符串匹配算法查找用户输入的文字，包含敏感词则用“*”替换掉\n\n\n\n访问量巨大的网站来说，如何实现一个高性能的敏感词过滤系统？\n\n多模式串匹配算法\n问题处理很高效\n\n\n\n如何用Trie树实现敏感词过滤功能？\n\n对敏感词字典进行预处理，构建成Trie树结构\n敏感词字典动态更新，如删除、添加敏感词，只需要动态更新一下Trie树即可\n\n借鉴单模式串的优化改进方法，能否对多模式串Trie树进行改进，进一步提高Trie树的效率？\n\nAC自动机算法\n\n经典的多模式串匹配算法：AC自动机Aho-Corasicksuanfa \nAC自动机实际上就是在Trie树之上，加了类似KMP的next数组，只不过此处的next数组构建在树上\npublic class AcNode &#123;\n  public char data; \n  public AcNode[] children = new AcNode[26]; // 字符集只包含a~z这26个字符\n  public boolean isEndingChar = false; // 结尾字符为true\n  public int length = -1; // 当isEndingChar=true时，记录模式串长度\n  public AcNode fail; // 失败指针\n  public AcNode(char data) &#123;\n    this.data = data;\n  &#125;\n&#125;\n所以AC自动机的构建包含两个操作\n\n将多个模式串构建成Trie树 （上一节已经解决）\n在Trie树上构建失败指针（本章解决）\n\n\n构件失败指针\npublic void buildFailurePointer() &#123;\n  Queue&lt;AcNode&gt; queue &#x3D; new LinkedList&lt;&gt;();\n  root.fail &#x3D; null;\n  queue.add(root);\n  while (!queue.isEmpty()) &#123;\n    AcNode p &#x3D; queue.remove();\n    for (int i &#x3D; 0; i &lt; 26; ++i) &#123;\n      AcNode pc &#x3D; p.children[i];\n      if (pc &#x3D;&#x3D; null) continue;\n      if (p &#x3D;&#x3D; root) &#123;\n        pc.fail &#x3D; root;\n      &#125; else &#123;\n        AcNode q &#x3D; p.fail;\n        while (q !&#x3D; null) &#123;\n          AcNode qc &#x3D; q.children[pc.data - &#39;a&#39;];\n          if (qc !&#x3D; null) &#123;\n            pc.fail &#x3D; qc;\n            break;\n          &#125;\n          q &#x3D; q.fail;\n        &#125;\n        if (q &#x3D;&#x3D; null) &#123;\n          pc.fail &#x3D; root;\n        &#125;\n      &#125;\n      queue.add(pc);\n    &#125;\n  &#125;\n&#125;\n构建完成的AC自动机\n\n如何在AC自动机上匹配主串？\npublic void match(char[] text) &#123; &#x2F;&#x2F; text是主串\n  int n &#x3D; text.length;\n  AcNode p &#x3D; root;\n  for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n    int idx &#x3D; text[i] - &#39;a&#39;;\n    while (p.children[idx] &#x3D;&#x3D; null &amp;&amp; p !&#x3D; root) &#123;\n      p &#x3D; p.fail; &#x2F;&#x2F; 失败指针发挥作用的地方\n    &#125;\n    p &#x3D; p.children[idx];\n    if (p &#x3D;&#x3D; null) p &#x3D; root; &#x2F;&#x2F; 如果没有匹配的，从root开始重新匹配\n    AcNode tmp &#x3D; p;\n    while (tmp !&#x3D; root) &#123; &#x2F;&#x2F; 打印出可以匹配的模式串\n      if (tmp.isEndingChar &#x3D;&#x3D; true) &#123;\n        int pos &#x3D; i-tmp.length+1;\n        System.out.println(&quot;匹配起始下标&quot; + pos + &quot;; 长度&quot; + tmp.length);\n      &#125;\n      tmp &#x3D; tmp.fail;\n    &#125;\n  &#125;\n&#125;\n","slug":"DSA/C36 AC自动机","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"a9e32e2621fbdc03b2a42efbcf0ce8e5","title":"DSA37 Greedy Algorithm","content":"贪心算法：如何用贪心算法实现Huffman压缩编码？几个基本的算法思想\n\n贪心算法\nHuffman Coding\nPrim和Kruskal最小生成树算法\nDijkstra单源最短路径\n\n\n分治算法\n回溯算法\n动态规划\n\n本章如何利用贪心算法实现对数据压缩编码，有效节省数据存储空间\n如何理解“贪心算法”例子1假设可以容纳100kg物品的背包，为了让背包中所装物品总价值最大，如何选择装哪些豆子？每种装多少？\n\n\n单价由高到低\n\n贪心算法的步骤\n看到这类问题，联想到贪心算法\n一组数据，定义了限制值和期望值，希望从中选出几个数据，满足限制值情况下，期望值最大\n\n\n尝试看贪心算法能否解决\n每次选择当前情况下，在对限制值同等贡献量情况下，对期望值贡献最大的数据\n\n\n举几个例子看贪心算法产生的结果是否最优\n\n例子2\n\n贪心算法：S-&gt;A-&gt;E-&gt;T\n实际最优：S-&gt;B-&gt;D-&gt;T\n\n原因\n\n前面的选择会影响后面的选择\n\n实战分析\n分糖果\n钱币找零\n区间覆盖\n任务调度、教师排课\n\n\n\n\n解答开篇霍夫曼编码\n\n考察文本中有多少个不同字符\n考察每个字符出现的频率\n\n即：出现频率较高的字符，稍短编码；出现频率较少字符，稍长编码\n为了避免解压缩过程中的歧义，编码要求个字符编码之间，不会出现某个编码是另一个编码前缀的情况\n\n如何根据字符出现频率的不同，给不同的字符进行不同长度的编码呢？\n\n后给每一条边上加一个权值，指向左子节点的边标记为0，指向右子节点的边标记为1，\n则从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码\n\n","slug":"DSA/C37 贪心算法","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"28170d54ceec31fbbfec4bc7706417d1","title":"DSA38 分治算法","content":"分治算法：谈一谈大规模计算框架MapReduce中的分治思想引入Google大数据处理三驾马车\n\nMapReduce\nGFS\nBigtable\n\n如何理解分治算法核心：分而治之\n\n将原问题划分成n个规模较小，并且结构与原问题相似的子问题\n递归地解决这些子问题\n然后合并其结果\n\n分治算法的递归实现，每一层递归都会涉及三个操作\n\n分解：将原问题分解成一系列子问题\n解决：递归地求解各个子问题，若子问题足够小，则直接求解\n合并：将子问题的结果合并成原问题\n\n分治算法能解决的问题一般需要满足几个条件\n\n原问题与分解成的小问题具有相同的模式\n原问题分解的子问题可以独立求解，子问题之间没有相关性\n具有分解终止条件，也即问题足够小时，可以直接求解\n可以将子问题合并成原问题，合并操作复杂度不能太高，否则起不到减小算法总体复杂度的效果\n\n分治算法应用举例分析如何编程求出一组数据的有序对个数或者逆序对个数？分治算法\n\n将数组分成前后两半A1和A2\n\n分别计算A1和A2的逆序对个数K1和K2\n\n计算A1与A2之间逆序对个数K3\n\n\n\nprivate int num = 0; // 全局变量或者成员变量\n\npublic int count(int[] a, int n) &#123;\n  num = 0;\n  mergeSortCounting(a, 0, n-1);\n  return num;\n&#125;\n\nprivate void mergeSortCounting(int[] a, int p, int r) &#123;\n  if (p &gt;= r) return;\n  int q = (p+r)/2;\n  mergeSortCounting(a, p, q);\n  mergeSortCounting(a, q+1, r);\n  merge(a, p, q, r);\n&#125;\n\nprivate void merge(int[] a, int p, int q, int r) &#123;\n  int i = p, j = q+1, k = 0;\n  int[] tmp = new int[r-p+1];\n  while (i&lt;=q &amp;&amp; j&lt;=r) &#123;\n    if (a[i] &lt;= a[j]) &#123;\n      tmp[k++] = a[i++];\n    &#125; else &#123;\n      num += (q-i+1); // 统计p-q之间，比a[j]大的元素个数\n      tmp[k++] = a[j++];\n    &#125;\n  &#125;\n  while (i &lt;= q) &#123; // 处理剩下的\n    tmp[k++] = a[i++];\n  &#125;\n  while (j &lt;= r) &#123; // 处理剩下的\n    tmp[k++] = a[j++];\n  &#125;\n  for (i = 0; i &lt;= r-p; ++i) &#123; // 从tmp拷贝回a\n    a[p+i] = tmp[i];\n  &#125;\n&#125;\n\n\n\n\n逆序对个数 = K1 + K2 + K3\n\n\n分治思想在海量数据处理中的应用\n海量数据集合根据某种方法划分为几个小的数据集合\n每个小的数据集合单独加载到内存解决\n将小数据集合合并成大数据集合\n\n","slug":"DSA/C38 分治算法","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"cab4c9495dd444030efce39574aea74e","title":"DSA40 回溯算法","content":"回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想引入回溯算法的应用\n\n深度优先搜索\n经典数学问题\n数独\n八皇后\n0-1背包\n图的着色\n旅行商问题\n全排列\n\n\n\n如何理解回溯算法笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解。\n八皇后问题\n\n8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子\n期望找到所有满足这种要求的放棋子方式\n\n\nint[] result &#x3D; new int[8];&#x2F;&#x2F;全局或成员变量,下标表示行,值表示queen存储在哪一列\npublic void cal8queens(int row) &#123; &#x2F;&#x2F; 调用方式：cal8queens(0);\n  if (row &#x3D;&#x3D; 8) &#123; &#x2F;&#x2F; 8个棋子都放置好了，打印结果\n    printQueens(result);\n    return; &#x2F;&#x2F; 8行棋子都放好了，已经没法再往下递归了，所以就return\n  &#125;\n  for (int column &#x3D; 0; column &lt; 8; ++column) &#123; &#x2F;&#x2F; 每一行都有8中放法\n    if (isOk(row, column)) &#123; &#x2F;&#x2F; 有些放法不满足要求\n      result[row] &#x3D; column; &#x2F;&#x2F; 第row行的棋子放到了column列\n      cal8queens(row+1); &#x2F;&#x2F; 考察下一行\n    &#125;\n  &#125;\n&#125;\n\nprivate boolean isOk(int row, int column) &#123;&#x2F;&#x2F;判断row行column列放置是否合适\n  int leftup &#x3D; column - 1, rightup &#x3D; column + 1;\n  for (int i &#x3D; row-1; i &gt;&#x3D; 0; --i) &#123; &#x2F;&#x2F; 逐行往上考察每一行\n    if (result[i] &#x3D;&#x3D; column) return false; &#x2F;&#x2F; 第i行的column列有棋子吗？\n    if (leftup &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 考察左上对角线：第i行leftup列有棋子吗？\n      if (result[i] &#x3D;&#x3D; leftup) return false;\n    &#125;\n    if (rightup &lt; 8) &#123; &#x2F;&#x2F; 考察右上对角线：第i行rightup列有棋子吗？\n      if (result[i] &#x3D;&#x3D; rightup) return false;\n    &#125;\n    --leftup; ++rightup;\n  &#125;\n  return true;\n&#125;\n\nprivate void printQueens(int[] result) &#123; &#x2F;&#x2F; 打印出一个二维矩阵\n  for (int row &#x3D; 0; row &lt; 8; ++row) &#123;\n    for (int column &#x3D; 0; column &lt; 8; ++column) &#123;\n      if (result[row] &#x3D;&#x3D; column) System.out.print(&quot;Q &quot;);\n      else System.out.print(&quot;* &quot;);\n    &#125;\n    System.out.println();\n  &#125;\n  System.out.println();\n&#125;\n两个回溯算法的经典应用0-1背包我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？\npublic int maxW &#x3D; Integer.MIN_VALUE; &#x2F;&#x2F;存储背包中物品总重量的最大值\n&#x2F;&#x2F; cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；\n&#x2F;&#x2F; w背包重量；items表示每个物品的重量；n表示物品个数\n&#x2F;&#x2F; 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：\n&#x2F;&#x2F; f(0, 0, a, 10, 100)\npublic void f(int i, int cw, int[] items, int n, int w) &#123;\n  if (cw &#x3D;&#x3D; w || i &#x3D;&#x3D; n) &#123; &#x2F;&#x2F; cw&#x3D;&#x3D;w表示装满了;i&#x3D;&#x3D;n表示已经考察完所有的物品\n    if (cw &gt; maxW) maxW &#x3D; cw;\n    return;\n  &#125;\n  f(i+1, cw, items, n, w);\n  if (cw + items[i] &lt;&#x3D; w) &#123;&#x2F;&#x2F; 已经超过可以背包承受的重量的时候，就不要再装了\n    f(i+1,cw + items[i], items, n, w);\n  &#125;\n&#125;\n正则表达式https://baike.baidu.com/item/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1700215\nhttps://www.bilibili.com/video/BV1da4y1p7iZ?from=search&amp;seid=1413946293500492218\n前提\n\n*匹配任意多个任意字符\n？匹配零个或者一个任意字符\n\n过程\n\ngraph TD\n依次考察正则表达式中的每个字符 --> 是非通配符时直接跟文本的字符进行匹配 \n--相同-->继续向下处理\n是非通配符时直接跟文本的字符进行匹配 \n--不同-->回溯\n\n 依次考察正则表达式中的每个字符 -->  遇到特殊字符时 -->*有多种匹配方案.匹配任意个文本串中字符\n --> 随意选择一种匹配方案 -->然后继续考察剩下的字符 --> 中途发现无法继续匹配下去了 \n -->*有多种匹配方案.匹配任意个文本串中字符\n\npublic class Pattern &#123;\n  private boolean matched &#x3D; false;\n  private char[] pattern; &#x2F;&#x2F; 正则表达式\n  private int plen; &#x2F;&#x2F; 正则表达式长度\n\n  public Pattern(char[] pattern, int plen) &#123;\n    this.pattern &#x3D; pattern;\n    this.plen &#x3D; plen;\n  &#125;\n\n  public boolean match(char[] text, int tlen) &#123; &#x2F;&#x2F; 文本串及长度\n    matched &#x3D; false;\n    rmatch(0, 0, text, tlen);\n    return matched;\n  &#125;\n\n  private void rmatch(int ti, int pj, char[] text, int tlen) &#123;\n    if (matched) return; &#x2F;&#x2F; 如果已经匹配了，就不要继续递归了\n    if (pj &#x3D;&#x3D; plen) &#123; &#x2F;&#x2F; 正则表达式到结尾了\n      if (ti &#x3D;&#x3D; tlen) matched &#x3D; true; &#x2F;&#x2F; 文本串也到结尾了\n      return;\n    &#125;\n    if (pattern[pj] &#x3D;&#x3D; &#39;*&#39;) &#123; &#x2F;&#x2F; *匹配任意个字符\n      for (int k &#x3D; 0; k &lt;&#x3D; tlen-ti; ++k) &#123;\n        rmatch(ti+k, pj+1, text, tlen);\n      &#125;\n    &#125; else if (pattern[pj] &#x3D;&#x3D; &#39;?&#39;) &#123; &#x2F;&#x2F; ?匹配0个或者1个字符\n      rmatch(ti, pj+1, text, tlen);\n      rmatch(ti+1, pj+1, text, tlen);\n    &#125; else if (ti &lt; tlen &amp;&amp; pattern[pj] &#x3D;&#x3D; text[ti]) &#123; &#x2F;&#x2F; 纯字符匹配才行\n      rmatch(ti+1, pj+1, text, tlen);\n    &#125;\n  &#125;\n&#125;\n ","slug":"DSA/C39 回溯算法","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"fc19127153caeb9baa595a1d01d3f0d7","title":"DSA4 Complexity Analysis2","content":"复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度// n表示数组array的长度\nint find(int[] array, int n, int x) &#123;\n  int i = 0;\n  int pos = -1;\n  for (; i &lt; n; ++i) &#123;\n    if (array[i] == x) &#123;\n       pos = i;\n       break;\n    &#125;\n  &#125;\n  return pos;\n&#125;\n\n最好情况时间复杂度：查找的变量x出现在第一个元素，$O(1)$\n\n最坏情况时间复杂度：查找的变量x不存在，$O(n)$\n\n平均时间复杂度：查找的变量x有n+1种情况\n\n在数组的0~(n-1)位置中\n\n不在数组中\n\n则：\n\n\\frac{1+2+3+...+n+n}{n+1} = \\frac{n(n+3)}{2(n+1)}\n\n1\\times \\frac{1}{2n}+2\\times \\frac{1}{2n}+\\cdots+n\\times \\frac{1}{2n}+n\\times \\frac{1}{2} = \\frac{3n+1}{4}\n\n\n\n均摊时间复杂度\n// array表示一个长度为n的数组\n // 代码中的array.length就等于n\n int[] array = new int[n];\n int count = 0;\n \n void insert(int val) &#123;\n    if (count == array.length) &#123;\n       int sum = 0;\n       for (int i = 0; i &lt; array.length; ++i) &#123;\n          sum = sum + array[i];\n       &#125;\n       array[0] = sum;\n       count = 1;\n    &#125;\n\n    array[count] = val;\n    ++count;\n &#125;\n","slug":"DSA/C4 复杂度分析(下)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"7315897fe4af98b9a72088541e465f37","title":"DSA40 初识动态规划","content":"初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？引入 双十一满200减50，选出来的商品价格总和最大程度接近满减条件，极大限度薅羊毛\n动态规划学习路线动态规划比较适合用来求解最优问题，比如求最大值、最小值等\n\n初识动态规划\n两个经典动态规划问题模型\n为什么动态规划\n动态规划解题方法如何演化\n\n\n动态规划理论\n动态规划适合解决的问题的特征\n动态规划解题思路\n\n\n应用动态规划理论知识\n实战解决三个经典动态规划问题\n\n\n\n0-1背包问题","slug":"DSA/C40 初识动态规划","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"be65ef045a392dbdd6233f994cc17ed3","title":"DSA5 Array","content":"数组：为什么很多编程语言中数组都从0开始编号？如何实现随机访问？\n\n\n\n\n\n\n\n\n数组(array)\n一种线性表数据结构。用一组连续的内存空间，来存储一组具有相同类型的数据\n线性表与非线性表\n线性表\n数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向\n\n\n\n非线性表\n数据之间并不是简单的前后关系\n\n\n\n\n连续的内存空间和相同类型的数据以上两个限制构成了数组的“杀手锏”特性：随机访问\n\n优点：访问方便\n缺点：删除、插入操作，为保证连续性，需要做大量的数据搬移工作\n\n如何实现根据下表随机访问数组元素？\n\na[i]\\_{address} = base\\_address + i * data\\_type\\_size\n数组支持随机访问\n根据下表随机访问的时间复杂度为$O(1)$\n\n低效的“插入”和“删除”\n\n问题：如果要将某个数据插入到第k个位置\n可能的困难：为了避免大规模的数据搬移\n解决方案：直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入到第k个位置\n\n\n\n问题：删除a、b、c三个元素\n可能的困难：避免defgh几个数据会被搬移三次\n解决方案：\n先记录下已经删除的数据，每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除\n数组没有更多空间存储数据时，再触发执行一次真正的删除操作\n\n\n\n数组的访问越界问题int main(int argc, char* argv[])&#123;\n    int i = 0;\n    int arr[3] = &#123;0&#125;;\n    for(; i&lt;=3; i++)&#123;\n        arr[i] = 0;\n        printf(\"hello world\\n\");\n    &#125;\n    return 0;\n&#125;\n\n问题：数组大小为3，仅有a[0]、a[1]、a[2]，当i=3时，访问越界\n\n\n\n\n\n\n\n\n\n\n在C语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的\n数组越界在C语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理\n只要数组通过偏移计算得到的内存地址是可用的，程序就可能不会报任何错误\nNote：\n某些计算机病毒利用代码中的数组越界可以访问非法地址的漏洞来供给系统\n容器能否完全替代数组？\nArrayList优势\n将很多数组操作的细节封装起来\n支持动态扩容\n\n\narray更合适的情况\nJava ArrayList无法存储基本类型\n数据大小事先已知且对数据的操作非常简单\n多维数组时，数组往往更加直观\nObject[][] array\nArrayList\\&gt; array\n\n\n\n\n总结\n业务开发 —&gt; 容器\n省时省力\n损耗一丢丢性能，但是不影响系统整体性能\n\n\n底层开发 —&gt; 数组\n例如开发网络框架\n性能优化做到极致\n\n\n\n\n\n回答“为什么从0开始编号”答：\n\n从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移(offset)”\n历史原因(C语言设计者用0开始计数数组下标)\n\n\n从0开始\n\n\na[i]\\_{address} = base\\_address + i * data\\_type\\_size\n\n\n从1开始\n\n\na[i]\\_{address} = base\\_address + (i-1) * data\\_type\\_size\n\n\n\n每次随机访问数组元素都多了一次减法运算\n","slug":"DSA/C5 数组","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"85ae2c10dc6f2d0c388a295260d12e29","title":"DSA6 Linked List1","content":"链表（上）：如何实现LRU缓存淘汰算法？缓存淘汰概述缓存\n\n提高数据读取性能的技术\n大小有限，缓存被用满时，数据清理和保留 —&gt; 缓存淘汰策略\nFIFO，先进先出策略\nLFU，最少使用策略\nLRU，最近最少使用策略\n\n\n\n链表结构与数组的对比\n数组\n连续的内存空间存储，对内存的要求比较高\n\n\n链表\n通过“指针”将一组零散的内存块串联起来使用\n\n\n\n\n几种结构\n单链表\n\n\n\n双链表\n\n\n\n循环链表\n单向\n双向\n\n\n\n对比\n\n\n\n链表结构\n特点\n适用场景\n\n\n\n\n单链表\n结点=数据+后继指针\n1.插入和删除数据非常快速2.想要随机访问第k个元素需要逐个结点遍历\n\n\n双链表\n尾结点指针指向链表头结点\n从链尾到链头比较方便，要处理的数据具有环形结构\n\n\n循环链表\n后继指针next+前驱指针prev\n1.额外两个空间2.支持双向遍历 —&gt; $O(1)$时间复杂度情况下找到前驱结点\n\n\n\n\n删除操作中的对比\n删除的情况\n\n删除结点中“值等于某个给定值”的结点\n删除给定指针指向的结点\n\n链表情况\n\n第一种情况，单链表和双链表，为了查找到值等于给定值的结点，都需要从头结点开始逐个遍历\n第二种情况\n单链表：需要找到前驱结点\n双链表：保存前驱结点指针，不需要逐个遍历\n\n\n\n空间-时间辩证关系\n空间换时间：内存空间充足，更加追求代码执行速度\n时间换空间：内存比较紧缺\n\n链表vs数组性能比拼\n解答开篇如何基于链表实现LRU缓存淘汰算法？\n维护一个有序单链表，越靠近链表尾部结点是越早之前访问的，当有一个新的数据被访问时，从链表头开始顺序遍历链表\n\ngraph TD\n维护一个有序单链表 -->数据已被缓存在链表中 --> 遍历得到数据对应结点.从原来位置删除.插入到链表头部\n维护一个有序单链表 -->数据未被缓存在链表中 -->缓存未满 -->将此结点直接插入到链表头部\n数据未被缓存在链表中 -->缓存已满 --> 链表尾结点删除.将新的数据结点插入链表头部\n\n","slug":"DSA/C6  链表(上)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"4d2b8ed889fbd369f571fec1667609a5","title":"DSA7 Linked List2","content":"链表（下）：如何轻松写出正确的链表代码？几个技巧\n理解指针或引用的含义\n\n将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量\n\n\n警惕指针丢失和内存泄漏\n\n情况\n\n代码\n\n\np-&gt;next = x;  // 将p的next指针指向x结点；\nx-&gt;next = p-&gt;next;  // 将x的结点的next指针指向b结点；\n\n\n结果就是：链表断成两半\n\n\n\n\n\n利用哨兵简化实现难度\n\n\n\n\n重点留意边界条件处理\n链表为空\n链表只包含一个结点\n链表只包含两个结点\n头尾结点\n\n\n举例画图、辅助思考\n\n\n\n\n","slug":"DSA/C7 链表(下)","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"d631f4f7e4cb3f5655d7dbbeb5a6587c","title":"DSA9 Quene","content":"队列：队列在线程池等有限资源中的应用问题引入当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？\n如何理解“队列”？\n先进先出\n入队enqueue()\n出队dequeue()\n\n\n几种队列\n\n\n\n队列类型\n特点\n适用场景\n\n\n\n\n顺序队列\n\n\n\n\n链式队列\n\n\n\n\n循环队列\n\n\n\n\n\n","slug":"DSA/C9 队列","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"},{"id":"a75362207a5dc66d40d312cda296e3d4","title":"DSA8 Stack","content":"栈：如何实现浏览器的前进和后退功能如何理解“栈”\n\n后进先出\n“操作受限”的线性表\n\nWhy 栈？\n数组或链表暴露了太多操作接口，灵活自由但也比较不可控，容易出错\n\n当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。\n如何实现一个栈\n数组实现：顺序栈\n链表实现：链式栈\n\n// 基于数组实现的顺序栈\npublic class ArrayStack &#123;\n  private String[] items;  // 数组\n  private int count;       // 栈中元素个数\n  private int n;           //栈的大小\n\n  // 初始化数组，申请一个大小为n的数组空间\n  public ArrayStack(int n) &#123;\n    this.items = new String[n];\n    this.n = n;\n    this.count = 0;\n  &#125;\n\n  // 入栈操作\n  public boolean push(String item) &#123;\n    // 数组空间不够了，直接返回false，入栈失败。\n    if (count == n) return false;\n    // 将item放到下标为count的位置，并且count加一\n    items[count] = item;\n    ++count;\n    return true;\n  &#125;\n  \n  // 出栈操作\n  public String pop() &#123;\n    // 栈为空，则直接返回null\n    if (count == 0) return null;\n    // 返回下标为count-1的数组元素，并且栈中元素个数count减一\n    String tmp = items[count-1];\n    --count;\n    return tmp;\n  &#125;\n&#125;\n支持动态扩容的顺序栈底层依赖一个支持动态扩容的数组\n当栈满了之后，申请一个更大的数组，将原来的数据搬移到新数组中\n\n栈的一些应用函数调用int main() &#123;\n   int a = 1; \n   int ret = 0;\n   int res = 0;\n   ret = add(3, 5);\n   res = a + ret;\n   printf(\"%d\", res);\n   reuturn 0;\n&#125;\n\nint add(int x, int y) &#123;\n   int sum = 0;\n   sum = x + y;\n   return sum;\n&#125;\n\n表达式求值\n括号匹配graph TD\n用栈来保存未匹配的左括号\n--> 从左到右依次扫描字符串--> 扫描到左括号 -->压入栈中 -->栈中内容 --> 为空-->字符串为合法格式\n从左到右依次扫描字符串--> 扫描到右括号 -->取出一个左括号-->栈中内容 --> 不为空-->字符串为非法格式\n\n\n解答开篇顺序查看了 a，b，c 三个页面，我们就依次把 a，b，c 压入栈\n\n当你通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，我们就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y\n\n这个时候你又想看页面 b，于是你又点击前进按钮回到 b 页面，我们就把 b 再从栈 Y 中出栈，放入栈 X 中\n\n这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y\n\n","slug":"DSA/C8 栈","date":"2021-07-20T03:46:33.000Z","categories_index":"DSA","tags_index":"DSA","author_index":"Rambo"}]