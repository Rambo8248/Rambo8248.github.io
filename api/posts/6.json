{"total":74,"pageSize":12,"pageCount":7,"data":[{"title":"DSA37 Greedy Algorithm","uid":"a9e32e2621fbdc03b2a42efbcf0ce8e5","slug":"DSA/C37 贪心算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:30.880Z","comments":true,"path":"api/articles/DSA/C37 贪心算法.json","cover":[],"text":"贪心算法：如何用贪心算法实现Huffman压缩编码？几个基本的算法思想 贪心算法 Huffman Coding Prim和Kruskal最小生成树算法 Dijkstra单源最短路径 分治算法 回溯算法 动态规划 本章如何利用贪心算法实现对数据压缩编码，有效节省数据存储空间 如何理...","link":"","photos":[],"count_time":{"symbolsCount":678,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA28 Heap","uid":"1ecdd1e00fb73a51c0511d1921f5b63c","slug":"DSA/C28 堆和堆排序","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:25:33.089Z","comments":true,"path":"api/articles/DSA/C28 堆和堆排序.json","cover":[],"text":"堆和堆排序：为什么说堆排序没有快速排序快？特殊的树：堆(Heap) 堆排序 原地 时间复杂度为$O(nlogn)$ 实际软件开发中，快速排序的性能要比堆排序好 如何理解堆？ 完全二叉树 堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值 大顶堆 小顶堆 如何实现一...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA33 String Match2","uid":"0ec81c6d3aa8372bc4bd0a74846f2430","slug":"DSA/C33 字符串匹配基础(中)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:26:35.770Z","comments":true,"path":"api/articles/DSA/C33 字符串匹配基础(中).json","cover":[],"text":"字符串匹配基础（中）：如何实现文本编辑器中的查找功能？文本编辑器中的查找替换功能 BM算法，Boyer-Moore KMP算法 BM算法核心思想 当模式串和主串某个字符不匹配的时候，能够跳过一些可定不会匹配的情况，将模式串往后多滑动几位 算法原理分析坏字符规则 graph TD ...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA40 回溯算法","uid":"cab4c9495dd444030efce39574aea74e","slug":"DSA/C39 回溯算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:28:02.190Z","comments":true,"path":"api/articles/DSA/C39 回溯算法.json","cover":[],"text":"回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想引入回溯算法的应用 深度优先搜索 经典数学问题 数独 八皇后 0-1背包 图的着色 旅行商问题 全排列 如何理解回溯算法笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA40 初识动态规划","uid":"7315897fe4af98b9a72088541e465f37","slug":"DSA/C40 初识动态规划","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:28:16.832Z","comments":true,"path":"api/articles/DSA/C40 初识动态规划.json","cover":null,"text":"初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？引入 双十一满200减50，选出来的商品价格总和最大程度接近满减条件，极大限度薅羊毛 动态规划学习路线动态规划比较适合用来求解最优问题，比如求最大值、最小值等 初识动态规划 两个经典动态规划问题模型 为什么动态规划 动态规划解...","link":"","photos":[],"count_time":{"symbolsCount":220,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA38 分治算法","uid":"28170d54ceec31fbbfec4bc7706417d1","slug":"DSA/C38 分治算法","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:48.625Z","comments":true,"path":"api/articles/DSA/C38 分治算法.json","cover":[],"text":"分治算法：谈一谈大规模计算框架MapReduce中的分治思想引入Google大数据处理三驾马车 MapReduce GFS Bigtable 如何理解分治算法核心：分而治之 将原问题划分成n个规模较小，并且结构与原问题相似的子问题 递归地解决这些子问题 然后合并其结果 分治算法的...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA4 Complexity Analysis2","uid":"fc19127153caeb9baa595a1d01d3f0d7","slug":"DSA/C4 复杂度分析(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:18:54.464Z","comments":true,"path":"api/articles/DSA/C4 复杂度分析(下).json","cover":null,"text":"复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度// n表示数组array的长度 int find(int[] array, int n, int x) &#123; int i = 0; int pos = -1; for (; i &lt; n; ++i) &#123;...","link":"","photos":[],"count_time":{"symbolsCount":906,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA36 AC自动机","uid":"06d10bcf0dacb0e855883f8036c8872c","slug":"DSA/C36 AC自动机","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:16.033Z","comments":true,"path":"api/articles/DSA/C36 AC自动机.json","cover":[],"text":"AC自动机：如何用多模式串匹配实现敏感词过滤功能？引入敏感词过滤功能是如何实现的？ 字符串匹配算法 通过维护一个敏感词的字典，当用户输入一段文字内容之后，通过字符串匹配算法查找用户输入的文字，包含敏感词则用“*”替换掉 访问量巨大的网站来说，如何实现一个高性能的敏感词过滤系统？ ...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA35 Trie Tree","uid":"6ac917baf75da522e92f8103dc9fe5ea","slug":"DSA/C35 Trie树","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:27:00.561Z","comments":true,"path":"api/articles/DSA/C35 Trie树.json","cover":[],"text":"Trie树：如何实现搜索引擎的搜索关键词提示功能？搜索引擎的搜索关键词提示功能 什么是Trie树？ 字典树，树形结构 专门处理字符串匹配的数据结构 解决在一组字符串集合中快速查找某个字符串的问题 先看看Trie树长什么样 本质：利用字符串之间公共前缀，将重复前缀合并在一起 6个字...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA7 Linked List2","uid":"4d2b8ed889fbd369f571fec1667609a5","slug":"DSA/C7 链表(下)","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:19:36.392Z","comments":true,"path":"api/articles/DSA/C7 链表(下).json","cover":[],"text":"链表（下）：如何轻松写出正确的链表代码？几个技巧 理解指针或引用的含义 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量 警惕指针丢失和内存泄漏 情况 代码 p-&gt;next =...","link":"","photos":[],"count_time":{"symbolsCount":310,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA5 Array","uid":"be65ef045a392dbdd6233f994cc17ed3","slug":"DSA/C5 数组","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:19:05.261Z","comments":true,"path":"api/articles/DSA/C5 数组.json","cover":[],"text":"数组：为什么很多编程语言中数组都从0开始编号？如何实现随机访问？ 数组(array) 一种线性表数据结构。用一组连续的内存空间，来存储一组具有相同类型的数据 线性表与非线性表 线性表 数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向 非线性表 数据之间并不是简...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DSA9 Quene","uid":"d631f4f7e4cb3f5655d7dbbeb5a6587c","slug":"DSA/C9 队列","date":"2021-07-20T03:46:33.000Z","updated":"2021-08-26T09:20:09.920Z","comments":true,"path":"api/articles/DSA/C9 队列.json","cover":[],"text":"队列：队列在线程池等有限资源中的应用问题引入当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？ 如何理解“队列”？ 先进先出 入队enqueue() 出队dequeue() ...","link":"","photos":[],"count_time":{"symbolsCount":195,"symbolsTime":"1 mins."},"categories":[{"name":"DSA","slug":"DSA","count":41,"path":"api/categories/DSA.json"}],"tags":[{"name":"DSA","slug":"DSA","count":41,"path":"api/tags/DSA.json"}],"author":{"name":"Rambo","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Still Water Runs Deep","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}